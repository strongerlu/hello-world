1
00:00:00,001 --> 00:00:04,836
欢迎收看斯坦福大学公开课

2
00:00:04,838 --> 00:00:07,405
本字幕由志愿者义务贡献

3
00:00:11,277 --> 00:00:15,946
>> Okay, well, welcome to lecture four of CS193P,
欢迎参加斯坦福大学2015年冬季学期的 CS193P 课程

4
00:00:15,948 --> 00:00:18,748
Stanford Winter of 2015.
CS193P 课程

5
00:00:18,750 --> 00:00:21,284
So, I've been doing all demo up until now,
在今天以前，我们一直都在写 demo，

6
00:00:21,286 --> 00:00:24,553
and now we're going to be doing all slides today.
而今天，我们将会全部通过幻灯片学习

7
00:00:24,555 --> 00:00:28,724
So, I have a lot of stuff to talk about
我将会讲到很多东西

8
00:00:28,726 --> 00:00:31,143
most of this, although not all of it,
大部分，但不是全部，

9
00:00:31,144 --> 00:00:33,561
is covered in your reading assignments, okay?
都在你的阅读任务中

10
00:00:33,563 --> 00:00:35,496
But here I'm going to
在这里我会尽量把

11
00:00:35,497 --> 00:00:37,430
try to highlight the things that are pretty important, and
重点强调一些重要的部分

12
00:00:37,433 --> 00:00:39,066
also just show you some stuff that are not in
并且也会给你看一些

13
00:00:39,068 --> 00:00:41,802
that reading assignment that you kinda need to know.
并不包含在阅读任务中，但你仍然需要知道的东西

14
00:00:41,804 --> 00:00:43,336
So this is definitely not a substitute for
但这绝对不能代替阅读

15
00:00:43,338 --> 00:00:46,472
the reading you'll still need to do the reading in order to
你仍然需要通过阅读

16
00:00:46,474 --> 00:00:49,875
kinda get the, the details of a lot of this stuff.
来掌握这些的细节部分

17
00:00:49,877 --> 00:00:54,613
So but this hopefully will kinda get you focused in on,
希望这节课可以让你注意在

18
00:00:54,615 --> 00:00:58,066
on the key stuff.
关键的东西上

19
00:00:58,067 --> 00:01:01,518
All right, so first, I wanna talk about
好的，那么我将讲讲

20
00:01:01,521 --> 00:01:05,589
Optionals and enums, so now that you know what an enum is.
Optional 和 enum，你已经知道 enum 是什么了

21
00:01:05,591 --> 00:01:08,425
I can tell you what an Optional really is okay?
那么我可以告诉你 Optional 到底是什么了

22
00:01:08,427 --> 00:01:10,994
An Optional is just an enum, okay?
Optional 就是 enum，

23
00:01:10,996 --> 00:01:15,098
It's a very simple enum it's a generic kind of like Array.
就是一个非常简单的 enum，它是泛型的，类似于 Array

24
00:01:15,100 --> 00:01:15,998
You know, have an Array,
比如一个 Array ，

25
00:01:16,000 --> 00:01:17,666
you specify the type of thing in it,
你指定了其中的类型，

26
00:01:17,668 --> 00:01:19,301
Optionals exactly the same, okay?
Optional 跟它完全一样

27
00:01:19,303 --> 00:01:20,335
It's a generic.
就是泛型

28
00:01:20,337 --> 00:01:22,637
You specify the type of Optional it is.
你指定了 Optional 的类型是什么

29
00:01:22,639 --> 00:01:26,173
And that type, which is T here in this little enum,
而此类型，在这个 enum 中的 T

30
00:01:26,175 --> 00:01:29,376
is just the type of the associated value, you know,
就是关联值的类型

31
00:01:29,378 --> 00:01:31,578
that enums can have associated values.
enums 可以关联各种值

32
00:01:31,580 --> 00:01:35,882
So that's just the type that, if the Optional is not nil.
如果 Optional 不是 nil，这就是它的类型

33
00:01:35,884 --> 00:01:38,751
That's what you get so that's all an enum is and
你就可以获取到它。这就是 enum

34
00:01:38,753 --> 00:01:42,054
so for example, this is what it would look like if we
举个例子

35
00:01:42,056 --> 00:01:45,724
used the enum notation to do an Optional.
使用一个 enum 实现一个 Optional 看起来会像是这样

36
00:01:45,726 --> 00:01:49,561
Saying you know, x which is an enum or is an Optional String,
你可以看到，x 可以是一个 enum 或者是一个 Optional String，

37
00:01:49,563 --> 00:01:52,130
which nil would just be saying x equals Optional
如果是 nil 可以这样表示：

38
00:01:52,132 --> 00:01:53,497
angle bracket String dot none.
x = Optional<String>.None

39
00:01:54,800 --> 00:01:56,200
Okay?

40
00:01:56,201 --> 00:01:57,601
Or, if you're sending it to not be know you
或者你可以将其赋值

41
00:01:57,603 --> 00:02:00,403
would say Optional angle bracket String dot Some，
x = Optional<Sting>.Some()

42
00:02:00,405 --> 00:02:02,705
parentheses, the associated value, which would be hello.
关联值，也就是 "Hello".

43
00:02:04,408 --> 00:02:05,607
That make sense?
很合理吧？

44
00:02:05,609 --> 00:02:07,709
So Optional really actually super simple.
Optional 其实就是这么简单

45
00:02:07,711 --> 00:02:10,478
With a question mark and exclamation point,
由问号及感叹号组成，

46
00:02:10,480 --> 00:02:13,180
I know that makes it seem like, it's just so
我知道这看起来

47
00:02:13,182 --> 00:02:17,451
really complicated, but it's pretty simple really it's just
非常复杂，但实际上非常简单

48
00:02:17,453 --> 00:02:20,787
syntax sugar, syntactic sugar to do this Optional.
这只是语法糖，为了实现 Optional

49
00:02:20,789 --> 00:02:25,124
Now the unwrapping, really just looks like this It's just
现在到解包，真的这看起来

50
00:02:25,126 --> 00:02:28,894
a switch and the case of some, you give the value back.
就只是 switch 与 case，在 "Some" 的情况下你可以得到其值

51
00:02:28,896 --> 00:02:32,230
In the case of none, you raise an exception, okay?
在 "None" 的情况下，就会抛出异常

52
00:02:32,232 --> 00:02:36,034
And simple as that.
就这么简单

53
00:02:36,036 --> 00:02:38,836
That's why it crashes when you unwrap something that's
这也是为什么当你解包一个 nil 的时候会崩溃

54
00:02:38,838 --> 00:02:41,405
nil, okay?

55
00:02:41,407 --> 00:02:45,242
So that's Optional all right, so Array, I just wanna.
这就是一个 Optional 。对于 Array

56
00:02:45,244 --> 00:02:47,744
We covered this so I'm gonna really fast through this but
我们已经概括了一次，所以我会快点进行这部分

57
00:02:47,746 --> 00:02:50,480
Arrays, the syntax there is the same, right?
Array ，这里的语法是相同的，对吧？

58
00:02:50,482 --> 00:02:51,781
That square bracket thing,
这里的方括号

59
00:02:51,783 --> 00:02:54,050
that means exactly the same thing.
这就意味着他们是相同的

60
00:02:54,052 --> 00:02:59,054
Also you can't append or modify in any way
并且你不能通过任何方式增加或修改

61
00:02:59,056 --> 00:03:02,257
an Array that is a let, right, that's a constant Array.
一个声明为 let 的 Array ，因为这是常量 Array

62
00:03:02,259 --> 00:03:04,992
I just wanna make it clear that defining an Array to
我在这里重申一下，通过 let 将一个

63
00:03:04,994 --> 00:03:07,328
be a constant by saying let something equal
Array 声明为常量

64
00:03:07,330 --> 00:03:09,229
an Array versus var something equal an Array,
与声明一个 Array 为 var

65
00:03:09,231 --> 00:03:12,833
means that it's immutable, so you can't do append or insert,
声明为 let 意味着它是不可变的，所以你不能增加或插入，

66
00:03:12,835 --> 00:03:15,468
or anything else that you could do on a mutable Array.
或任何你想要改变这个 Array 的操作

67
00:03:15,470 --> 00:03:17,337
Also, of course,
当然

68
00:03:17,338 --> 00:03:19,205
if you access an Array with the square brackets and
如果你通过方括号访问一个 Array

69
00:03:19,207 --> 00:03:21,540
try to pull out something that's outside the bounds of
然后尝试着获取一个超出了 Array 范围东西

70
00:03:21,542 --> 00:03:23,809
the Array, this Array only has four animals in it and
一个 Array 只有四种动物在里面，

71
00:03:23,811 --> 00:03:27,145
I'm trying to get animal five that's gonna crash.
我想要获取第五种，那么就会崩溃

72
00:03:27,147 --> 00:03:28,279
Array index out of bounds,
Array 访问越界

73
00:03:28,281 --> 00:03:30,981
just like pretty much any language you've used.
你以前使用过的语言也会是这样

74
00:03:32,551 --> 00:03:33,850
How to enumerate an Array.
如何枚举一个 Array 呢

75
00:03:33,852 --> 00:03:35,885
If you wanted to go through every single item
如果你想要获取在 Array 中的每一个对象

76
00:03:35,887 --> 00:03:39,655
in an Array and look at it, you can use for in, okay?
你可以使用 for in，

77
00:03:39,657 --> 00:03:43,526
So you just say for, some variable you want,
就比如 for，一个你需要的变量，

78
00:03:43,528 --> 00:03:46,061
in your Array, and then inside there,
in Array，然后在这里面

79
00:03:46,063 --> 00:03:49,131
that'll be your value, okay pretty obvious.
就是你想要的值了

80
00:03:49,133 --> 00:03:51,433
I put this here mostly to compare it to the next slide,
我放在这里主要是为了与

81
00:03:51,435 --> 00:03:54,902
which is Dictionary so Dictionary again,
接下来的 Dictionary 进行对比

82
00:03:54,904 --> 00:03:56,470
that's where a bracket thing is an alternate for
这里的括号也是起着同样的作用

83
00:03:56,472 --> 00:03:59,406
the exact same thing so if I had a nice
有一个 Dictionary

84
00:03:59,408 --> 00:04:02,576
Dictionary here I can create a Dictionary.
我创建了一个 Dictionay

85
00:04:02,578 --> 00:04:04,177
Using this square bracket notation,
使用了方括号标记

86
00:04:04,179 --> 00:04:07,146
which is just square bracket, key colon value, comma
[key:value, key:value]

87
00:04:07,148 --> 00:04:08,914
key colon value okay, you know that.
你懂的

88
00:04:08,916 --> 00:04:12,084
And you also know that if I access a Dictionary with
如果我通过方括号访问一个 Dictionay，

89
00:04:12,086 --> 00:04:14,519
the square bracket, it returns an Optional and
它会返回一个 Optional

90
00:04:14,521 --> 00:04:17,722
that's because, for example here, I'm looking up PAC ten
举个例子，我要在 pac10teamRankings 中寻找 Ohio State

91
00:04:17,724 --> 00:04:21,192
team Ohio State obviously that is not.
明显就没有

92
00:04:21,194 --> 00:04:23,961
It packed ten team so it's not in the Dictionary.
这里只包含了十个队伍，而它不在这个 Dictionay 里

93
00:04:23,963 --> 00:04:25,929
So it's going to return nil, okay?
那么就应该返回 nil 对吧？

94
00:04:25,931 --> 00:04:27,931
So, that's why when you access a Dictionary,
这就是为什么你访问一个 Dictionay，

95
00:04:27,933 --> 00:04:29,299
it comes back it's an Optional.
它会返回一个 Optional

96
00:04:30,769 --> 00:04:32,868
To enumerate Dictionary you use a tuple.
枚举 Dictionay 你需要使用 tuple

97
00:04:33,871 --> 00:04:36,171
Okay, so you say for, the tuple,
for tuple

98
00:04:36,173 --> 00:04:39,207
key com of value in the Dictionary.
(key, value) in  Dictionay

99
00:04:39,209 --> 00:04:41,376
And inside there, key and value will both be set.
然后在里面，key 与 value 都会被设置好

100
00:04:41,378 --> 00:04:46,947
Okay, that's really easy way to enumerate Dictionaries.
这是非常简单的枚举 Dictionay 的方法

101
00:04:48,083 --> 00:04:53,686
Sence? All right I'm gonna teaching about new struct that
那接下来我会教你们一个之前没见过的

102
00:04:53,688 --> 00:04:59,358
you haven't seen called Range. A Range is just two points
新的结构体 Range，Range 是一个包含一种合理类型的两个点

103
00:04:59,360 --> 00:05:01,893
of a sensible type, so a starting point and an ending
一个是起始点，另一个是终止点

104
00:05:01,895 --> 00:05:03,528
point is exactly what you think a range would be.
正如你们所想的范围那样

105
00:05:03,530 --> 00:05:07,098
Now I say a sensible type here because, you know,
之所以称为合理类型

106
00:05:07,100 --> 00:05:10,568
the sensible type depends on what you're talking about for
取决于你怎么看

107
00:05:10,570 --> 00:05:12,403
an Array, the sensible type is an Int,
对于 Array 来说，这个合理的类型可以是 Int

108
00:05:12,405 --> 00:05:14,805
but for other things like a String, it's not, and
但是对于别的比如 String 来说，它就不是了

109
00:05:14,807 --> 00:05:16,106
we're gonna talk about that in a minute.
我们稍后将会讲解这些知识

110
00:05:17,409 --> 00:05:21,844
Range is also a generic, just like Array or
Range 跟 Array 或者 Optional enum 一样

111
00:05:21,846 --> 00:05:24,413
like that Optional enum.
是泛型的

112
00:05:24,415 --> 00:05:28,783
And so it takes the type of thing so the Range again that.
所以它包含了一个类型

113
00:05:28,785 --> 00:05:32,520
To specify a range in an Array would be Range, angle bracket,
在 Array 中指定一个范围的方法是 Range<Int>

114
00:05:32,522 --> 00:05:35,389
Int because Ints are how you index an Array.
因为 Array 是通过 Int 索引的

115
00:05:35,391 --> 00:05:36,857
So, if you were gonna specify a Range in
所以，如果你想要在数组中声明 Range

116
00:05:36,859 --> 00:05:38,758
an Array they would be Ints, okay?
它就需要是 Int 类型的

117
00:05:38,760 --> 00:05:40,693
And it's approximately what I put here it's
我在这里讲的大概差不多了

118
00:05:40,695 --> 00:05:44,663
not exactly this, but as far as given what, you know,
但不完全是，但是就目前你们了解的知识来看

119
00:05:44,665 --> 00:05:47,966
so far this is the best I can describe it to you.
这是我能想到的最好的描述方式

120
00:05:47,968 --> 00:05:51,069
It's just a struct that has a startIndex and endIndex and
它仅仅是一个包含了 startIndex 和 endIndex 的结构体

121
00:05:51,071 --> 00:05:53,271
it is a struct you can go and get those values and
它也是一种能让你获取

122
00:05:53,273 --> 00:05:55,940
set those values out of there so
和设置值的结构体

123
00:05:55,942 --> 00:06:01,145
Array's Range would be a range of Int. String, it's,
所以 Array 的 Range 是 Int 的一个取值区间 至于 String

124
00:06:01,147 --> 00:06:04,047
you would think that String would also be.
你们可能会想，对于 String 也是这样的

125
00:06:04,049 --> 00:06:07,017
You see sub ranges of Strings would also be specified by
可以看到 String 的子串可以通过 Int 去指定

126
00:06:07,019 --> 00:06:08,451
an Int, but in not, it not.
但也不一定

127
00:06:08,453 --> 00:06:11,420
There's a special type called String.index,
这里有一种特殊的类型叫做 String.index

128
00:06:11,422 --> 00:06:12,654
which is an index into a String,
它是一种对 String 的索引

129
00:06:12,656 --> 00:06:16,224
I'm gonna talk all about that in a later slide, okay?
我将会在后面的幻灯片中讲到

130
00:06:16,226 --> 00:06:18,960
So Ranges, just like Arrays and
所以 Range 就像 Array 和

131
00:06:18,962 --> 00:06:22,530
Dictionaries, we don't usually say Range, angle bracket,
Dictionay 一样，但我们一般不会用 Range<Int> = XXX，

132
00:06:22,532 --> 00:06:26,867
Int equals something we use this special syntax.
我们使用这种特殊的语法

133
00:06:26,869 --> 00:06:29,569
And the special syntax is this three dots, or
这个特殊的语法是 ... ，或者

134
00:06:29,571 --> 00:06:32,739
two dots and a less than sign.
..<

135
00:06:32,741 --> 00:06:37,009
Okay, so the three dots means a range from the first thing,
... 意味着

136
00:06:37,011 --> 00:06:39,778
oh, no, on the left of the dots, to the other thing on
从点的左边到点的右边

137
00:06:39,780 --> 00:06:41,480
the right of the dots. That's the startIndex and
也就是 startIndex 和

138
00:06:41,482 --> 00:06:44,015
the endIndex, and it includes them both.
endIndex，它包含这两个值

139
00:06:44,017 --> 00:06:47,218
Includes both the start and end, whereas the other one,
包含开头和结尾

140
00:06:47,220 --> 00:06:49,920
two dot dot less than means it includes the first one, but
..< 意味着它只包含了开头，但是

141
00:06:49,922 --> 00:06:51,355
it does not include the second one.
没有包含结尾

142
00:06:51,357 --> 00:06:54,591
So it's an open-ended Range, okay cuz those,
所以它是一个有左闭右开的区间

143
00:06:54,593 --> 00:06:56,092
both of those kind of Ranges are common.
这些都是常用的 Range 的种类

144
00:06:57,028 --> 00:07:00,463
So that's how we specify a Range 99% of the time,
也是你们在 99% 的时候定义一个 Range 的方法

145
00:07:00,465 --> 00:07:03,298
we don't use the Range struct to do it
我们不使用 Range 的结构来定义

146
00:07:03,300 --> 00:07:05,834
although you can you could create a Range struct.
尽管可以创建一个 Range 的结构体

147
00:07:05,836 --> 00:07:08,903
And you could pass it as an argument to anything that
而且你们可以将它作为参数传递给任何接受 Range 的地方

148
00:07:08,905 --> 00:07:12,040
takes these dot, dot, dots. You could put an actual Range in
你们可以使用真正的 Range 结构

149
00:07:12,042 --> 00:07:13,941
there as well, okay they're the same thing.
他们是同样的

150
00:07:13,943 --> 00:07:16,127
It's just the dot, dot,
... 对你们而言只是一种

151
00:07:16,128 --> 00:07:18,312
dots are syntaxed to create that Range for you, okay and
创建 Range 的语法

152
00:07:18,314 --> 00:07:20,781
the things on either side of the dot, dot, dot.
在 ... 的两侧

153
00:07:20,783 --> 00:07:21,799
You know, it depends on
它取决于

154
00:07:21,800 --> 00:07:22,816
what kind of Range you're trying to create.
你要创建哪种类型的 Range

155
00:07:22,818 --> 00:07:24,150
If you're creating an Int Range.
如果你要创建一个 Int 类型的 Range

156
00:07:24,152 --> 00:07:27,486
A Range of angle bracket Int, then they'd be Ints, okay?
那么 Range<Int>，然后 Range 就是 Int 类型的了

157
00:07:27,488 --> 00:07:28,854
But if you're doing a String,
但是如果你们正在处理 String

158
00:07:28,856 --> 00:07:30,188
they have to be String.indexes.
那就必须使用 String.index 类型了

159
00:07:30,190 --> 00:07:33,591
And that's a little harder to create, because a String.index
而且创建这种类型的 Range 有一点点难度，因为 String.index 类型

160
00:07:33,593 --> 00:07:36,294
can't be created from a numeric literal.
不能通过数字去创建

161
00:07:36,296 --> 00:07:38,362
You have to create it programmatically, so
你必须需要一点编程技巧去创建，所以

162
00:07:38,364 --> 00:07:39,963
we'll talk about that.
我们将会在大概十张幻灯片后

163
00:07:39,965 --> 00:07:45,602
In about ten slides or so. Okay and
来讨论这个

164
00:07:45,604 --> 00:07:48,438
you can enumerate a Range using for-in just like we
你们可以 通过 for-in 来遍历一个 Range，就像我们

165
00:07:48,440 --> 00:07:50,906
can with our raising Dictionaries there okay?
使用 Dictionay 一样

166
00:07:50,908 --> 00:07:54,610
All right,
好了

167
00:07:54,611 --> 00:07:58,313
other classes, besides Arrays, Dictionaries, Range. NSObject.
除了 Array, Dictionay, Range，接下来讨论其他的类，比如 NSObject

168
00:07:58,315 --> 00:08:00,982
So NSObject was the the base class for
NSObject 在 Objective-C 中

169
00:08:00,984 --> 00:08:02,817
all of Objective-C classes.
是所有类的基类

170
00:08:02,819 --> 00:08:05,119
In Swift we don't really have a base class for
在 Swift 中，我们并没有

171
00:08:05,121 --> 00:08:07,154
all Swift classes.
这样一个基类

172
00:08:07,156 --> 00:08:10,757
however, there are some kind of advanced features in
然而，它有一些在 iOS 中的

173
00:08:10,759 --> 00:08:13,726
iOS that require,
高级特性

174
00:08:13,728 --> 00:08:18,163
even your Swift class to inherit from NSObject.
你的 Swift 类也可以继承自 NSObject

175
00:08:18,165 --> 00:08:19,598
I can't really talk about them,
我现在还不能跟你们讨论这些

176
00:08:19,599 --> 00:08:21,032
because there's other things you need to know for
因为还有些别的你们必须得知道的东西

177
00:08:21,035 --> 00:08:23,401
me to even explain them to you but
我得去解释

178
00:08:23,403 --> 00:08:25,536
down the road that will happen.
学下去你们就知道了

179
00:08:25,538 --> 00:08:27,805
It really doesn't hurt to make your Swift class be
让你们的 Swift 类继承自 NSObject 没什么麻烦的

180
00:08:27,807 --> 00:08:29,406
a subclass of NSObject, so we could have
所以我们可以让

181
00:08:29,408 --> 00:08:31,808
made CalculatorBrain be a subclass of NSObject.
CalculatorBrain 类继承自 NSObject

182
00:08:31,810 --> 00:08:33,109
Wouldn't hurt, and
没有任何影响，而且

183
00:08:33,111 --> 00:08:35,845
in the future, once we learn these advance things,
在将来，一旦我们学到这些进阶的东西

184
00:08:35,847 --> 00:08:38,948
it'd be nice to be able to do those advanced features with
我们将可以使用一些高级的特性来编写

185
00:08:38,950 --> 00:08:41,617
CalculatorBrain so it's kinda one.
CalculatorBrain

186
00:08:41,619 --> 00:08:42,851
Can feel free I'm not sure what to
唔，我也不知道该怎么说

187
00:08:42,853 --> 00:08:45,220
say the best practice here is to always have your Swift
就是，在 iOS 中，最好让你们所有的 Swift 类

188
00:08:45,222 --> 00:08:49,090
classes inherit from NSObject. All the classes in iOS,
都继承自 NSObject. 在 iOS 中，所有的类，

189
00:08:49,092 --> 00:08:50,975
like UIViewController, and
比如 UIViewController，还有其他

190
00:08:50,976 --> 00:08:52,859
all those, they all inherit from NSObject eventually.
其实最后都是继承自 NSObject

191
00:08:52,862 --> 00:08:55,462
It's the super class of all of them there's not
它是所有类的基类

192
00:08:55,464 --> 00:08:59,599
really much in NSObject anymore that matters.
关于 NSObject，没有其他需要讲的了

193
00:08:59,601 --> 00:09:03,002
But like I say, there's these advanced features but.
但是，就像我说的，有一些高级特性

194
00:09:03,004 --> 00:09:04,637
Then there's NSNumber,
接下来是 NSNumber

195
00:09:04,638 --> 00:09:06,271
you've actually briefly seen NSNumber.
你们之前其实已经见过 NSNumber

196
00:09:06,273 --> 00:09:09,908
NSNumber is just a generic number-holding class, it just holds a number.
它只是一个装数字的类

197
00:09:09,910 --> 00:09:12,677
That's all it does on it has a ton of methods on and I'm not
它里面有很多方法

198
00:09:12,679 --> 00:09:15,013
gonna go through and here you can look in the documentation.
但是我不打算去讲，你们可以自己去看文档

199
00:09:15,015 --> 00:09:17,114
But, the methods are things like doubleValue.
但是，这些方法，比如 doubleValue

200
00:09:17,116 --> 00:09:20,317
intValue which is give me your value of yourself as
intValue ，会将他们自身的值

201
00:09:20,319 --> 00:09:21,818
an Int, as a Double etc.
以 Int, Double 等类型返回给我们

202
00:09:23,121 --> 00:09:26,322
In Swift, we don't really use this very much,
在 Swift 中，我们不会用太多这些东西

203
00:09:26,324 --> 00:09:28,324
because it's strongly typed and,
因为 Swift 是强类型

204
00:09:28,326 --> 00:09:31,527
so we're using types like Int and Double.
我们直接用像 Int 、 Double 这样的类型

205
00:09:31,529 --> 00:09:35,997
But in Objective-C APIs, there's no NSNumbers lying
但在 Objective-C 的 API 中，没有遍地的 NSNumbers 类型

206
00:09:35,999 --> 00:09:39,701
around and so you kinda need to know about it.
这一点是你们要了解的

207
00:09:39,703 --> 00:09:42,069
I'm gonna talk a little bit later about the fact that
接下来我会多讲一点强类型的内容

208
00:09:42,071 --> 00:09:44,772
all those Swift types are kinda magically bridged
所有这些 Swift 类型都通过巧妙桥接到 NSNumber 类型

209
00:09:44,774 --> 00:09:48,075
to NSNumber, okay those ints and Doubles.
比如 Int, Double 等

210
00:09:48,077 --> 00:09:50,076
So, you really don't even have to worry about NSNumber.
所以你甚至不必担心 NSNumber

211
00:09:50,078 --> 00:09:53,880
Unless you use NSNumberFormatter that we used in
除非你要用作业中提到的 NSNumberFormatter

212
00:09:53,882 --> 00:09:58,117
the assignment, because that thing returns an NSNumber.
因为它会返回一个 NSNumber 类型的值

213
00:09:58,119 --> 00:10:00,652
>> So it there's no like NSObject parallel in Swift,
>>（学生提问）

214
00:10:00,654 --> 00:10:02,721
is there a way to make like an Array that holds
（学生提问）

215
00:10:02,723 --> 00:10:04,773
any kind of [CROSSTALK] ?
（学生提问）

216
00:10:04,774 --> 00:10:06,824
>> Yep, so the question is, if there's no NSObject, well,
嗯，他的问题是，如果没有 NSObject （那么该怎么处理 NSObject 相关的东西呢）

217
00:10:06,826 --> 00:10:09,060
it wouldn't really matter about NSObject.
其实没有 NSObject 并不是造成困扰的所在

218
00:10:09,062 --> 00:10:11,062
But the question is can I
真正的问题在于没了 NSObject 之后

219
00:10:11,063 --> 00:10:13,063
create an Array where there are random Objects in there?
我能不能创建一个包含任意对象的数组呢

220
00:10:13,065 --> 00:10:15,932
And we're gonna talk about that later.
我们下面会讲这个东西

221
00:10:15,934 --> 00:10:18,468
Another class, NSDate, exactly what is sounds like,
另一个类， NSDate，顾名思义

222
00:10:18,470 --> 00:10:21,270
stores a date, let's you get the current date and time too.
可以存储日期，也可以让你获取当前日期和时间

223
00:10:22,306 --> 00:10:24,139
Pretty self-explanatory has lots and
显然，NSDate 有非常非常多的方法

224
00:10:24,141 --> 00:10:25,874
lots of methods in it.
会涉及到这些东西

225
00:10:25,876 --> 00:10:28,143
And it has even more and more methods because there's those
它还因为下面即将提到的另外三个类

226
00:10:28,145 --> 00:10:29,577
three other classes mentioned here,
还会有更多相关的方法

227
00:10:29,579 --> 00:10:32,480
Calendar, DateFormatter, and DateComponents.
Calendar, DateFormatter, 和 DateComponents.

228
00:10:32,482 --> 00:10:34,281
And if you're ever doing a date where you're gonna
如果你正要做日期相关的事情

229
00:10:34,283 --> 00:10:37,784
put a date on screen as part of your application,
在你的应用的某个地方放置一个日期

230
00:10:37,786 --> 00:10:39,753
you really wanna look at all these classes and
你就需要查看所有

231
00:10:39,755 --> 00:10:41,954
read the documentation that talks about dates.
提到日期的类和文档

232
00:10:41,956 --> 00:10:43,422
Because, dates are displayed very
因为全世界的日期

233
00:10:43,424 --> 00:10:45,224
differently around the world.
显示方式各不相同

234
00:10:45,226 --> 00:10:48,160
Different calendars different you know even
不同的日历，就我们所熟知的差异

235
00:10:48,162 --> 00:10:50,895
different languages, the order of the month, day, year even
在语言方面，年月日的顺序方面都不同

236
00:10:50,897 --> 00:10:53,031
if you're using the Gregirian calendar is different.
甚至你正在用的 Gregirian 类型的标准日历也有不同的地方

237
00:10:53,033 --> 00:10:56,600
So, you really, really dates are tricky to get right if
所以如果你要做在全世界都能正确显示的日历

238
00:10:56,602 --> 00:10:59,136
you wanna build an app that can work around the world.
是需要一些技巧的

239
00:10:59,138 --> 00:11:00,871
Okay, so I'm just kind of warning you if
所以我只是提醒你

240
00:11:00,873 --> 00:11:03,506
you're gonna build an app like that some day you wonna really
如果你要做一个应用需要用到日期时间

241
00:11:03,508 --> 00:11:06,542
understand date and all it's friends here.
你需要理解和 NSDate 相关的东西

242
00:11:06,544 --> 00:11:07,977
There's NSData,
还有 NSData

243
00:11:07,979 --> 00:11:11,280
super easy class it's just a bag of bits, okay?
非常简单的类，它就是一个比特包

244
00:11:11,282 --> 00:11:13,849
Could be gigantic bag of bits, small bag of bits, whatever.
可以是巨大的比特包，也可以是一个小小的比特包

245
00:11:13,851 --> 00:11:18,586
But it's just untyped data that's just in there it's just
不管怎样，它里面只是无类型的数据

246
00:11:18,588 --> 00:11:21,055
you can think of it almost like a pointer to memory and
你可以把它看成是一个指向内存的指针

247
00:11:21,057 --> 00:11:22,256
you just don't know what's in there.
并且你不知道它那里有什么东西

248
00:11:23,292 --> 00:11:26,693
This is how iOS will pass around untyped data, raw data.
这就是 iOS 可以四处传递无类型数据、原始数据的原因

249
00:11:26,695 --> 00:11:31,263
It passes around using this class.
它就是通过这个类来传递的

250
00:11:31,265 --> 00:11:33,632
It will be obvious when we start using this what it's for.
所以我们用这个类的目的是显而易见的

251
00:11:33,634 --> 00:11:36,134
You're not gonna be using NSData much in this class,
你不会用太多 NSData 的东西

252
00:11:36,136 --> 00:11:38,970
cuz we're not dealing with raw data that much,okay.
因为我们不会去处理那么多原始数据

253
00:11:38,972 --> 00:11:41,439
All right, so, let,
好的，其实

254
00:11:41,441 --> 00:11:43,974
I just wanted to mention some of those classes just so,
我只是想稍微提一下这其中的一些类

255
00:11:43,976 --> 00:11:47,144
you know, they exist you can check out the documentation
它们都在文档中，你可以通过文档

256
00:11:47,146 --> 00:11:48,945
on all of them to find out more about it and
找到它们并查看更详细的内容

257
00:11:48,947 --> 00:11:50,914
I'm gonna revisit a few of them like Array and
下面我会再稍微提到其中的一些类，比如 Array

258
00:11:50,916 --> 00:11:54,283
Dictionary and String because they, they're so important I'm
Dictionary 还有 String，因为它们实在太重要了

259
00:11:54,285 --> 00:11:56,552
actually gonna talk about some of their methods.
所以我会着重介绍它们的一部分方法

260
00:11:56,554 --> 00:11:58,554
But, I wanna talk a little bit about data structures in
通常，我会先谈谈 Swift 中的一些数据结构

261
00:11:58,556 --> 00:12:00,589
Swift in general, okay?
没问题吧

262
00:12:01,491 --> 00:12:03,124
There's really three fundamental building
在这些数据结构中

263
00:12:03,126 --> 00:12:04,692
blocks for your data structure that you
有三个基础块

264
00:12:04,694 --> 00:12:06,927
might build and you've seen them
而且你之前已经见过了

265
00:12:06,929 --> 00:12:08,795
two of the three of them in detail, but
其中的两个的具体内容

266
00:12:08,797 --> 00:12:10,597
they are class, struct, and
它们就是类、结构体

267
00:12:10,599 --> 00:12:13,333
enum, okay they're the three basic building blocks.
和枚举，它们就是那三个基础的块

268
00:12:14,469 --> 00:12:17,936
And they look very similar their declaration syntax looks
它们在声明的语法上看起来很像

269
00:12:17,938 --> 00:12:19,137
very, very similar, right?
非常非常像，对吧

270
00:12:19,139 --> 00:12:21,106
Just, the only difference is whether it's class,
唯一的差别就在声明的关键字是 class

271
00:12:21,108 --> 00:12:23,341
struct, or enum, but otherwise looks the same.
struct 还是 enum，除此之外看起来就是一模一样

272
00:12:23,343 --> 00:12:25,009
They're also very similar in that they can all
它们还有个非常相像的地方，它们都能拥有

273
00:12:25,011 --> 00:12:27,878
have properties and functions, okay, all three of them.
属性和方法

274
00:12:27,880 --> 00:12:31,448
Now enums they can't store any values
Enum 本身是不能存储任何值

275
00:12:31,450 --> 00:12:34,050
you store the values of your enum in that associated
你可以将值存储在枚举的关联信息中

276
00:12:34,052 --> 00:12:38,454
information but they can have computed properties, okay?
枚举是可以有计算型属性

277
00:12:38,456 --> 00:12:42,458
And all three of them can have functions, all right? okay?
这三种数据结构都可以有函数，明白吗

278
00:12:42,460 --> 00:12:44,292
So, that's very important to understand so,
理解这点非常的重要

279
00:12:44,294 --> 00:12:45,927
they are very, very similar in that way.
它们在那方面看起来非常的相似

280
00:12:47,197 --> 00:12:49,397
They're also similar at least structs, and
结构体和类更甚

281
00:12:49,399 --> 00:12:51,098
classes in that they can have intializers.
它们甚至都可以有初始化的构造器

282
00:12:51,100 --> 00:12:53,800
And we're gonna talk about initializers in detail in
我们后面的幻灯片中会详细地

283
00:12:53,802 --> 00:12:55,468
a few slides, okay?
谈到这个构造器

284
00:12:55,470 --> 00:12:56,703
So, they're similar in a lot of ways but
它们在许多方面都非常相似

285
00:12:56,705 --> 00:12:58,938
there's a couple ways in which they're very different,
但仍然有几个不同的地方

286
00:12:58,940 --> 00:13:00,039
all right?

287
00:13:00,040 --> 00:13:01,139
Classes are the only ones where you
类是三者中唯一拥有

288
00:13:01,142 --> 00:13:04,009
have inheritance, okay?
继承的性质

289
00:13:04,011 --> 00:13:05,243
And it's pretty obvious,
显而易见

290
00:13:05,245 --> 00:13:07,478
that's kind of the main definer of what a class is,
这是一种确定类是什么东西的主要定义

291
00:13:07,480 --> 00:13:08,045
it has inheritance.
就是它有继承性质

292
00:13:09,715 --> 00:13:12,082
And then, introspection and
我也会讲

293
00:13:12,084 --> 00:13:13,750
casting, which I'm also gonna talk about a little
内省和转型

294
00:13:13,752 --> 00:13:16,652
later those are only for classes, so none of this
都是属于类的性质

295
00:13:16,654 --> 00:13:19,555
casting thing I'm gonna talk about can you do for structs.
所以我所说所有关于转换的内容，你不能应用到结构体上

296
00:13:21,158 --> 00:13:23,224
And the most important difference to understand, and
而我们要明白的三种结构最重要的区别

297
00:13:23,226 --> 00:13:24,625
we really went over this in the demo,
在我们接下来的 demo 中会遇见的

298
00:13:24,627 --> 00:13:27,561
is this value type versus reference type.
就是 value type （值类型）与 reference type （引用类型）

299
00:13:27,563 --> 00:13:29,663
Structs and enums are passed around and
结构体和枚举的传递和

300
00:13:29,665 --> 00:13:32,499
stored in variables copied, okay?
存储是通过拷贝过的变量

301
00:13:32,501 --> 00:13:34,117
Right?
对吗？

302
00:13:34,118 --> 00:13:35,734
And referenced and classes are reference types.
类属于引用类型

303
00:13:35,737 --> 00:13:37,637
In other words, we pass round pointers to them,
换句话说，我们传递的是这些对象的指针，

304
00:13:37,639 --> 00:13:39,171
they live in the heap.
而这些对象本身存储在堆内存中

305
00:13:39,173 --> 00:13:41,407
And remember that class is their memory and
需要记住的是，堆内存中的对象

306
00:13:41,409 --> 00:13:43,809
the heap is managed for us.
系统会自动为我们管理（ARC）

307
00:13:43,811 --> 00:13:45,444
Okay, so there's nothing,
这样一来，

308
00:13:45,445 --> 00:13:47,078
we don't have to do anything alloc and free them.
我们就没有必要去开辟和释放内存了

309
00:13:47,080 --> 00:13:48,212
We create them when we want, and
我们创建想要的对象后，

310
00:13:48,214 --> 00:13:49,714
when nobody else, no one's using it,
一旦没有任何指针指向这些对象，

311
00:13:49,716 --> 00:13:52,316
it gets cleaned up and it's not garbage collection, okay?
这些对象就会被马上清理掉，注意，这不是垃圾回收机制，明白吗？

312
00:13:52,318 --> 00:13:53,850
Reference counting, automatic reference counting.
这是引用计数，自动引用计数 （ARC）

313
00:13:53,852 --> 00:13:56,252
But, I wanna just have a slide on this
我还想多讲一下

314
00:13:56,254 --> 00:13:58,221
value type versus reference type again, because it's
值类型和引用类型的区别，因为分清它们

315
00:13:58,223 --> 00:13:59,789
a really important thing to understand it.
真的很重要

316
00:13:59,791 --> 00:14:01,890
Cuz people get confused writing the code and
因为人们在写代码的时候并不是很清楚

317
00:14:01,892 --> 00:14:04,726
they don't understand what's going on,
他们背后的区别和原理，

318
00:14:04,728 --> 00:14:08,329
but a value type struct means, you know, it's
对于值类型，比如结构体，它表示

319
00:14:08,331 --> 00:14:11,599
mean that it's copied when you pass it into a function.
当你将它传递给方法的时候，方法使用的是它的拷贝

320
00:14:11,601 --> 00:14:14,235
It's copied when you assign it to a different variable,
当你将它赋值给另外一个变量的时候也是如此，

321
00:14:14,237 --> 00:14:15,436
this one especially gets people.
理解这个是很重要的

322
00:14:15,438 --> 00:14:16,636
I don't understand as I have,
比如，

323
00:14:16,638 --> 00:14:20,540
you know let x equals Array, and I say let y equal x.
let x = Array<>，然后 let y = x

324
00:14:20,542 --> 00:14:22,508
That makes, essentially a copy of x,
这实际上是将 x 的值拷贝一份给了 y ，

325
00:14:22,510 --> 00:14:25,611
now that copy might be lazy behind the scenes, but
或许这背后是以惰性的方式拷贝的，总之

326
00:14:25,613 --> 00:14:28,279
as far as you're concerned it's a copy, okay?
你只需要知道这是一份拷贝，明白吗？

327
00:14:29,449 --> 00:14:31,015
And if you wanna to be mutable,
如果你希望赋值后可以修改它，

328
00:14:31,017 --> 00:14:33,183
you could copy it into a VAR instead of a LET,
你只需要将这个常量赋值给一个变量（var y = x），

329
00:14:33,185 --> 00:14:34,718
and now you could mutate it.
之后，你就可以修改它了

330
00:14:34,720 --> 00:14:36,486
And if you mutate it you get,
当你修改你得到的值的时候，

331
00:14:36,488 --> 00:14:38,988
you're mutating your own copy, you're not mutating.
你修改的是你拷贝来的值，而不是修改

332
00:14:38,990 --> 00:14:42,491
What the other one pointed to, okay?
之前被拷贝的那个值（修改 y 不会影响 x ），明白吗？

333
00:14:42,493 --> 00:14:47,729
you, because of this, when you make a struct or an enum,
因为上述原理，当你定义一个 struct 或者一个 enum，

334
00:14:47,731 --> 00:14:51,866
and you add a function to it that modifies it,
并且为它添加方法来修改它的状态时，

335
00:14:51,868 --> 00:14:56,236
you have to mark it with this keyword mutating.
你必须在方法前面加上 mutating 关键字。

336
00:14:56,238 --> 00:14:59,306
And that's so that Swift knows when someone else.
这样当其他人

337
00:14:59,308 --> 00:15:02,042
Gets you know, tries to use your enum or struct, if
需要使用你的 enum 或 struct 的时候，

338
00:15:02,044 --> 00:15:05,178
they use one of these mutating functions it obviously has to
他们就必须在一个变量上来调用这些 mutating 函数，

339
00:15:05,180 --> 00:15:07,613
be in a var but not in a let type variable.
而不是在一个常量上

340
00:15:07,615 --> 00:15:13,552
[NOISE] Okay so reference stored in the heap, reference
引用类型存储在堆中，

341
00:15:13,554 --> 00:15:19,524
counted even if you have a constant pointer to a class.
即使是一个常量指针，也会导致引用计数增加

342
00:15:19,526 --> 00:15:21,525
Let something equals the class.
对于指向一个对象的常量指针，

343
00:15:21,527 --> 00:15:24,261
You can still send messages to that thing that can mutate it,
你同样可以向这个常量指针发送消息，来修改所指对象里面的属性，

344
00:15:24,263 --> 00:15:26,196
because it didn't the heap.
因为这个对象存储在堆里面，

345
00:15:26,197 --> 00:15:28,130
All right, so it being, you have a pointer to it.
而你可以用一个指针来引用它

346
00:15:28,133 --> 00:15:29,933
So, and when you pass it to a function,
当你把这个这个对象传递个一个方法的时候，

347
00:15:29,935 --> 00:15:31,267
you're passing a pointer to that thing, so
你传递的是指向这个对象的指针，所以

348
00:15:31,269 --> 00:15:32,968
if the function modifies it,
如果这个方法修改了这个对象，

349
00:15:32,970 --> 00:15:35,571
it's modifying the thing back where it was called.
那它修改的就是存储在堆内存中的那个对象了

350
00:15:35,573 --> 00:15:37,406
Okay?
明白吗？

351
00:15:37,408 --> 00:15:41,809
So which do you use between these two?
那么如何正确选择这两种数据类型呢？

352
00:15:41,811 --> 00:15:42,894
Well you know,
事实上，

353
00:15:42,895 --> 00:15:43,978
90% of the time, you're gonna use a class.
百分之九十的情况下我们都会使用类

354
00:15:43,980 --> 00:15:45,746
This is object-oriented programming language.
因为这是面向对象的编程语言

355
00:15:45,748 --> 00:15:48,348
You're gonna wanna have the ability to do inheritance, and
当你使用类时，你就可以使用诸如继承，

356
00:15:48,350 --> 00:15:49,916
overriding, and things like that.
重写之类的特性了

357
00:15:49,918 --> 00:15:53,786
Structs are really more for the basic fundamental types,
而结构体更适合基础数据类型，

358
00:15:53,788 --> 00:15:57,456
like Double, Int, Array, Dictionaries, String.
比如 Double, Int, Array, Dictionaries, String。

359
00:15:57,458 --> 00:16:00,826
These are all you know, really fundamental things and
你知道，这些东西都非常基础，而且

360
00:16:00,828 --> 00:16:03,128
when we get into the graphics, you're gonna see the points,
当我们涉及到绘图的时候，我们会更多地使用 points ，

361
00:16:03,130 --> 00:16:07,131
sizes, rectangles, those are structs, okay?
sizes，rectangles，它们都是都是结构体

362
00:16:07,133 --> 00:16:09,166
But, most of everything else we build,
但是，我们的大多数操作都是

363
00:16:09,168 --> 00:16:12,036
we build the classes, okay.
与类打交道

364
00:16:12,038 --> 00:16:13,804
And since it manages all the memory for you and
而且系统会为你管理内存，

365
00:16:13,806 --> 00:16:18,775
all that, it's really no big pain to do, to use classes.
所以现在使用类是一件非常轻松的事情了

366
00:16:19,944 --> 00:16:22,228
All right, so methods.
好的，接下来，

367
00:16:22,229 --> 00:16:24,513
So, I wanna talk a little bit about methods, all right.
我想讨论一下方法

368
00:16:24,515 --> 00:16:26,181
You obviously-
很明显，

369
00:16:26,183 --> 00:16:27,449
>> [COUGH]

370
00:16:27,451 --> 00:16:29,417
>> If you override a method in a class,
当你重写父类的方法的时候，

371
00:16:29,419 --> 00:16:33,287
you have to put the keyword, override in front of it, 'kay?
你必须在该方法前面加上 override 关键字，记住了吗？

372
00:16:34,490 --> 00:16:37,057
You can also mark a method final,
你也可以把一个方法标记为 final ，

373
00:16:37,059 --> 00:16:39,559
that means no one can override it.
final 表示这个方法不能被重写

374
00:16:39,561 --> 00:16:41,694
So, if someone subclasses a class you wrote,
如果有人继承了你的类，

375
00:16:41,696 --> 00:16:43,328
they can't override you if you marked it final.
他们不能重写那些被标记为 final 的方法

376
00:16:43,330 --> 00:16:46,131
You can also mark an entire class final, which means hm,
你还可以把整个类都标记为 final ，这表示，

377
00:16:46,133 --> 00:16:47,565
it's a, you know, this is the end of the line.
谁都不能更改这个类，

378
00:16:47,567 --> 00:16:49,634
You can't do any subclasses of it basically.
甚至不能继承这个类。

379
00:16:49,636 --> 00:16:51,402
Okay?
明白了吗？


380
00:16:51,404 --> 00:16:58,508
Both types and instances have methods and properties.
类和实例都有自己的方法和属性

381
00:16:58,510 --> 00:17:00,577
So, types, a type is like Array,
比如， Array 就是一个类，

382
00:17:00,579 --> 00:17:04,047
that's the type and instance of an Array is an actual Array
而具体的一个 Array 就是一个实例，

383
00:17:04,049 --> 00:17:04,947
with things in it.
实例封装有自己数据

384
00:17:04,949 --> 00:17:07,249
Okay?
明白吗？

385
00:17:07,250 --> 00:17:09,550
So let's look at this pili, piece of code, right here.
我们来看看下面这段代码

386
00:17:09,553 --> 00:17:11,620
I've defined a Double, 'kay?
我定义里一个 Double 类型的变量 d ，

387
00:17:11,622 --> 00:17:13,922
This var which is a Double, and I say,
这个是一个 Double 变量，

388
00:17:13,924 --> 00:17:17,625
if the Double isSignMinus, that means if it's minus sign,
然后向 d 发送 isSignMinus 消息，来判断它

389
00:17:17,627 --> 00:17:19,727
has, it's negative.
是否是负数，

390
00:17:19,729 --> 00:17:21,962
Then I'm going to set the Double to be it,
然后我把 d 设置为，

391
00:17:21,964 --> 00:17:23,863
the absolute value of the Double.
它自己的绝对值

392
00:17:23,865 --> 00:17:28,501
So, isSignMinus is an instance variable,
所以， isSignMius 是实例 d 的变量，

393
00:17:28,503 --> 00:17:30,035
an instance property.
或者说是实例 d 的一个属性

394
00:17:30,037 --> 00:17:32,804
You send it to a particular Double to ask it,
你通过对一个具体的 Double 类型的实例 d 发送 isSignMius 消息，

395
00:17:32,806 --> 00:17:34,673
is your SignMinus?
来判实例 d 是否是负数

396
00:17:34,675 --> 00:17:39,210
Whereas Double.abs is a type function on Double.
然而， abs 是 Double 这个类型的方法（不依赖类型的实例）

397
00:17:39,212 --> 00:17:42,379
You pass the Double you wanna operate on to it, and
你向这个方法中传入你需要操作的 Double 类型的实例，

398
00:17:42,381 --> 00:17:44,381
it works on it.
它返回你想要的结果

399
00:17:44,382 --> 00:17:46,382
But your, and you're not sending abs to a particular
这里，你并没有向一个特定的 Double 实例发送消息，

400
00:17:46,385 --> 00:17:48,385
Double, you're sending it to the class, or
而是向 Double 的类型在发送消息，

401
00:17:48,387 --> 00:17:49,952
the struct in this case, the type.
在这个例子中是向着 struct 类型（Double 是 struct）

402
00:17:49,954 --> 00:17:51,721
You see what I mean?
明白我的意思吗？

403
00:17:51,723 --> 00:17:54,723
So, some method you send to instances, particular
你把一些方法发送给实例

404
00:17:54,725 --> 00:17:57,592
instances of some things, something you can send to the type.
一些特殊的方法，你可以发送给类型

405
00:17:57,594 --> 00:18:00,628
All right, so two different kinds of, of method but
所以是两种不一样的方法

406
00:18:00,630 --> 00:18:02,597
otherwise, the rules for them are about the same.
但他们的规则是一样的

407
00:18:02,599 --> 00:18:04,732
It's just that, who you asked to do the work.
区别就是你叫谁去完成任务

408
00:18:05,668 --> 00:18:08,101
You declare a type method or
你声明一个类方法或者

409
00:18:08,103 --> 00:18:11,037
a property by using static in front of it.
前面使用关键字 static 修饰的一个 property

410
00:18:11,039 --> 00:18:14,474
So, like abs, there would static func abs,
就像 abs 方法，原型是

411
00:18:14,476 --> 00:18:16,842
takes a Double returns a Double.
static func abs(d: Double) -> Double

412
00:18:16,844 --> 00:18:19,345
And that makes it so you send it that to, the Double type
这就规定了你要向 Double 类型发消息

413
00:18:19,347 --> 00:18:21,880
instead of sending it to a particular Double.
而不是某个特定的 Double 实例

414
00:18:21,882 --> 00:18:24,749
In a class you use the word class not static.
在一个 class 中你使用关键字 class 而不是 static（static 用于 struct 和 enum）

415
00:18:24,751 --> 00:18:26,617
Okay, cuz it's called a class function.
因为它被称为类方法

416
00:18:27,787 --> 00:18:28,819
Okay?
明白吗？

417
00:18:28,821 --> 00:18:31,055
So, I just don't want you to be confused,
我不想让你们感到困惑

418
00:18:31,056 --> 00:18:33,290
when you start seeing methods like abs that are sent to
当你看见一个类似于 abs 的方法

419
00:18:33,292 --> 00:18:35,108
the Double type.
被发送给 Double 类型时

420
00:18:35,109 --> 00:18:36,925
That looks kinda weird but it's perfectly normal.
那看起来有一点奇怪，但是很正常

421
00:18:36,928 --> 00:18:38,228
Okay?
明白吗？

422
00:18:38,229 --> 00:18:39,529
And what would you do with a ty, wh, when do
那么……

423
00:18:39,531 --> 00:18:42,231
you have a type function versus an instant function?
类方法和实例方法该如何选择呢？

424
00:18:42,233 --> 00:18:44,800
Well, if you're doing any kind of utility work, right?
如果你正在进行通用性工作

425
00:18:44,802 --> 00:18:46,218
You're not doing anything in
你不需要针对

426
00:18:46,219 --> 00:18:47,635
particular to a certain kind of Double, but
特定的 Double 实例做修改，

427
00:18:47,638 --> 00:18:50,705
just in utilities, you would have those in there.
只是通用的一些步骤，那么你可以使用两种方式

428
00:18:50,707 --> 00:18:53,908
Sometimes you would have type methods that create objects of
有时候你会用类方法

429
00:18:53,910 --> 00:18:56,310
certain kinds and hand them out.
来创建对象并供外部使用

430
00:18:56,312 --> 00:18:59,013
Maybe a shared object like if you had one,
比如共享对象，如果你有一个

431
00:18:59,015 --> 00:19:00,547
only one instance of an object for
只有一个实例的对象

432
00:19:00,549 --> 00:19:03,383
your entire app of a certain type, maybe you would ask that
也许你会要求那个类型

433
00:19:03,385 --> 00:19:07,120
type, give me that shared instance, okay?
给我那个共享的实例，明白了吗？

434
00:19:07,122 --> 00:19:08,587
So it's kinda before utilities and
这是通用步骤和

435
00:19:08,589 --> 00:19:10,889
creation, that kinda thing.
创建对象之前的东西

436
00:19:10,891 --> 00:19:12,991
And they're, now I wouldn't, I don't wanna say, they're rare,
我不想说类方法很少见

437
00:19:12,993 --> 00:19:15,960
they're not super common, you'll see them in, in iOS and
说类方法不是非常常见，你们在 iOS 里面会看到

438
00:19:15,962 --> 00:19:18,496
you'll probably use them occasionally.
偶尔还会使用

439
00:19:18,498 --> 00:19:21,565
you, you would use them really instead of global functions.
你可能会使用类方法而非全局函数

440
00:19:21,567 --> 00:19:23,801
You can't have global functions.
你不允许使用全局函数

441
00:19:23,803 --> 00:19:25,936
In Swift, of course.
当然是在 Swift 中

442
00:19:25,938 --> 00:19:28,271
But you'd really probably prefer to make it a type
但是你可能真的喜欢创建类方法

443
00:19:28,273 --> 00:19:31,674
method so that function is associated with you know,
以便那个方法关联到

444
00:19:31,676 --> 00:19:33,542
the type and kind of, unless it's
类型和其他东西，除非它真的是

445
00:19:33,544 --> 00:19:35,844
truly a global function that applies to the world.
一个世界通用的全局函数

446
00:19:35,846 --> 00:19:39,348
It doesn't, it's not about a particular class,
它跟一个特殊的类无关

447
00:19:39,350 --> 00:19:41,716
usually you would make them be a type,
通常情况下你将会把它们当做一个类使用

448
00:19:41,718 --> 00:19:44,485
a type function [SOUND] very well [SOUND].
一个类方法

449
00:19:44,487 --> 00:19:46,454
All right?
对吧？

450
00:19:46,456 --> 00:19:49,390
So method, now lets talk about the parameter names
现在让我们来谈谈

451
00:19:49,392 --> 00:19:50,908
of methods.
方法的参数名

452
00:19:50,909 --> 00:19:52,425
This is, this is a, this is gonna be the crash course,
这会是速成课，

453
00:19:52,428 --> 00:19:54,361
you read all about this I hope in the documentation.
你们已经阅读了我希望你们知道的，在文档中所有的相关内容

454
00:19:54,363 --> 00:19:57,697
But, all parameters to functions have an internal
但是，方法中的所有参数都有

455
00:19:57,699 --> 00:19:58,731
name and an external name.
一个内部的名字和一个外部的名字

456
00:19:58,733 --> 00:20:00,432
So, we're talking about the parameters.
所以，让我们来讨论一下这些参数

457
00:20:00,434 --> 00:20:00,999
Okay?
明白了么？

458
00:20:01,001 --> 00:20:03,068
So, down there,
所以，在下面

459
00:20:03,069 --> 00:20:05,136
foo, the parameters the parameter to foo there.
foo , 参数 foo 在这里

460
00:20:05,138 --> 00:20:07,071
'Kay, it has internal name and external name.
明白了么，它有一个内部命名和一个外部命名

461
00:20:07,073 --> 00:20:09,874
So, the internal name, which goes kinda near
所以，内部的名字，和冒号有一点接近

462
00:20:09,876 --> 00:20:12,643
the colon, is the name that that thing is gonna have as
是在方法中拥有一个本地变量的名字

463
00:20:12,645 --> 00:20:15,479
a local variable inside the method, at this internal name.
在这个内部名称中

464
00:20:15,481 --> 00:20:18,615
And then the external name is the name that
外部命名是一个名字

465
00:20:18,617 --> 00:20:22,251
callers are going to use when the, to put before the colon.
调用者准备使用的，放在冒号之前

466
00:20:22,253 --> 00:20:23,285
'Kay?
明白了么？

467
00:20:23,286 --> 00:20:24,318
When they call the thing.
当他们调用东西的时候

468
00:20:24,321 --> 00:20:26,822
So in bar there, I'm calling things, and
所以在这里，我要调用一个东西

469
00:20:26,824 --> 00:20:30,008
in foo I'm defining them.
在 foo 方法中我定义了他们

470
00:20:30,009 --> 00:20:33,193
So, you see that here, I call foo with external colon 123.
所以，在这里你可以看到，我通过 foo(external:123) 来调用 foo

471
00:20:33,196 --> 00:20:37,598
Even though, internal to foo, that thing is called internal.
尽管，foo 的内部，那东西叫做 internal

472
00:20:38,801 --> 00:20:39,933
'Kay?
明白了吗？

473
00:20:39,935 --> 00:20:41,401
So, you can have both external,
所以，你可以同时拥有外部的

474
00:20:41,403 --> 00:20:42,368
internal names, they can be different.
以及内部的名字，他们可以不一样

475
00:20:43,604 --> 00:20:45,037
You can put an under bar,
你可以添加一个下划线

476
00:20:45,039 --> 00:20:48,473
remember under bar is kinda the don't care thing in Swift.
记住，在 Swift 中下划线是会被忽略的

477
00:20:48,475 --> 00:20:50,808
Even under bar if you don't want callers to
如果你不想有调用者

478
00:20:50,810 --> 00:20:52,009
use an external name.
使用一个外部命名

479
00:20:52,011 --> 00:20:53,410
So now look at bar.
现在来看 bar 方法

480
00:20:53,412 --> 00:20:55,345
It calls foo,
它调用了 foo 方法

481
00:20:55,346 --> 00:20:57,279
it doesn't even put internal colon or external colo, colon.
可是却没有写 internal: 或者 external:

482
00:20:57,282 --> 00:20:59,282
It just puts the argument there.
它只是把参数留在了那儿

483
00:20:59,284 --> 00:21:00,550
'Kay? So, the under bar says,
所以，下划线说：

484
00:21:00,552 --> 00:21:03,285
I don't wanna have an external name for this.
“我不想拥有一个外部命名”

485
00:21:03,287 --> 00:21:07,422
'Kay, now that is the default for
其实，函数的第一个参数的

486
00:21:07,424 --> 00:21:09,958
the first argument to a function.
默认外部命名就是下划线

487
00:21:10,994 --> 00:21:12,393
So, foo only has one argument, so
所以，foo 方法只有一个参数

488
00:21:12,395 --> 00:21:14,695
it's first argument, it's only argument.
所以，它是第一个参数也是唯一的一个参数

489
00:21:14,697 --> 00:21:17,731
You can see that when you call it from bar,
你可以看到它当你从 bar 处调用它

490
00:21:17,733 --> 00:21:19,332
you don't say internal colon,
你不会写 “internal:”

491
00:21:19,334 --> 00:21:22,435
as because that under bar thing is the default.
因为下划线是默认的

492
00:21:23,371 --> 00:21:25,337
Now, if you don't want that to be the default,
现在，如果你不想让它作为默认的值

493
00:21:25,339 --> 00:21:28,506
you can force the first one to be required by
你可以强制第一个参数是必要的

494
00:21:28,508 --> 00:21:31,609
putting a pound sign there, a little hashtag, okay?
通过添加一个 “#” 井号标志，一个小标签，明白？

495
00:21:31,611 --> 00:21:34,345
And that makes it so you have to say internal colon-
这使得你不得不通过 internal: 来调用函数

496
00:21:34,347 --> 00:21:36,814
>> [COUGH] >> 'Kay?
明白吗？

497
00:21:37,950 --> 00:21:42,318
For other parameters, not the first parameter but
对于另外的参数，不是第一个参数

498
00:21:42,320 --> 00:21:43,886
other parameters.
是其他的参数

499
00:21:43,888 --> 00:21:46,555
The name, the internal or external name,
他们的名称，内部命名或外部命名

500
00:21:46,557 --> 00:21:49,391
is mandatory, 'kay?
是必须要写的，明白？

501
00:21:49,393 --> 00:21:52,460
Unless, you put the and you can change the name,
除非，你设置或者改变了它的名称

502
00:21:52,462 --> 00:21:55,430
you can be you can, you can have the external name be
这个因人而异，你可以将外部命名区别于其他的参数

503
00:21:55,432 --> 00:21:58,165
different for any parameter not just the first one.
这个不仅限于第一个参数

504
00:21:58,167 --> 00:22:01,001
And you can put the under bar in there and make it so
还有，你可以在这里添加一个下划线

505
00:22:01,003 --> 00:22:03,070
even the second one has no parameter name.
来让第二个变量没有参数名

506
00:22:03,072 --> 00:22:06,940
This would be incredibly un-Swift like to do this.
我不建议这样做，因为这不是标准的做法

507
00:22:06,942 --> 00:22:10,610
To have a function like this that takes two arguments, and
要想让这样一个接受两个参数的方法的第二个参数

508
00:22:10,612 --> 00:22:13,946
the second one doesn't really have, a name.
不需要名称

509
00:22:13,948 --> 00:22:16,382
Because in Swift you can kind of think of the name of
因为在 Swift 中，你一般会认为方法的名字

510
00:22:16,384 --> 00:22:20,018
the method, as describing what the first argument is.
即描述了它的第一个参数是什么

511
00:22:20,020 --> 00:22:22,487
The first argument's your method, it should always be,
你的方法的第一个参数，始终需要

512
00:22:22,489 --> 00:22:24,422
kind of obvious based on the name of the method.
基于此方法的名字

513
00:22:24,424 --> 00:22:25,623
Because the method does something,
因为方法完成了某些功能

514
00:22:25,625 --> 00:22:27,424
it operates on something or whatever.
它在某个事物之上进行操作

515
00:22:27,426 --> 00:22:29,309
That should be the first argument.
那个事物就应该是第一个参数

516
00:22:29,310 --> 00:22:31,193
That's why it usually doesn't need a first parameter name.
这就是我们不需要第一个参数名的原因

517
00:22:31,196 --> 00:22:32,462
And then all the other arguments,
至于其余的参数

518
00:22:32,464 --> 00:22:33,663
you wanna give them names, so
如果你理解了它们在干什么之后

519
00:22:33,665 --> 00:22:35,398
if you understand what they are, 'kay?
你想要给它们命名

520
00:22:35,400 --> 00:22:37,132
What they're about?
说明这个参数是用来干什么的

521
00:22:37,134 --> 00:22:40,035
And in other languages a lot of times you'll have a real,
在其他的语言中，你经常会遇到

522
00:22:40,037 --> 00:22:42,937
really long method that says you know, do this, and
非常非常长的方法命名告诉你某个方法

523
00:22:42,939 --> 00:22:44,405
that, with this other thing, and
做了 A 和 B ，使用了 C 跟 D

524
00:22:44,407 --> 00:22:47,408
that, and then in parenthesis you have four arguments and
然后你需要在括号中将这四个参数

525
00:22:47,410 --> 00:22:49,810
people have to kinda match up what's what.
一一对应起来

526
00:22:49,812 --> 00:22:51,945
Here, the name of the method really is kind of
而在 Swift 中，方法名是根据

527
00:22:51,947 --> 00:22:53,580
distributed out amongst it's arguments.
它的参数来命名的

528
00:22:53,582 --> 00:22:55,014
So, it's really a lot easier to read and
比较方便去阅读

529
00:22:55,016 --> 00:22:57,516
a lot easier to understand, what the heck is going on?
也比较方便去理解，方法这里到底是在干什么？

530
00:22:57,518 --> 00:22:59,718
so, I don't recommend it,
显然，我并不推荐这么做

531
00:22:59,720 --> 00:23:03,655
I don't recommend putting the under bar in, in parameters.
我不推荐在参数之前加上下划线

532
00:23:03,657 --> 00:23:05,089
There, there are some exceptions, but
虽然有一些特例，但是

533
00:23:05,091 --> 00:23:08,692
I generally don't recommend that.
一般来说我不推荐这么做

534
00:23:08,694 --> 00:23:09,860
'Kay?
明白了吗？

535
00:23:09,862 --> 00:23:10,994
All right properties,
接来下是 properties

536
00:23:10,996 --> 00:23:13,062
let's talk a little bit about properties.
让我们一起来看看什么是 properties

537
00:23:13,064 --> 00:23:15,331
So, property observers are very important and
显然， property observers 是非常关键的

538
00:23:15,333 --> 00:23:17,333
we're gonna use them a lot.
而且我们会大量使用它

539
00:23:17,335 --> 00:23:19,452
They are very simple,
它们使用起来很简单

540
00:23:19,453 --> 00:23:21,570
you have a property like here I have some stored property.
在这里你有一个 someStoredProperty

541
00:23:21,572 --> 00:23:23,238
It's an Int equals 42, and
它是 Int 类型的，值为42

542
00:23:23,240 --> 00:23:26,941
yes I didn't need to type there, I'm just putting there.
其实我并不需要在这里写这些，我只是把它放在这里

543
00:23:26,943 --> 00:23:29,210
okay, and throughout my slides by the way.
这些一直贯穿在我的 Slides 中

544
00:23:29,212 --> 00:23:32,880
Green, I put things in green because I'm just trying to
绿色，我将这部分标注为绿色，因为

545
00:23:32,882 --> 00:23:35,782
make you draw attention to the fact that this is code.
我想让你们注意到的是，这部分是代码

546
00:23:35,784 --> 00:23:37,684
Okay? That's all green means, but
明白了吗？这是被标注为绿色的部分的意义

547
00:23:37,686 --> 00:23:40,353
yellow usually will mean this is
黄色部分通常表示

548
00:23:40,355 --> 00:23:42,221
the thing I'm talking about, right now.
这是我正在跟你们讲的东西

549
00:23:42,223 --> 00:23:43,422
This is the thing to pay attention to.
这是你们需要关心的部分

550
00:23:43,424 --> 00:23:44,590
So, you can al,
所以，你可以把黄色部分

551
00:23:44,591 --> 00:23:45,757
almost think of yellow, as like highlighted.
认为是一种高亮

552
00:23:45,759 --> 00:23:47,309
Okay?
明白了吗？

553
00:23:47,310 --> 00:23:48,860
So, here I have some stored property.
回到我们之前讲的，这里我拥有一个 someStoredProperty

554
00:23:48,862 --> 00:23:51,195
It stores in Int 42.
它存储了 Int 类型的42

555
00:23:51,197 --> 00:23:54,398
And notice though, even though it's a stores property,
需要注意的是，这是一个

556
00:23:54,400 --> 00:23:56,100
not computed, it's stored.
直接存储、不需要计算过程的 property

557
00:23:56,102 --> 00:23:58,435
I still put a curly brace after it.
我仍旧在它之后放置了一对花括号

558
00:23:58,437 --> 00:24:00,103
But in that curly brace instead of
花括号的意思并不是说，

559
00:24:00,105 --> 00:24:02,472
saying get instead like a computer property.
这个 property 是通过计算得到的

560
00:24:02,474 --> 00:24:05,675
I say, will set and did set, 'kay?
而是有 willSet 和 didSet，明白了吗？

561
00:24:05,677 --> 00:24:09,277
So these are little pieces of code inside the willSet and
所以在 willSet 和 didSet 之后的

562
00:24:09,279 --> 00:24:11,396
dill, didSet.
小段的代码

563
00:24:11,397 --> 00:24:13,514
They get called when that property gets set by anybody,
会在设置 property 的值的过程中被调用

564
00:24:13,517 --> 00:24:16,884
so it's called an a property observer cause I'm observing
这就是它为什么叫 property observer 的原因

565
00:24:16,886 --> 00:24:20,021
with this code I'm observing this thing is being set.
因为这段代码 observe 这个 property 的设置方法

566
00:24:20,023 --> 00:24:21,989
And the willSet is called right before
willSet 这个方法会在设置 property 值之前被调用

567
00:24:21,991 --> 00:24:25,592
the properties value gets set, and the didSet, right after.
同理，didSet 这个方法会在设置 property 值之后被调用

568
00:24:25,594 --> 00:24:27,244
And inside the willSet,
在 willSet 方法中

569
00:24:27,245 --> 00:24:28,895
you've got this special variable called new value,
你会有一个特殊的 newValue 变量

570
00:24:28,897 --> 00:24:31,230
which is gonna be the new value that's going to be set.
这是 property 将要被设置的新的值

571
00:24:31,232 --> 00:24:34,233
And then inside didSet, you've got this special thing
同样，在 didSet 方法中，你会有一个特殊的 oldValue 变量

572
00:24:34,235 --> 00:24:36,535
called old value, which is the old value.
这是 property 要被设置之前的值

573
00:24:36,537 --> 00:24:39,371
Okay?
明白了吗？

574
00:24:39,372 --> 00:24:42,206
Now, you use this in really kind of these two cases.
现在，你可以在这两种情况下使用它们

575
00:24:42,208 --> 00:24:44,608
One is you have the stored property in yourself,
一种情况是你在自己的类中拥有

576
00:24:44,610 --> 00:24:46,660
in your class.
stored property

577
00:24:46,661 --> 00:24:48,711
And whenever someone sets it, you want to kinda notice and
当其他方法的设置它的值时，你想要获得一个 notice

578
00:24:48,714 --> 00:24:50,013
do something, okay?
然后你可以根据这个 notice 做一些事情

579
00:24:50,015 --> 00:24:54,384
And the other one is you inherit some property, and you
另一种情况是你继承了某些类

580
00:24:54,386 --> 00:24:57,319
don't necessarily do anything with that property directly.
你并不需要对这些类中的 property 做什么修改

581
00:24:57,321 --> 00:24:59,722
But you wanna know, when that gets changed by anybody.
但它们被改变时你想知道

582
00:24:59,724 --> 00:25:00,756
'Kay?
明白了吗？

583
00:25:00,758 --> 00:25:01,956
So, you can even do willSet and
所以，你可以在某些

584
00:25:01,958 --> 00:25:04,726
didSet on properties you inherit from somebody,
继承的类之上

585
00:25:04,728 --> 00:25:05,526
from your super class.
重写继承自父类的 willSet 和 didSet

586
00:25:06,529 --> 00:25:07,861
Okay?
明白了吗？

587
00:25:07,863 --> 00:25:10,697
Now, what kinda things would we do in here?
在这里，我们能够做些什么？

588
00:25:10,699 --> 00:25:13,533
Well, one extremely common thing to do in iOS is to
在 iOS 开发中非常常见的做法是

589
00:25:13,636 --> 00:25:15,019
update the user-interface.
更新用户界面（UI）

590
00:25:16,020 --> 00:25:18,403
So, you have some view controller let's say, or
举例，你有一个 view controller

591
00:25:18,406 --> 00:25:21,440
you have a view, and you change some property in it and
或者你有一个 view ，你改变了其中的某些 property

592
00:25:21,442 --> 00:25:25,043
it, that changing that property means would change.
改变其中某些 property 意味着

593
00:25:25,045 --> 00:25:28,146
So, in the didSet, you'll go update the user-interface.
在 didSet 中，你将对用户界面进行更新

594
00:25:28,148 --> 00:25:30,281
That make sense?
这样说能理解一点了吗？

595
00:25:30,283 --> 00:25:32,083
'Kay.
好

596
00:25:32,084 --> 00:25:33,884
So, the observers are really cool, they're a really good
所以， property observers 是非常酷的

597
00:25:33,886 --> 00:25:35,852
way to kinda keep track of what's going on and
他们是跟踪发生了什么事情以及

598
00:25:35,854 --> 00:25:36,853
keep things in sync.
保持事务同步的一种好方法

599
00:25:38,323 --> 00:25:42,624
All right, lazy initialization so a lazy property,
接下来，我们谈谈惰性实例化

600
00:25:42,626 --> 00:25:45,494
if you put lazy in front of a property declaration, it means
如果你在 property 声明前加了 lazy ，这意味着

601
00:25:45,496 --> 00:25:49,230
it does not get initialized until someone accesses it.
它只会在被用到的时候才会初始化

602
00:25:50,333 --> 00:25:53,467
And that's true whether it's initialized with
比如它以被赋值的操作执行初始化

603
00:25:53,469 --> 00:25:55,769
equal something, so that equal something will not
那么这个赋值的动作会在这个 property 实际被用到的时候

604
00:25:55,771 --> 00:25:59,305
happen until someone actually accesses that property.
才会执行

605
00:25:59,307 --> 00:26:03,876
Or you can actually initialize it by putting a closure there,
你也可以在初始化的时候使用闭包

606
00:26:03,878 --> 00:26:06,712
put parenthesis after it, and we'll execute that closure.
后面放一对圆括号，也就是通过执行这个闭包

607
00:26:06,714 --> 00:26:10,048
And that will initialize the property.
来初始化这个属性

608
00:26:10,050 --> 00:26:15,186
But that closure won't get executed until someone tries to get it, 'kay?
但是这个闭包只有在 property 被用到的时候才会执行

610
00:26:15,188 --> 00:26:19,023
And then you can even in a lazy property, you could call
在 lazy property 中

611
00:26:19,025 --> 00:26:23,593
a method to, to initialize it because it, normally you
你甚至可以调用一个方法来初始化

612
00:26:23,595 --> 00:26:27,296
wouldn't be able to do this if you didn't say lazy.
如果你不把 property 标记为 lazy，这样做是不允许的

613
00:26:27,298 --> 00:26:29,415
Because you can't call any
因为在类初始化之前

614
00:26:29,416 --> 00:26:31,533
methods in your class until you're fully initialized, so
类里的方法都是不可以调用的

615
00:26:31,535 --> 00:26:33,535
there's kinda a catch 22 there.
有点像第22条军规

616
00:26:33,537 --> 00:26:34,736
But in this case since,
但是在这种情况

617
00:26:34,738 --> 00:26:37,238
you can't call any methods until you're initialized,
在属性全部初始化以前确实不可以调用方法，

618
00:26:37,240 --> 00:26:39,974
by the time somebody tries to get this property,
直到有人试图 get 这个 property

619
00:26:39,976 --> 00:26:41,408
you'd be fully initialized.
它就会被初始化了

620
00:26:41,410 --> 00:26:43,343
So, you can call methods.
所以方法就可以调用了

621
00:26:43,345 --> 00:26:45,779
So, you see the advantage of lazy there?
到这你能看出用 lazy 的优势了吗？

622
00:26:45,781 --> 00:26:47,798
'Kay.

623
00:26:47,799 --> 00:26:49,816
This lazy thing still satisfies the rule that you
这个 lazy 特性依然满足“所有属性必须

624
00:26:49,818 --> 00:26:53,285
must initialize all of your properties.
初始化”的规则

625
00:26:53,287 --> 00:26:56,688
'Kay, even though it doesn't actually initialize it until someone accesses it.
即使它在被用到以前并没有被初始化，

627
00:26:56,690 --> 00:26:58,490
It still satisfies that rule.
它依然遵循这个规则

628
00:27:00,293 --> 00:27:04,528
unfortunately, only vars can be lazily initialized.
但是，只有 var 才可以用 lazy 初始化这个特性

629
00:27:04,530 --> 00:27:06,347
Things that are let,
因为 let，也就是类里的常量

630
00:27:06,348 --> 00:27:11,134
if you had constants in your class, those would have to be initializing in your initializer.
都必须在类的初始化方法里初始化

632
00:27:11,135 --> 00:27:14,102
You can't initialize them lazily, only vars, not lets.
只有 var 可以用 lazy，let 不可以

633
00:27:14,105 --> 00:27:19,108
This can be used to get around some kind of tricky initialization dependencies.
这个特性一般会用来处理一些错综复杂的初始化依赖

635
00:27:19,110 --> 00:27:20,909
Because of that rule that everything has to be
正是因为在类的内部的规则：在做任何事之前，

636
00:27:20,911 --> 00:27:22,577
initialized before you can do anything.
所有的 property 都必须被初始化

637
00:27:22,579 --> 00:27:24,479
Sometimes you can get into fights with your
有时类会和它的父类有一些交集，

638
00:27:24,481 --> 00:27:27,114
superclass for example, about when something's gonna be
举个例子

639
00:27:27,116 --> 00:27:29,883
initialized, and you need your superclass to do something or
当有些 property 将要被初始化时，需要你或者你的父类做一些事情

640
00:27:29,885 --> 00:27:32,252
you can do something, but it needs you to do something
但是你在做这些事情之前还需要先解决一些事情

641
00:27:32,254 --> 00:27:35,288
before they can do something, so you're kinda we're stuck.
这时候你就会有点卡住

642
00:27:35,290 --> 00:27:37,290
And what you can do is one of the other of you,
这时候你就可以让

643
00:27:37,292 --> 00:27:40,259
make one of the things that depends on their lazy.
某些 property 依赖于它们的 lazy 初始化

644
00:27:40,261 --> 00:27:45,196
Okay. And then, as soon as somebody wants it, it'll get initialized and off we go.
这样的话，当有东西需要这个 property 的时候，它才会被初始化


646
00:27:47,000 --> 00:27:48,599
Okay? Any questions about Lazy?
明白了吗？关于 lazy 大家有问题吗？

647
00:27:48,601 --> 00:27:53,337
Pretty cool feature. All right?
非常好的特性

649
00:27:53,338 --> 00:27:55,338
And it's exactly, what it sounds like, just lazily waits
准确的来说，就跟这个特性的名字一样，就是懒懒地等着别人

650
00:27:55,341 --> 00:27:58,342
to initialize until someone wants this property.
需要这个属性的时候，这个属性才开始初始化

651
00:27:58,344 --> 00:27:59,743
Okay?

652
00:27:59,745 --> 00:28:02,545
So, now let's talk about initialization, so
下边咱们来聊聊初始化，

653
00:28:02,547 --> 00:28:06,148
I need to get, I need a drink before the initialization, cuz it's complicated.
在说这个话题之前我得喝点水，因为初始化很复杂

655
00:28:08,719 --> 00:28:10,652
Hopefully my, I'm just, I'm not, this is not,
希望我没事儿

656
00:28:10,654 --> 00:28:11,819
just taking care of my voice here.
就是怕我嗓子坏了

657
00:28:11,821 --> 00:28:15,689
Okay, init, all right.
好了，init

658
00:28:15,691 --> 00:28:18,392
So, when do you need an init method?
什么时候需要一个 init 方法？

659
00:28:18,394 --> 00:28:20,344
Well, you know what?
事实上你知道吗？

660
00:28:20,345 --> 00:28:22,295
You actually don't need an init method that often.
大多数时候并不需要 init 方法

661
00:28:22,297 --> 00:28:26,332
'Kay? We showed,had the init method in the CalculatorBrain.
我们之前演示过 CalculatorBrain 类的 init 方法，

663
00:28:26,334 --> 00:28:27,766
Made sense there. We needed it there.
在那 init 确实是有用而且必要的

665
00:28:28,902 --> 00:28:29,868
But you don't need it that often,
但是实际上大多数时候不太需要 init，

666
00:28:29,870 --> 00:28:34,005
because a lot of your variables and constants in your class or
因为类或者结构体里边大部分的常量和变量都会

668
00:28:34,007 --> 00:28:37,808
struct are set with equals, so you don't need them.
通过赋值被初始化

669
00:28:37,810 --> 00:28:40,110
Or maybe the properties are Optionals.
或者有些属性是 Optional 的，

670
00:28:40,112 --> 00:28:41,511
And so they can just start out nil and
这样即使他们是 nil 也没问题，

671
00:28:41,513 --> 00:28:46,115
you can set them later like the outlets in a storyboard.
也可以在之后在给他们赋值，就像 StoryBoard 里的 outlet 一样

672
00:28:46,117 --> 00:28:50,752
Or you can actually initialize by using a closure.
又或者可以用闭包来初始化

673
00:28:50,754 --> 00:28:52,287
Okay? As I showed in the previous
理解这个吗？就像我之前演示的

674
00:28:52,289 --> 00:28:54,756
thing, that lazy thing, that you, you can do that for
lazy 那个特性一样，你一样可以用闭包来初始化一个

675
00:28:54,758 --> 00:28:57,558
non-lazies, put the closure thing there and execute it.
非 lazy 的属性

676
00:28:57,560 --> 00:28:59,226
It'll get executed right away and
不同的是这个闭包会立即执行并且

677
00:28:59,228 --> 00:29:01,328
nothing inside that closure could refer to
闭包里没有任何与其他实例变量有关系的东西

678
00:29:01,330 --> 00:29:03,830
other instance variables of, of course because it
因为这个闭包会在初始化全部完成

679
00:29:03,832 --> 00:29:06,666
would be executing before the initialization was done.
以前就执行了

680
00:29:06,668 --> 00:29:09,869
But still, you can calculate some things to assign things
但是你仍然可以通过闭包

681
00:29:09,871 --> 00:29:11,937
in a closure, by executing a closure.
做一些计算来赋值

682
00:29:13,173 --> 00:29:16,841
and, or you could use the lazy mechanism and then to avoid needing an init.
你也可以使用 lazy 机制，从而避免使用 init 方法

684
00:29:16,843 --> 00:29:18,776
So, there's a lot of ways to avoid init.
所以有很多方法来避免使用 init

685
00:29:19,979 --> 00:29:24,014
But if you do need an init then what,
但如果你确实需要一个 init 方法的时候，

686
00:29:24,016 --> 00:29:26,516
what, how do we do init?
该怎么做呢？

687
00:29:26,518 --> 00:29:28,384
Because init has some kind of
因为 init 方法会有一些很有趣

688
00:29:28,386 --> 00:29:31,220
interesting inter-dependencies,
的互相依赖关系，

689
00:29:31,222 --> 00:29:34,956
it's not as straightforward as you might think.
它并不像你可能想象的那么简单

690
00:29:34,958 --> 00:29:37,658
Now you get some free inits-
在一些情况下，init 方法会自动生成，

691
00:29:37,660 --> 00:29:39,593
'Kay? Inits that get done for
也就是说 init 已经给你准备好了

692
00:29:39,595 -->00:29:45,231
you, one is that if all the properties in a class,in a base class.
其中一种情况就是如果一个基类，

694
00:29:45,233 --> 00:29:47,600
Not a co, this is something that has no superclass,
基类就是指没有父类的类，

695
00:29:47,602 --> 00:29:48,668
like CalculatorBrain.
比如 CalculatorBrain

696
00:29:48,670 --> 00:29:50,469
If they all have defaults,
如果它的所有的 property 都有默认值

697
00:29:50,471 --> 00:29:53,939
then you'll get an inits with no arguments for free.
那么你就会自动得到一个没有参数的 init 方法

698
00:29:53,941 --> 00:29:56,508
So, if we haven't implemented CalculatorBrains, init,
所以尽管我们没有为 CalculatorBrains 类写 init 方法，

699
00:29:56,510 --> 00:29:58,109
of course, we still could have said.
我们依然可以写

700
00:29:58,111 --> 00:30:00,378
>> You know, brain = CalculatorBrain().
brain = CalculatorBrain()

701
00:30:00,380 --> 00:30:03,280
That's because we get a free init in calculator brain,
这是因为我们有一个默认的 init

702
00:30:03,282 --> 00:30:06,283
cuz we initialized our default using equals something.
我们默认使用等于某值初始化

703
00:30:06,285 --> 00:30:07,467
Okay. So you,
所以

704
00:30:07,468 --> 00:30:08,650
that's one way to get an init.
这是一种得到 init 的方法

705
00:30:08,653 --> 00:30:11,421
A struct, not a class, but a struct,
结构体，不是类，但是结构体

706
00:30:11,423 --> 00:30:15,324
it will get a default one that has all the properties as
它将默认得到一个将所有 property 作为参数的初始化方法

707
00:30:15,326 --> 00:30:18,627
arguments only if you have no initializers.
仅当没有初始化函数时

708
00:30:18,629 --> 00:30:21,897
So if you had a struct and you gave it no initializers,
因此，如果你有一个结构体并且没有初始化方法

709
00:30:21,899 --> 00:30:24,899
you would get one for free, which would be init or
你会得到一个默认的初始化方法

710
00:30:24,901 --> 00:30:27,935
all the arguments match all of the vars you have.
并且所有的参数和变量匹配，如果有的话

711
00:30:27,937 --> 00:30:29,970
All the vars and lets, okay?
所有的 var 和 let，明白吧？

712
00:30:29,972 --> 00:30:35,108
So here I got a struct, it has two properties there, x and y.
一个结构体，它有两个 property ，x 和 y

713
00:30:35,110 --> 00:30:38,945
And you can see that I got this init, x takes an Int and
你可以看到我这里有一个 init 方法，x 是 Int类型

714
00:30:38,947 --> 00:30:41,514
a y String for free, for free.
y 是 String 类型

715
00:30:41,516 --> 00:30:44,183
I didn't have to implement that at all, it just came for
我不要实现它

716
00:30:44,185 --> 00:30:45,684
free and so people can call that.
它就可以被调用

717
00:30:45,686 --> 00:30:48,186
They can initialize MyStruct, by saying,
可以通过圆括号，提供 x 和 y 的值来

718
00:30:48,188 --> 00:30:51,322
MyStruct open parentheses and provide the x and the y.
初始化 MyStruct

719
00:30:51,324 --> 00:30:52,857
Okay?

720
00:30:52,859 --> 00:30:54,058
All right.

721
00:30:54,060 --> 00:30:56,727
So, what can you do inside of init?
你可以在 init 里面做什么？

722
00:30:56,729 --> 00:30:57,895
Okay. We saw,
好，我们看到

723
00:30:57,896 --> 00:30:59,062
what we did in calculator brain,
我们在 CalculatorBrain 里做了什么

724
00:30:59,064 --> 00:31:00,763
we initialized some stuff.
我们初始化了些 property

725
00:31:00,765 --> 00:31:02,498
But what can you do?
你可以做什么？

726
00:31:02,499 --> 00:31:04,232
Well, you can set any properties value in there.
你可以在里面设置任何 property 的值

727
00:31:04,235 --> 00:31:05,300
You can even set
你甚至可以

728
00:31:05,302 --> 00:31:07,235
properties that have default values.
给 property 设置默认值

729
00:31:07,237 --> 00:31:09,771
So even if you have properties set equals 12.
即使你把它设置为等于12

730
00:31:09,773 --> 00:31:12,540
In your init, you can reset that thing to something else
在你的 init 里，你可以把一些东西重置为别的什么

731
00:31:12,542 --> 00:31:15,109
if you wanted to, if you changed your mind in init.
如果你想的话

732
00:31:15,111 --> 00:31:16,010
Okay?

733
00:31:16,012 --> 00:31:16,910
You can do that.
你可以这样做

734
00:31:16,912 --> 00:31:20,913
You can also set constant properties.
你也可以给常量 property 赋值

735
00:31:20,915 --> 00:31:24,817
So if you have a struct or a class and
如果你有一个结构体或者类

736
00:31:24,819 --> 00:31:31,189
it has let x colon String, you can set that in your init.
它有一个 property: let x: String

737
00:31:31,191 --> 00:31:34,192
Even though to let, it's gotta get set some time in your init
即使是 let，它也可以在 init 里

738
00:31:34,194 --> 00:31:35,326
is when you can set it.
被你赋值

739
00:31:35,328 --> 00:31:37,094
You can also say, equal something, but
也可以是等于其他什么

740
00:31:37,096 --> 00:31:38,495
you can also set it in your init.
你可以在 init 里这么做

741
00:31:38,497 --> 00:31:40,230
Okay?

742
00:31:40,231 --> 00:31:41,964
So people sometimes don't understand, realize,
人们有时不理解

743
00:31:41,967 --> 00:31:44,567
they're like, oh, I can have lets in my class?
他们肯定在想，哦，在我的 class 里可以有 let？

744
00:31:44,569 --> 00:31:46,602
Can have like, you know, constants for
可有一样，你知道的

745
00:31:46,604 --> 00:31:49,038
my class that are created at initialization and
类里的常量在初始化和创建实例

746
00:31:49,040 --> 00:31:51,306
stay the same for the lifetime of instance and
的生命周期里是保持不变的

747
00:31:51,308 --> 00:31:54,242
absolutely you can and you initialize them in your init.
你绝对可以在 init 里初始化它们

748
00:31:54,244 --> 00:31:55,443
Okay.

749
00:31:55,444 --> 00:31:56,643
That's actually a good practice if
这实际上是很好的做法

750
00:31:56,646 --> 00:32:00,214
you have something that's, you know, constant like that.
如果你需要定义常量属性

751
00:32:00,216 --> 00:32:04,385
You can call other init methods in your own class or
在你的类或者结构体里你可以调用其他的 init 方法

752
00:32:04,387 --> 00:32:06,687
struct using self.init.
使用 self.init

753
00:32:06,689 --> 00:32:08,422
Okay?

754
00:32:08,423 --> 00:32:10,156
Self.init, you can call the other ones with the ones that
self.init，你可以调用有不同参数的

755
00:32:10,158 --> 00:32:11,524
have different arguments.
其他 init 方法

756
00:32:11,526 --> 00:32:13,026
Okay?

757
00:32:13,027 --> 00:32:14,527
So that sounds good.
所以听起来很不错

758
00:32:14,529 --> 00:32:18,297
And of course in a class, you can call super.init.
当然，在类里你也可以调用 super.init

759
00:32:18,299 --> 00:32:20,132
Call your superclass's initializers,
调用你父类的初始化方法

760
00:32:20,134 --> 00:32:22,267
what their arguments whatever, they might be.
参数无论是什么，如果有的话

761
00:32:22,269 --> 00:32:26,237
However, big old humongous, however on this one.
然而很重要的是

762
00:32:26,239 --> 00:32:28,205
There are a lot of rules for
调用其他的 init 时有很多规则

763
00:32:28,207 --> 00:32:31,842
calling other inits, especially in classes.
尤其是在类里

764
00:32:31,844 --> 00:32:34,077
They instruct, it's not a big deal.
在结构体里，这并不是一个大问题

765
00:32:34,078 --> 00:32:36,311
But in classes, there's a lot of rules and were gonna take
但在类里，有很多规则，我们将拿两个幻灯片

766
00:32:36,314 --> 00:32:39,182
two slides here to go through these rules briefly.
对这些规则做简单介绍

767
00:32:39,184 --> 00:32:39,849
All right.

768
00:32:39,851 --> 00:32:41,116
So as part of these rules,
所以作为这些规则的一部分

769
00:32:41,118 --> 00:32:43,118
what do you required to do inside of init?
你需要在 init 里做些什么？

770
00:32:43,120 --> 00:32:45,186
What is mandatory for you to do?
什么是你必须要做的？

771
00:32:45,188 --> 00:32:48,156
Well, as you know, you have to have initialized all
好，正如你所知道的，在你的类里

772
00:32:48,158 --> 00:32:50,324
the properties in your entire class.
所有的 property 都必须初始化

773
00:32:50,326 --> 00:32:52,659
You can not start a class off with no value.
他们都必须有值

774
00:32:52,661 --> 00:32:56,163
And remember, Optionals, nil is a value for an Optional.
记住，对于 Optionals，nil 也是值

775
00:32:56,165 --> 00:32:58,498
So if an Optional is nil, it is set.
所以，如果你有一个 Optional 是 nil，这也算它有值

776
00:32:58,500 --> 00:32:59,766
So, everything's fine there.
一切都好了

777
00:32:59,768 --> 00:33:03,202
There are two times, type,
在类里，Swift 提供两种类型

778
00:33:03,204 --> 00:33:05,504
types of inits in a class.
的构造器来初始化

779
00:33:05,506 --> 00:33:06,805
Not in a struct, but in a class.
不是在结构体里，在类里

780
00:33:06,807 --> 00:33:09,007
One is called a convenience init and
一种是 Convenience Init

781
00:33:09,009 --> 00:33:11,242
then there's all the other kinds.
其它的都是另一种类型

782
00:33:11,244 --> 00:33:13,377
Those are called designated initializers.
叫 Designated Initializers

783
00:33:13,379 --> 00:33:15,012
So by default, an initializer is
默认的 initializer

784
00:33:15,014 --> 00:33:17,647
called a designated initializer, but there's also
是 designated initializer，但是另外还有些

785
00:33:17,649 --> 00:33:20,116
these things called convenience initializers.
叫 convenience initializers

786
00:33:20,118 --> 00:33:21,384
And we make this distinction,
我们得做出区分

787
00:33:21,386 --> 00:33:23,886
because there's a little bit different rules about them.
因为它们的规则有一点点的不同

788
00:33:23,888 --> 00:33:25,220
So lets talk about that.
我们来看看吧

789
00:33:25,222 --> 00:33:28,056
A designated initializer, one that doesn't take
Designated initializer，不能有

790
00:33:28,058 --> 00:33:29,858
convenience in the front of it.
convenience 在它的前面

791
00:33:29,860 --> 00:33:31,325
It has to, and
它只能

792
00:33:31,327 --> 00:33:37,564
can only call a designated initializer in its superclass.
调用其父类的 designated initializer

793
00:33:37,566 --> 00:33:38,899
It's a very important rule.
这是一个非常重要的规则

794
00:33:38,901 --> 00:33:40,601
Okay. If you

795
00:33:40,602 --> 00:33:42,302
have a designated initializer, initializer doesn't have
如果有一个 designated initializer

796
00:33:42,304 --> 00:33:43,936
the word convenience in front of it,
它前面没有 convenience 这个单词在

797
00:33:43,938 --> 00:33:45,838
it can't call another init in your class.
在你的类里不能调用其他的 init 方法

798
00:33:45,840 --> 00:33:47,706
It has to call a superclass in init and
必须在 init 里调用父类的 init

799
00:33:47,708 --> 00:33:49,808
it has to be a designated initializer not
而且它必须是一个 designated initializer

800
00:33:49,810 --> 00:33:52,243
a convenience initializer in the superclass.
而不是 convenience initializer

801
00:33:52,245 --> 00:33:53,878
Okay?

802
00:33:53,880 --> 00:33:56,280
Understand that rule number one?
理解第一条规则了吗？

803
00:33:56,282 --> 00:33:57,314
That's your designated initial.
这就是你们的预设初始化（designated initial）

804
00:33:57,316 --> 00:33:59,183
This is all, by
这就是全部了

805
00:33:59,184 --> 00:34:01,051
the way in the documentation It's very elaborately.
顺便说一下，在文档中有详细的描述

806
00:34:01,053 --> 00:34:02,485
Drawn out with pictures and all that.
有图表之类的说明

807
00:34:02,487 --> 00:34:04,020
I'm just trying to summarize it here.
我这里只是大概提一下

808
00:34:04,022 --> 00:34:05,488
Okay. Hopefully,
希望

809
00:34:05,489 --> 00:34:06,955
you've read that already and this is review.
你们已经读了文档，这是复习

810
00:34:06,958 --> 00:34:09,458
But if not, hopefully you're understanding a little bit of
如果没有，希望你们能理解一点

811
00:34:09,460 --> 00:34:11,093
what I'm saying.
我所说的

812
00:34:11,094 --> 00:34:12,727
Tonight when you read it, you'll be, oh yeah, I get it.
今晚，当你们阅读文档时，就会明白了

813
00:34:12,730 --> 00:34:14,262
Okay. So that's the rule for
这就是

814
00:34:14,264 --> 00:34:15,897
designating initializer.
designating initializer 的规则

815
00:34:15,899 --> 00:34:19,233
You have to initialize all of your own
你必须在调用父类的初始化函数前

816
00:34:19,235 --> 00:34:24,838
properties before you call your superclass's initializer.
先初始化你自己的所有的 property

817
00:34:24,840 --> 00:34:25,572
Okay? This is for
只有 designated initializers

818
00:34:25,574 --> 00:34:26,939
designated initializers only,
需要这样

819
00:34:26,941 --> 00:34:29,342
cuz they are the ones who call supervisors initializers.
因为他们调用 supervisors initializers

820
00:34:29,344 --> 00:34:32,478
So you have to be done with your own properties before you
所以你必须在调用父类的 property 前

821
00:34:32,480 --> 00:34:34,046
call your superclass's.
先处理你自己（类）的 property

822
00:34:34,048 --> 00:34:36,348
This one will trip you up, often.
这经常让你有些麻烦

823
00:34:36,350 --> 00:34:39,350
Okay? You also have to call your
你要先调用

824
00:34:39,352 --> 00:34:43,420
superclass's init before you assign a value to
父类的初始化函数，然后才能给继承自父类的

825
00:34:43,422 --> 00:34:47,557
any property you inherit from your superclass.
property 赋值

826
00:34:47,559 --> 00:34:49,125
In other words,
也就是说，

827
00:34:49,126 --> 00:34:50,692
you have to let your superclass's initialize,
你必须先让你的父类初始化它的 property，

828
00:34:50,695 --> 00:34:53,262
it's properties before you can start setting them.
然后你才能给它们赋值

829
00:34:53,264 --> 00:34:54,963
So you get those three rules?
你们现在明白这三条规则了吗？

830
00:34:54,965 --> 00:34:56,832
Okay.

831
00:34:56,833 --> 00:34:58,700
That has to do with, so you're superclass, cuz it has to do
这和你们的父类有关，因为它必须处理

832
00:34:58,702 --> 00:35:01,302
with designated intitializers and calling super.
designated intitializers 并调用它的父类（的初始化函数）

833
00:35:01,304 --> 00:35:02,921
All right. Now

834
00:35:02,922 --> 00:35:04,539
a convenience initializer has different rules.
convenience initializer 有不同的规则

835
00:35:04,541 --> 00:35:06,073
Okay? First of all,
首先，

836
00:35:06,075 --> 00:35:09,243
a convenience initializer must and
convenience initializer 必须

837
00:35:09,245 --> 00:35:14,581
can only call a designated initializer in it's own class.
而且只能调用本类的 designated initializer

838
00:35:14,583 --> 00:35:16,249
Convenience initializer,
Convenience initializer，

839
00:35:16,251 --> 00:35:19,118
initializer cannot call super init of any kind.
这类初始化函数不能调用任何父类的初始化函数

840
00:35:19,120 --> 00:35:21,653
And it can't call and it must call a,
它必须调用

841
00:35:21,655 --> 00:35:23,388
a designated initializer.
designated initializer

842
00:35:23,390 --> 00:35:26,358
Now it can call that designated initializer
它能通过调用其他的 convenience initializer

843
00:35:26,360 --> 00:35:29,860
indirectly through another convenience initializer.
间接调用 designated initializer

844
00:35:29,862 --> 00:35:31,312
Okay.

845
00:35:31,313 --> 00:35:32,763
So one convenience initializer can call self another
因此 convenience initializer 能调用本类其他

846
00:35:32,765 --> 00:35:35,866
convenience initializer, which called designated initializer.
调用 designated initializer 的 convenience initializer

847
00:35:35,868 --> 00:35:39,268
But eventually, a designated initializer must be called.
但最后，有个 designated initializer 必须被调用

848
00:35:39,270 --> 00:35:40,870
Okay?

849
00:35:40,872 --> 00:35:43,906
A convenience initializer must call that
一个 convenience initializer 必须先直接或

850
00:35:43,908 --> 00:35:46,775
designated initializer, directly or
间接调用 designated initializer，

851
00:35:46,777 --> 00:35:50,945
indirectly before it can touch any values, obviously.
然后才能访问其他的值

852
00:35:50,947 --> 00:35:52,263
Okay?

853
00:35:52,264 --> 00:35:53,580
You have to kinda get the main, your
你必须让主要的，

854
00:35:53,583 --> 00:35:56,483
object primarily initialized before you can have
你的对象首先被初始化，然后你才能

855
00:35:56,485 --> 00:36:00,253
the convenience initializer start hacking at properties.
让 convenience initializer 开始访问 property

856
00:36:00,255 --> 00:36:03,356
The calling of other inits, whether your a convenience guy
其他初始化函数的调用，不管是你的 convenience initializer

857
00:36:03,358 --> 00:36:06,125
calling your designator or whether your a designator
调用你的 designator initializer，还是你的 designator initializer

858
00:36:06,127 --> 00:36:08,961
calling up to your supers designator has to be complete
调用你父类的 designator initializer，

859
00:36:08,963 --> 00:36:12,197
before you can start accessing your properties and methods.
所有这些都必须在你开始访问 property 和方法之前完成

860
00:36:12,199 --> 00:36:15,400
In other words, the class has to be initialized before you
也就是说，这个类必须被初始化，然后

861
00:36:15,402 --> 00:36:17,869
can start calling methods and properties.
你才能开始调用方法和 property

862
00:36:17,871 --> 00:36:19,838
Okay?

863
00:36:19,839 --> 00:36:21,806
That's why we have to use lazy if we want a property to
这就是为什么我们必须使用 lazy 的方式，

864
00:36:21,808 --> 00:36:24,275
set its value to be calling a method.
如果想让 property 在被调用方法的时候被赋值

865
00:36:24,277 --> 00:36:25,943
Because we can't do it non-lazily,
因为我们不能使用 non-lazily 的方式

866
00:36:25,945 --> 00:36:28,245
because we wouldn't be initialized at that time.
因为那时我们还没被初始化

867
00:36:28,247 --> 00:36:30,113
We'd still be in the process of initializing.
我们还在初始化过程中

868
00:36:30,115 --> 00:36:31,981
It's kind of a two phase initialization.
这如同初始化的两个阶段

869
00:36:31,983 --> 00:36:36,652
You get fully initialized, now you can go do that.
完全初始化之后，你就能那样做了

870
00:36:36,654 --> 00:36:38,120
Okay? So these are the rules.
这就是（初始化的）规则了

871
00:36:38,122 --> 00:36:40,139
Question?
有问题吗？

872
00:36:40,140 --> 00:36:42,157
Is there a way to set the constant then by
（学生提问）

873
00:36:42,159 --> 00:36:43,691
by calling a method?
（学生提问）

874
00:36:43,693 --> 00:36:44,942
So the question is,
问题是，

875
00:36:44,943 --> 00:36:46,192
is there a way to set constant by calling a method or
有没有一种方式，可以调用方法或者类似的途径

876
00:36:46,195 --> 00:36:47,027
something like that?
给常量赋值

877
00:36:47,029 --> 00:36:47,828
And the answer is no.
答案是不能

878
00:36:47,830 --> 00:36:49,029
Okay.

879
00:36:49,031 --> 00:36:52,098
You can only set constants either setting them equals
你只能给常量赋予等于的某个值，

880
00:36:52,100 --> 00:36:54,033
something or in your initializers.
或者在你的初始化函数中

881
00:36:54,035 --> 00:36:57,969
Unfortunately, later we can't do it.
不幸的是，之后我们不能做这些了

882
00:36:57,971 --> 00:36:59,104
Okay.

883
00:36:59,106 --> 00:37:01,239
Let's talk about inheriting init.
让我们聊聊继承式初始化

884
00:37:01,241 --> 00:37:02,507
Okay?

885
00:37:02,508 --> 00:37:03,774
Cuz this is complicated, as well.
这也很复杂

886
00:37:03,776 --> 00:37:05,876
So here are the rules for inheriting init.
这就是继承式初始化的规则了

887
00:37:05,878 --> 00:37:10,413
If you do not implement any designated initializers in
如果你没有在你的类中实现任何 designated initializers ，

888
00:37:10,415 --> 00:37:14,250
your class, any, then you'll inherit all of
那么，你将继承你父类中的

889
00:37:14,252 --> 00:37:18,320
your superclass's designated initializers.
所有 designated initializers

890
00:37:18,322 --> 00:37:20,889
Otherwise, you'll inherit none of your de,
否则，你将不继承任何你的父类中的

891
00:37:20,891 --> 00:37:23,358
superclass's designated initializers.
designated initializers

892
00:37:23,360 --> 00:37:25,059
Okay?

893
00:37:25,061 --> 00:37:28,396
It's all or nothing on designated initializers.
要么就是继承全部的 designated initializers，要么就是一个都不继承

894
00:37:28,398 --> 00:37:33,934
If you override all of your superclass's designated inits.
如果你覆盖了你父类中的所有 designated initializers，

895
00:37:33,936 --> 00:37:34,668
Okay?

896
00:37:34,670 --> 00:37:36,536
All, so your superclass has
比如，你的父类中有

897
00:37:36,537 --> 00:37:38,403
three designated initializers with different arguments.
三种不同参数的 designated initializers，

898
00:37:38,406 --> 00:37:41,607
If you override all of them, then you'll inherit all of
如果你重写了所有这些方法，那么你就继承了父类中所有的

899
00:37:41,609 --> 00:37:44,443
your superclass's convenient initializers.
convenient initializers

900
00:37:44,445 --> 00:37:46,778
Also, if you implement none of them.
同样，如果你没有实现它们中的任一个方法，

901
00:37:46,780 --> 00:37:48,947
Because you'll essentially inherit all
在这种情况下，你将继承

902
00:37:48,949 --> 00:37:51,816
the designateds and all the convenience in that case.
所有 designated 和 convenience initializer

903
00:37:51,818 --> 00:37:53,884
Okay?

904
00:37:53,886 --> 00:37:55,419
So that's the inheritance rule.
这就是继承的规则

905
00:37:55,421 --> 00:37:56,520
This trips people up, too.
这让人有点搞不懂

906
00:37:56,522 --> 00:37:57,587
They're like, oh yeah,
他们说，哦耶，

907
00:37:57,589 --> 00:37:59,255
I implemented that one initializer, but
我实现了一个初始化

908
00:37:59,257 --> 00:38:01,190
how come the other initializer doesn't work?
但是其他的初始化为什么没用？

909
00:38:01,192 --> 00:38:02,624
Well, because once you initiali...
好吧，因为一旦你初始化

910
00:38:02,626 --> 00:38:04,326
implement one designated initializer,
执行一个 designated initializer

911
00:38:04,328 --> 00:38:05,827
you don't inherit the rest of them.
你就不必继承其他的

912
00:38:05,829 --> 00:38:08,129
Okay?

913
00:38:08,130 --> 00:38:10,430
So it's all or nothing on designateds.
所以对于 designated initializers 不是全有就是全无

914
00:38:10,433 --> 00:38:13,067
And on convenience, it's kind of all or nothing too.
而对于 convenience 也一样如此

915
00:38:13,069 --> 00:38:15,936
Cuz you have to implement or not implement all of
因为为了执行 convenience，你必须全实现或者

916
00:38:15,938 --> 00:38:18,939
the designateds to get the conveniences.
全不实现 designated initializers

917
00:38:18,941 --> 00:38:23,876
Any init that you inherit by these rules that I just said,
任何 init，如果是按照我刚才说的规则继承而来的话

918
00:38:23,878 --> 00:38:27,880
count for all the rules on the previous slide.
包括之前幻灯片提到的所有规则

919
00:38:27,882 --> 00:38:30,849
I'm not gonna go back to the previous slide and go through
在这里，我就不回顾之前幻灯片的内容了

920
00:38:30,851 --> 00:38:33,852
them all, but you can satisfy a lot of the requirements in
不过，其实就这样继承 initializer 就可以满足

921
00:38:33,854 --> 00:38:36,988
the previous slide by just inheriting your initializers.
很多之前的幻灯片里讲的规则了

922
00:38:36,990 --> 00:38:38,289
Okay?

923
00:38:38,291 --> 00:38:39,757
But you have,
但是你

924
00:38:39,758 --> 00:38:41,224
you can only inherit them in these kind of restricted ways.
只能通过这种受限制的方法去继承它们

925
00:38:41,227 --> 00:38:42,426
But once you do,
不过只要你这么做了

926
00:38:42,428 --> 00:38:46,063
you can satisfy a lot of those previous rules.
之前的所有规则就都可以满足了

927
00:38:46,065 --> 00:38:48,999
It is possible to have what's called a required init.
可能有人问什么是 required init

928
00:38:49,001 --> 00:38:51,034
You just put required on it.
就是在前面写上 required

929
00:38:51,036 --> 00:38:52,268
And if you put required,
如果你写上 required，

930
00:38:52,270 --> 00:38:54,536
it means that subclasses must implement it.
那么它的子类就必须实现这个方法

931
00:38:54,538 --> 00:38:56,722
It is required.
这就是 required

932
00:38:56,723 --> 00:38:58,907
Now they can inherit it by the rules above.
现在通过遵守上面的规则，你可以继承它了

933
00:38:58,909 --> 00:39:00,241
In other words, if they don't,
换句话说，如果没有实现

934
00:39:00,243 --> 00:39:02,043
implement any designated negative initializers,
任何 designated initializers

935
00:39:02,045 --> 00:39:04,578
they'll inherit the required initializer, that's good.
它们将会继承 required 的初始化，这非常棒

936
00:39:04,580 --> 00:39:07,948
But if you implement any of the designated initializers,
但是如果你实现了任何一个 designated initializers，

937
00:39:07,950 --> 00:39:10,217
you must implement the required ones.
你就必须实现 required 的那些

938
00:39:10,219 --> 00:39:11,885
Okay?

939
00:39:11,887 --> 00:39:15,554
Finally, there's failable initializers.
最后，再说说 failable initializers

940
00:39:15,556 --> 00:39:18,357
Okay?

941
00:39:18,358 --> 00:39:21,159
So some initializers are allowed to fail and return nil.
有一些 initializer 允许失败并且返回 nil

942
00:39:21,161 --> 00:39:22,878
Okay?

943
00:39:22,879 --> 00:39:24,596
You, you designate them by putting question mark
你在初始化完成后，可以加个注释

944
00:39:24,598 --> 00:39:26,931
after the init, like this right here.
就像我这里一样

945
00:39:26,933 --> 00:39:28,316
Okay?

946
00:39:28,317 --> 00:39:29,700
Now, this is pretty uncommon.
现在，这是很少见的

947
00:39:29,702 --> 00:39:31,702
Okay? You don't see
明白吗？你们不经常见这些

948
00:39:31,703 --> 00:39:33,703
these very often and the documentation last I checked,
我上次查文档的时候，

949
00:39:33,706 --> 00:39:35,739
doesn't really show this very well.
它也没描述的特别仔细

950
00:39:35,741 --> 00:39:37,574
It doesn't put the question mark in there.
它没有把问号写在那儿

951
00:39:37,576 --> 00:39:38,541
I think it's just
我觉得是

952
00:39:38,543 --> 00:39:41,010
a documentation generation problem.
生成文档的时候出现的问题

953
00:39:41,012 --> 00:39:43,712
It will say in, in the comment for
它会在初始化的时候提示

954
00:39:43,714 --> 00:39:46,915
the init, this can return nil, if it fails.
这个可能会返回 nil ，如果失败的话

955
00:39:46,917 --> 00:39:48,083
But it doesn't put,
但是它没有写，

956
00:39:48,084 --> 00:39:49,250
the question mark on there.
应该是把问号写在那儿

957
00:39:49,252 --> 00:39:51,419
But that's okay, because when you start using it,
但是没关系，因为当你用它的时候

958
00:39:51,421 --> 00:39:53,087
you're gonna call this initializer.
你就会调用它

959
00:39:53,089 --> 00:39:54,988
And the thing's gonna come back and you're gonna try and
回调了之后你尝试

960
00:39:54,990 --> 00:39:55,722
send messages to it.
给它发送一个消息

961
00:39:55,724 --> 00:39:57,524
And it's gonna say,
它会提示

962
00:39:57,525 --> 00:39:59,325
this isn't Optional, does not respond to the method.
这个方法不是 Optional 的，没有对应的方法

963
00:39:59,327 --> 00:40:00,159
And you're like, what?
你会惊讶，我擦！

964
00:40:00,161 --> 00:40:01,294
Isn't Optional?
它不是 Optional？

965
00:40:01,295 --> 00:40:02,428
And then you're gonna know.
然后你就会瞬间反应过来

966
00:40:02,429 --> 00:40:03,562
Oh, the initializer was failable.
哦，这是个 failable initializer

967
00:40:03,564 --> 00:40:05,698
So let's look at an example of this.
来，我们来看这个例子

968
00:40:05,700 --> 00:40:07,065
So UIImage.
关于 UIImage

969
00:40:07,067 --> 00:40:09,751
Okay?

970
00:40:09,752 --> 00:40:12,436
That's a class in UIKit.
它是 UIKit 中的一个类

971
00:40:12,439 --> 00:40:14,772
And it returns an image.
然后，它返回一个图片

972
00:40:14,774 --> 00:40:17,107
And you can ask for an image by its name.
你可以通过它的名称来获取图片

973
00:40:17,109 --> 00:40:19,976
But of course, that image named that might not be
当然，如果你的项目中如果不存在图片的话

974
00:40:19,978 --> 00:40:23,346
anywhere in your project, so this thing can return nil.
它就会返回 nil

975
00:40:23,348 --> 00:40:24,814
So in this case right here,
那么在这里，

976
00:40:24,816 --> 00:40:27,316
image equals UIImage named: "foo".
名为 "foo" 的图片赋值给 image

977
00:40:27,318 --> 00:40:29,284
image is an Optional UIImage,
image 是一个 Optional UIImage

978
00:40:29,286 --> 00:40:32,320
even I'm calling initializer there, right?
即使我调用了 initializer

979
00:40:32,322 --> 00:40:34,222
UIImages initializer.
UIImages 的 initializer

980
00:40:34,224 --> 00:40:35,923
It could be. So,
image 可以是 Optional

981
00:40:35,925 --> 00:40:38,092
Usually, what we do in this case is we use if let.
这种情况下我们会用 if let

982
00:40:38,094 --> 00:40:41,061
If we can let the image equal the image name foo,
如果 image = UIImage(name: "foo") 成立

983
00:40:41,063 --> 00:40:42,863
then we'll do what we want.
那么我们就处理相关的事件

984
00:40:42,865 --> 00:40:44,464
Otherwise, we couldn't find it.
不成立，不能创建图片

985
00:40:44,466 --> 00:40:46,232
So, we'll do whatever we do in that case.
这种情况下我们做点什么

986
00:40:46,234 --> 00:40:47,500
Okay?
是吗？

987
00:40:47,502 --> 00:40:48,734
So watch out for those.
所以，多注意这些细节

988
00:40:48,736 --> 00:40:51,670
There's a few of them, a few dozen at the most.
这种情况非常少，最多不过十几种

989
00:40:51,672 --> 00:40:52,937
Yeah.
说你的问题

990
00:40:52,939 --> 00:40:55,206
So this is a replace like try-catch?
-（学生提问）

991
00:40:55,208 --> 00:40:58,642
So the question is does this replace try-catch?
-问题是：这是 try-catch 的一个取代吗？

992
00:40:58,644 --> 00:41:00,611
And we're not even going to talk about try-catch in
我们不打算谈论 try-catch

993
00:41:00,613 --> 00:41:01,979
this class.
在这门课

994
00:41:01,980 --> 00:41:03,346
Okay? That's how rare it is.
好吗？ try-catch 非常少见

995
00:41:03,349 --> 00:41:06,816
You don't even really use try-catch in Swift.
甚至在 Swift 中也很少用到它

996
00:41:06,818 --> 00:41:10,353
You know, things are Optionals make a lot of try-catch stuff
Optional 让

997
00:41:10,355 --> 00:41:11,654
just not necessary.
try-catch 变得不是必须的

998
00:41:11,656 --> 00:41:13,422
try-catch, for
对于那些不知道什么是 try-catch 的同学，

999
00:41:13,423 --> 00:41:15,189
those of you who don't know, is you can raise exceptions in
try-catch 是你的程序引发异常时

1000
00:41:15,192 --> 00:41:17,926
your program and they can percolate up the callstack and
它们会遍历调用堆栈并且

1001
00:41:17,928 --> 00:41:20,161
someone tries to catch them and handle them.
查找处理此类异常的 catch 语句

1002
00:41:20,163 --> 00:41:22,013
Okay?
明白了吗？

1003
00:41:22,014 --> 00:41:23,864
And that programming methodology is not one
这种编程方法并不是

1004
00:41:23,867 --> 00:41:27,501
that's really something that we use much in iOS.
iOS 开发中常用的一种方法

1005
00:41:27,503 --> 00:41:28,635
Okay? In Objective-C,
明白了吗？在 Objective-C 中

1006
00:41:28,637 --> 00:41:30,537
maybe it was used even a little more.
这种方法可能只会用了一点点

1007
00:41:30,539 --> 00:41:32,171
I'm not even sure about that but
对此我不是很确定但是

1008
00:41:32,173 --> 00:41:34,674
certainly in Swift we're not gonna be using that.
在 Swift 中，我们肯定不会使用它

1009
00:41:34,676 --> 00:41:36,442
I'm not, I'm not even gonna show it to your in this class.
在本课程的范围内，我甚至不会演示给你们怎么使用它

1010
00:41:36,444 --> 00:41:40,679
That's how unneed, unnecessary it is to know that.
不需要了解

1011
00:41:40,681 --> 00:41:41,979
Okay.
好的

1012
00:41:41,981 --> 00:41:44,782
So let's talk about creating objects,
让我们来讲一下如何创建对象

1013
00:41:44,784 --> 00:41:47,718
then you know to do it by putting the type and
创建一个对象的语法是，你在想要创建的类型之后

1014
00:41:47,720 --> 00:41:52,022
then parentheses and then the arguments to the initializer.
加上一对括号，括号内是初始化方法的参数

1015
00:41:52,024 --> 00:41:53,457
Okay.

1016
00:41:53,458 --> 00:41:54,891
It's completely obvious there.
这里写的很清楚

1017
00:41:54,893 --> 00:41:58,561
You notice you don't always create objects by doing that.
你可能会发现你并不总是通过这种方式来创建对象

1018
00:41:58,563 --> 00:42:01,196
Sometimes, you will ask a class method or
有时候你会使用一个类方法或者

1019
00:42:01,198 --> 00:42:02,931
a type method to do it.
类型方法去创建一个对象

1020
00:42:02,933 --> 00:42:04,632
So here's one, buttonWithType.
这里就是一个例子，.buttonWithType

1021
00:42:04,634 --> 00:42:07,802
You see that's being sent UIButton, the type.
你看到这个消息被发送给了 UIButton，一种类型

1022
00:42:07,804 --> 00:42:09,236
All right. It's not being sent to
消息并没有发送给一个

1023
00:42:09,238 --> 00:42:11,238
a UIButton, it's being sent to the type,
UIButton 的对象，而是一个类型

1024
00:42:11,240 --> 00:42:12,639
like we talked about before.
我记得我们之前讲过

1025
00:42:12,641 --> 00:42:14,040
And so sometimes,
还有一种情况

1026
00:42:14,042 --> 00:42:16,976
you'll be creating things that way very rarely.
这种情况比较少见，需要你用另外一种方式创建对象

1027
00:42:16,978 --> 00:42:20,546
They really, Apple's been moving away from that model
甚至连 Apple 都已经将它们从 Model 中移除

1028
00:42:20,548 --> 00:42:24,049
and more towards just using initializers and creating
而转向于使用初始化方法

1029
00:42:24,051 --> 00:42:28,219
things but there, there's some that, that do that.
但是仍有部分的情况会使用到这种创建对象的方法

1030
00:42:28,221 --> 00:42:31,322
Like remember UIImage on the previous page,
还记得上一页中的 UIImage 吗？

1031
00:42:31,324 --> 00:42:34,025
that wasn't UIImage dot image named.
那个不是像 UIImage.imageNamed: 这样的

1032
00:42:34,027 --> 00:42:37,094
That's kind of how it used to be in Apple, now it's UIImage
以前 Apple 就用那种创建对象的方法，但是现在用

1033
00:42:37,096 --> 00:42:39,996
parentheses whatever, called a constructor.
UIImage().xxx，这个叫做 constructor

1034
00:42:39,998 --> 00:42:43,733
Sometimes other objects will obviously create
有些时候其他对象会为你

1035
00:42:43,735 --> 00:42:45,034
objects for you.
创建一些对象

1036
00:42:45,036 --> 00:42:49,137
So like here's a really cool method in String called join.
例如在 String 中有一个非常酷的方法叫 join

1037
00:42:49,139 --> 00:42:51,856
Okay?

1038
00:42:51,857 --> 00:42:54,574
Join takes an Array of Strings and it will separate them by
Join 接受一个由字符串组成的数组并

1039
00:42:54,577 --> 00:42:57,545
whatever String you send join to.
用接收 join 消息的字符串把这个数组分离开

1040
00:42:57,547 --> 00:43:00,447
So comma.join up in Array will give you a comma
所以，",".join(myArray) 会返回给你一个

1041
00:43:00,449 --> 00:43:03,316
separated String, a String with the things,
由逗号分隔的字符串，就是说这个字符串

1042
00:43:03,318 --> 00:43:05,685
in the Array comma separated.
中间有一个逗号把前后分为两段

1043
00:43:05,687 --> 00:43:08,388
And that's obviously creating a new Array (shoule be String).
这明显是创建了一个新数组

1044
00:43:08,390 --> 00:43:10,489
So this, this is kind of completely obvious.
这确实很明显

1045
00:43:10,491 --> 00:43:13,325
But yes, some methods return objects to you that
是的，一些方法会返回

1046
00:43:13,327 --> 00:43:14,593
are created.
创建出来的对象给你

1047
00:43:14,595 --> 00:43:16,478
okay.


1048
00:43:16,479 --> 00:43:18,362
So let's talk now about AnyObject,
让我们讲一下 AnyObject

1049
00:43:18,365 --> 00:43:20,832
this was brought up earlier.
这个在之前涉及过

1050
00:43:20,834 --> 00:43:24,201
AnyObject is kind of okay.
AnyObject 是某种

1051
00:43:24,203 --> 00:43:26,103
For the purposes of what you know so
为了方便理解

1052
00:43:26,105 --> 00:43:28,005
far, you can think of it as a type.
你可以认为它是一种类型

1053
00:43:28,007 --> 00:43:30,273
Okay? It's not really a type, but
明白了吗？但是事实上，这并不是一种类型

1054
00:43:30,275 --> 00:43:33,476
you can think of it as type, like Double or
但是你可以认为它是一种类型，就像 Double

1055
00:43:33,478 --> 00:43:35,277
Array or whatever.
或者 Array 等等

1056
00:43:35,279 --> 00:43:37,079
And it's used primarily for
AnyObject 主要用于

1057
00:43:37,081 --> 00:43:40,749
compatibility with existing Objective-C APIs and iOS.
兼容现有 Objective-C API 和 iOS 代码

1058
00:43:40,751 --> 00:43:42,584
Okay. You're really not gonna use
你并不会经常使用

1059
00:43:42,586 --> 00:43:45,820
AnyObject to build your own data structures very much.
AnyObject 来构建你自己的数据结构

1060
00:43:45,822 --> 00:43:47,689
I suppose you could, but
你可以这样做

1061
00:43:47,690 --> 00:43:49,557
it'd be kind of, it'd be, again, kind of anti-Swift.
但是，这有一点点，不像 Swift 风格的做法

1062
00:43:49,559 --> 00:43:54,161
Swift is very much into strong typing and type inference and
Swift 是强类型语言，并有类型推断的特性

1063
00:43:54,163 --> 00:43:55,929
all that.
的那种语言

1064
00:43:55,930 --> 00:43:57,696
So you could, but I'm only gonna talk about it in the
当然你可以这么做，但是我只会在兼容性的问题上

1065
00:43:57,699 --> 00:44:00,566
context here of using it here as this compatibility thing.
讲到 AnyObject 的问题

1066
00:44:00,568 --> 00:44:01,167
All right?
明白了吗？

1067
00:44:01,169 --> 00:44:04,837
So what is AnyObject?
什么是 AnyObject？

1068
00:44:04,839 --> 00:44:06,672
Okay? And where will you see it?
还有，我们会在哪里用到它？

1069
00:44:06,674 --> 00:44:10,742
So AnyObject, means a pointer to an object.
AnyObject 的意思是，指向一个对象的指针

1070
00:44:10,744 --> 00:44:12,476
Meaning, an instance of a class.
也就是说，一个类的实例

1071
00:44:12,478 --> 00:44:13,310
Okay? That you
明白吗？

1072
00:44:13,312 --> 00:44:14,978
don't know what the class is.
只是你不知道它的类是什么

1073
00:44:14,980 --> 00:44:18,848
So it's just kind of pointer to unknown class.
所以它是指向一个未知类的指针

1074
00:44:18,850 --> 00:44:20,016
Okay? Which it seems kind of
有问题吗？这可能听上去

1075
00:44:20,018 --> 00:44:21,617
weird and it is kind of weird.
有些奇怪，确实它有些奇怪

1076
00:44:21,619 --> 00:44:24,786
And you, so we gonna have to play around to be able to
你们会考虑，我们到底会在什么情况下使用到它

1077
00:44:24,788 --> 00:44:26,921
use it but that's what it is.
但这里我想告诉你们的是，它是什么

1078
00:44:26,923 --> 00:44:29,524
And where will you see this in iOS?
在 iOS 开发中，哪里能看到它呢？

1079
00:44:29,526 --> 00:44:32,360
Sometimes, you'll see properties that are in
有些时候你会看到某些属性的类型是 AnyObject 的

1080
00:44:32,362 --> 00:44:36,430
AnyObject, like there's a property on storyboard segues
例如我们下周会讲到的

1081
00:44:36,432 --> 00:44:38,932
which we're gonna talk about next week.
在 Storyboard Segues 的一个属性

1082
00:44:38,934 --> 00:44:41,401
Called destinationViewController,
这个属性叫 destinationViewController

1083
00:44:41,403 --> 00:44:44,403
instead of being a UIViewController (which) is a type,
它不是以 UIViewController 作为它的类型

1084
00:44:44,405 --> 00:44:45,604
it's AnyObject.
而是 AnyObject

1085
00:44:45,606 --> 00:44:47,572
Okay, for historical reasons really.
这是某些历史遗留问题造成的

1086
00:44:47,574 --> 00:44:50,842
And similarly, in UIViewController,
类似的，在 UIViewController 中

1087
00:44:50,844 --> 00:44:53,978
there is a property called toolbarItems and
有一个叫 toolbarItems 的属性

1088
00:44:53,980 --> 00:44:57,148
it would return to an Array of the AnyObject.
它会返回一个由 AnyObject 组成的数组

1089
00:44:57,150 --> 00:44:59,083
Okay?


1090
00:44:59,084 --> 00:45:01,017
So basically, these properties are giving you back things you
基本上，这些属性返回给你一些

1091
00:45:01,020 --> 00:45:02,552
don't even know what they are.
你都不知道是什么类型的东西

1092
00:45:03,989 --> 00:45:05,421
Kay?


1093
00:45:05,423 --> 00:45:07,623
You'll also see them as arguments to functions.
还有，你会在函数的参数中见到 AnyObject

1094
00:45:07,625 --> 00:45:09,625
Like here is
类似在这里一样

1095
00:45:09,626 --> 00:45:11,626
a UIViewController method prepare for segue.
一个 UIViewController 的方法 prepareForSegue

1096
00:45:11,629 --> 00:45:13,462
It takes a normal argument there, segue, but
它接受一个普通的参数，segue，但是它还接受一个

1097
00:45:13,464 --> 00:45:16,364
then it also takes a sender, which can be AnyObject.
sender 参数，这个参数的类型是 AnyObject 的

1098
00:45:17,834 --> 00:45:19,366
Now in that case, it kinda makes sense because it
在这个情况下，AnyObject 的说法更有道理

1099
00:45:19,368 --> 00:45:21,068
really could be AnyObject in that case,
因为 Sender 确实可以是任意对象

1100
00:45:21,070 --> 00:45:23,703
cuz whatever's causing the segue to happen in a user
因为无论什么导致 UI 中 Segue 发生的东西

1101
00:45:23,705 --> 00:45:27,006
interface, could be AnyObject, so it makes some sense.
都可以是任意对象，所以这么就说通了

1102
00:45:27,008 --> 00:45:30,276
But there's addConstraints, kay?
但这里是 addConstraints

1103
00:45:30,278 --> 00:45:32,311
Which is another UIViewController thing.
也是一种跟 UIViewController 类似的东西

1104
00:45:32,313 --> 00:45:34,746
And you add the constraints, you think that would be
如果你加了 constraints，你可以认为

1105
00:45:34,748 --> 00:45:36,715
Array of whatever class constraints are,
那是一个 constraints 的 Array，不管 constraints 是什么类型

1106
00:45:36,717 --> 00:45:38,483
I haven't taught you about this, but
我还没有教你们这些

1107
00:45:38,485 --> 00:45:41,285
these are the constraints that do all our UI shifting.
这些 constraints 都是用来控制 UI 的移位

1108
00:45:41,287 --> 00:45:44,455
But again, for historical reasons, it's an Array of
但是，由于历史遗留问题

1109
00:45:44,457 --> 00:45:47,290
AnyObject and even in a appendDigit in calculator.
这是一个任意对象的 Array ，甚至是计算器里的 appendDigit

1110
00:45:47,292 --> 00:45:51,294
Okay, remember, when we drag, control, dragged the button to
记住，当我按住 control

1111
00:45:51,296 --> 00:45:54,430
make a appendDigit, and I made a big deal of of saying,
拖动按钮去生成一个 appendDigit 的，我们其实是在说

1112
00:45:54,432 --> 00:45:57,433
change that from AnyObject to UI button, okay?
把那个任意对象变成一个 UI Button

1113
00:45:57,435 --> 00:46:01,070
Well, if you hadn't changed it, then you could've ended up
如果你还没改变这个，你最后可能会得到

1114
00:46:01,072 --> 00:46:03,305
with a appendDigit, sender AnyObject.
一个 appendDigit(sender: AnyObject)

1115
00:46:03,307 --> 00:46:03,872
Kay?


1116
00:46:05,442 --> 00:46:08,142
It also can even be the return type for fun, for functions,
这甚至可以作为函数返回对象

1117
00:46:08,144 --> 00:46:10,577
like that buttonWithType I talked about a few slides ago?
就像是前几张幻灯片中我说过的那个 buttonWithType 函数

1118
00:46:10,579 --> 00:46:12,112
It actually returns AnyObject,
它其实返回 AnyObject

1119
00:46:12,114 --> 00:46:14,948
it doesn't return a UI button, you would think it would, but
这不会返回一个 UI Button，你可能想这会返回这样一个类型

1120
00:46:14,950 --> 00:46:16,916
it doesn't, it returns AnyObject.
但其实不会，他会返回 AnyObject

1121
00:46:16,918 --> 00:46:18,684
Okay, so, this,
就是这样

1122
00:46:18,686 --> 00:46:20,519
you're probably like what the heck is going on.
你可能会想这是怎么了

1123
00:46:20,521 --> 00:46:22,688
Why would you be passing around these pointers if
为什么你要传递这些

1124
00:46:22,690 --> 00:46:24,989
you don't even know what these things are, okay?
甚至你不知道这些是什么的指针呢？

1125
00:46:24,991 --> 00:46:28,426
Well we'll talk a little bit why we do it but
我们稍后会讨论一下为什么这么做

1126
00:46:28,428 --> 00:46:32,163
let's talk first about how we use it, because it's this
但先来说说我们怎么用这个，因为这是一个指向未知对象的指针

1127
00:46:32,165 --> 00:46:35,766
pointer to unknown object, so I can't really send any
所有我不能发送任何信息给它

1128
00:46:35,768 --> 00:46:40,136
messages to it because I don't even know what it is, okay?
因为我甚至不知道这是什么

1129
00:46:40,138 --> 00:46:45,474
And so to use it, we convert it to a type we do know, kay?
为了使用它，我们把它转换成一种我们知道的类型

1130
00:46:45,476 --> 00:46:49,044
That's the only way we're really gonna use AnyObject,
我们唯一的使用 AnyObject 的方式

1131
00:46:49,046 --> 00:46:52,547
is to invert it to some class that we do know, all right?
就是把它转换成我们知道的类

1132
00:46:52,549 --> 00:46:55,283
And we do that with.
我们通过

1133
00:46:56,319 --> 00:46:59,787
By creating a new variable, so we, we've got some AnyObject,
建立一个新的变量来做这件事。比如，我们有一些 AnyObject

1134
00:46:59,789 --> 00:47:01,989
it's a, it was an argument to a method, or
是一个方法的参数

1135
00:47:01,991 --> 00:47:03,557
it's a local variable or
或者是一个本地变量

1136
00:47:03,559 --> 00:47:05,959
something like that, and we wanna convert it.
诸如此类，我们想把它转换掉

1137
00:47:05,961 --> 00:47:08,661
So, we're gonna create a new variable of the,
所以我们可以建立一个新的变量

1138
00:47:08,663 --> 00:47:11,163
of the type we wanna convert it to, okay?
新变量的类型就是我们想要转换到的类型

1139
00:47:11,165 --> 00:47:13,832
And we're gonna assign this new variable to be
然后我们要把这个变量声明成

1140
00:47:13,834 --> 00:47:17,269
equal to that AnyObject thing converted.
“变量 = AnyObject 转换后的东西”

1141
00:47:17,271 --> 00:47:18,704
Now, of course,
接着

1142
00:47:18,705 --> 00:47:20,138
we have to convert it to a compatible type.
我们需要转换成一个合适的类型

1143
00:47:20,140 --> 00:47:21,539
It actually has,
实际上，它也

1144
00:47:21,540 --> 00:47:22,939
has to actually be one of those things.
必须是那种类型

1145
00:47:22,942 --> 00:47:26,344
So, if we got a UIButton back from buttonWithType and
所以如果我们从 buttonWithType 中取回了 UIButton

1146
00:47:26,346 --> 00:47:27,711
it comes back as AnyObject,
其实返回了 AnyObject

1147
00:47:27,713 --> 00:47:30,881
we can convert it to UIButton, cuz it is a UIButton.
你可以把它转换成 UIButton，因为他真的是个 UIButton

1148
00:47:30,883 --> 00:47:32,666
Kay?


1149
00:47:32,667 --> 00:47:34,450
But we can't convert it to a UILabel, it's not a UILabel, so
但是不能转换成 UILabel，因为他不是个 UILabel

1150
00:47:34,453 --> 00:47:36,953
that would crash our program actually.
这会让你的程序崩溃

1151
00:47:36,955 --> 00:47:39,055
So, how do we do that conversion?
那我们怎么去做这个转换呢？

1152
00:47:40,524 --> 00:47:42,758
yeah, see, it will crash our program if we do that.
看到没，这会让我们的程序崩溃

1153
00:47:42,760 --> 00:47:44,392
How do we do that conversion safely so
如何安全地去做这个转型

1154
00:47:44,394 --> 00:47:46,394
we're not crashing our program all the time?
才不会让我们的程序一直崩溃呢？

1155
00:47:46,396 --> 00:47:50,531
So, there's two ways, and we call this casting, kay?
这里有两种方式，我们叫它转换

1156
00:47:50,533 --> 00:47:53,067
You know what typecasting is, we're essentially casting
你知道类型转换是什么，我们

1157
00:47:53,069 --> 00:47:55,068
the type from AnyObject to something else.
本质上是把一个类型从任意类型转换成其他的

1158
00:47:56,004 --> 00:48:00,439
And we can typecast forcibly using the as keyword.
我们还可以用 as 关键词强行转换

1159
00:48:00,441 --> 00:48:01,840
A S, as.
用 as

1160
00:48:01,842 --> 00:48:04,343
Okay Swift as usual, very succinct.
通常 Swift 是非常简洁的

1161
00:48:04,345 --> 00:48:06,811
And so I'm gonna use that destination view
下面我要用 destinationViewController

1162
00:48:06,813 --> 00:48:08,813
controller thing as an example so
来做个例子

1163
00:48:08,815 --> 00:48:12,283
I've got this property destinationViewController.
我得到了这个 destinationViewController 作为属性

1164
00:48:12,285 --> 00:48:14,051
It's in AnyObject.
这是个 AnyObject

1165
00:48:14,053 --> 00:48:16,620
And, I know it's a ViewController.
我知道这是个 ViewController

1166
00:48:16,622 --> 00:48:20,223
And I think it should be a CalculatorViewController.
我想这应该是个 CalculatorViewController

1167
00:48:20,225 --> 00:48:21,491
So, I'm gonna be using in my
我要在我的

1168
00:48:21,493 --> 00:48:23,559
examples CalculatorViewController.
CalculatorViewController 里面用

1169
00:48:23,561 --> 00:48:25,761
Imagine we had called our CalculatorViewController,
先想象一下我们调用 CalculatorViewController

1170
00:48:25,763 --> 00:48:28,864
CalculatorViewController instead of ViewController.
是 CalculatorViewController 而不是 ViewController

1171
00:48:28,866 --> 00:48:30,432
I'm doing that in examples because it,
我因为这个才用在我的例子里

1172
00:48:30,434 --> 00:48:32,000
it's just going to make more sense, okay?
这样能让你们更好理解

1173
00:48:32,002 --> 00:48:35,269
So, I want to talk to this destinationViewController,
所以我想说说这个 destinationViewController

1174
00:48:35,271 --> 00:48:37,037
which is AnyObject.
这是个 AnyObject

1175
00:48:37,039 --> 00:48:39,473
And I know that it's a CalculatorViewController.
同时我又知道这是个 CalculatorViewController

1176
00:48:39,475 --> 00:48:41,474
And if it's not a CalculatorViewController,
如果这个不是个 CalculatorViewController

1177
00:48:41,476 --> 00:48:43,209
my program should probably crash.
这个程序就应该会崩溃

1178
00:48:43,211 --> 00:48:45,177
Because, in the context I'm using it,
因为在使用它的情景下

1179
00:48:45,179 --> 00:48:46,679
I want it to be that.
我需要它是 CalculatorViewController

1180
00:48:46,681 --> 00:48:48,397
Okay?


1181
00:48:48,398 --> 00:48:50,114
So, I can just say, let calcVC equals
所以可以写 let calcVC ＝

1182
00:48:50,117 --> 00:48:52,484
DestinationViewController as CalculatorViewController.
destinationViewController as CalculatorViewController

1183
00:48:52,486 --> 00:48:56,821
And now, calcVC, this new constant, its type is
现在，calcVC 这个常量的类型

1184
00:48:56,823 --> 00:48:59,990
not AnyObject, its type is CalculatorViewController.
不是 AnyObject，而是 CalculatorViewController

1185
00:48:59,992 --> 00:49:02,159
And so now, I've gotten hold of that AnyObject in
所以现在我可以这种方法处理好了 AnyObject

1186
00:49:02,161 --> 00:49:03,626
a way that I can actually do things with it,
之后就可以针对它做事情了

1187
00:49:03,628 --> 00:49:04,761
and I can send messages,
也可以发送消息

1188
00:49:04,763 --> 00:49:07,696
CalculatorViewControl messages, to calcVC.
CalculatorViewControl 消息给 calcVC.

1189
00:49:08,999 --> 00:49:10,899
Now, you can protect against crashing if
现在如果你想防止崩溃

1190
00:49:10,901 --> 00:49:13,801
you're not sure whether that destinationViewController is
但你不确定 destinationViewController 是不是

1191
00:49:13,803 --> 00:49:16,771
a CalculatorViewController, but you're hoping it is.
一个 CalculatorViewController，但你希望是

1192
00:49:16,773 --> 00:49:18,272
Okay?


1193
00:49:18,273 --> 00:49:19,772
You can use as question mark.
你可以用 as 加问号

1194
00:49:19,775 --> 00:49:22,909
And as question mark returns an Optional.
as? 会返回一个可选的

1195
00:49:22,911 --> 00:49:26,879
Same as as, right, as returns that AnyObject thing cast to
跟 as 一样，as 返回 AnyObject 转换成

1196
00:49:26,881 --> 00:49:28,414
be a different class.
其他类之后的对象

1197
00:49:28,416 --> 00:49:30,983
As question mark does the same thing, but it's Optional
问号做了同样的事，但是返回的是 Optional 版本

1198
00:49:30,985 --> 00:49:33,585
version of that, so we can return nil if that AnyObject,
如果类型为 AnyObject 的 destinationViewController

1199
00:49:33,587 --> 00:49:35,387
destinationViewController cannot be
不能转换成 CalculatorViewController

1200
00:49:35,389 --> 00:49:37,388
turned into a CalculatorViewController,
那就返回 nil

1201
00:49:37,390 --> 00:49:39,757
because it's not a CalculatorViewController some
因为它不是 CalculatorViewController，而是其他的

1202
00:49:39,759 --> 00:49:41,992
other kinda ViewController or something else.
ViewController 或者其他的（类）

1203
00:49:41,994 --> 00:49:42,726
All right?

1204
00:49:42,728 --> 00:49:44,745
And so you can say,
所以，你可以说，

1205
00:49:44,746 --> 00:49:46,763
if let calcVC equals destinationViewController as
if let calcVC = destinationViewController as

1206
00:49:46,765 --> 00:49:48,131
CalculatorViewController, and
CalculatorViewController， 然后

1207
00:49:48,133 --> 00:49:51,067
then inside there, you've got calcVC set.
在那里面，你就给 calcVC 赋值了

1208
00:49:51,069 --> 00:49:53,502
And it's, you know that it's a CalculatorViewController.
你知道它是一个 CalculatorViewController

1209
00:49:53,504 --> 00:49:57,205
And AnyObject is now in your past, okay?
AnyObject 也就成了过去式了

1210
00:49:58,975 --> 00:50:00,174
Make sense? So, we have as and
理解吗？好了，我们学了 as 和

1211
00:50:00,176 --> 00:50:01,675
as question mark.
as?

1212
00:50:01,677 --> 00:50:05,512
You can also check beforehand if you just wanna see, is this
如果你愿意，你也可以事先检查下，这是不是一个

1213
00:50:05,514 --> 00:50:08,748
a CalculatorViewController, you can say is.
CalculatorViewController

1214
00:50:08,750 --> 00:50:10,750
So, you can say if destinationViewController is
你可以写

1215
00:50:10,752 --> 00:50:13,252
a calculation view... CalculatorViewController,
if destinationViewController is CalculatorViewController，

1216
00:50:13,254 --> 00:50:16,422
then I'll go ahead and, then I can do the as, for example.
那么我就继续，然后我就可以进行 as（转换）

1217
00:50:16,424 --> 00:50:20,358
But usually we use the as question mark, you know,
但通常地，我们使用 as?

1218
00:50:20,360 --> 00:50:23,194
check it and convert it all in one go.
做检查并且转换，一次搞定

1219
00:50:23,196 --> 00:50:25,013
Okay?

1220
00:50:25,014 --> 00:50:26,831
So that's how we're gonna use an AnyObject.
这就是我们怎么使用 AnyObject

1221
00:50:26,833 --> 00:50:30,434
We're gonna have to cast it with as into something else.
我们必须将它转化成其他东西

1222
00:50:30,436 --> 00:50:32,936
Question?
有问题吗？

1223
00:50:32,937 --> 00:50:35,437
Is there a way to check if it's not it
（学生提问）

1224
00:50:35,440 --> 00:50:37,473
doesn't ?
（学生提问）

1225
00:50:37,475 --> 00:50:39,041
Yeah. So the question is,
所以，问题是，

1226
00:50:39,043 --> 00:50:41,977
is there a way to kind of ask it what the type is and
有没有这样一种方式，可以先检察这个类是什么类型，

1227
00:50:41,979 --> 00:50:44,079
get the answer back in some way?
然后通过某种方式得到结果

1228
00:50:44,081 --> 00:50:47,448
And, the answer is, for the purposes of where you are, no.
答案是，就你所提的这个问题，不能

1229
00:50:47,450 --> 00:50:48,883
Okay? You don't do that.
你不能那样做

1230
00:50:48,885 --> 00:50:50,317
You, you, you ask it for
你想要知道

1231
00:50:50,319 --> 00:50:52,919
certain, whether it can be a certain thing.
它是否是一个确定的东西

1232
00:50:52,921 --> 00:50:54,587
You don't ask it, what are you?
你不能问，你是什么？

1233
00:50:54,589 --> 00:50:55,988
And then try and figure it out from there.
然后试图知道它是什么

1234
00:50:55,990 --> 00:50:57,589
Just, that's, we're not gonna use that paradigm.
因此，我们不能使用那样的模式

1235
00:50:59,827 --> 00:51:00,792
Okay?

1236
00:51:00,794 --> 00:51:03,728
Let's talk about Arrays of AnyObject.
让我们说说包含 AnyObject 的 Array

1237
00:51:03,730 --> 00:51:05,996
Cuz sometimes you're gonna get an Array of AnyObject back,
有时你会得到一个 AnyObject 的 Array

1238
00:51:05,998 --> 00:51:08,766
like that constraints one I was talking about.
就像我刚刚提到的 constraints

1239
00:51:08,768 --> 00:51:10,967
Where it's going to be an Array of constraints that
它可能是一个 AnyObject 类型 constraints 的 Array (译注：[AnyObject])

1240
00:51:10,969 --> 00:51:13,536
are going to be AnyObject, but I know they're going to be in
但我知道它们在这个

1241
00:51:13,538 --> 00:51:16,539
this layout constraint, but they're going to be an Array.
布局约束中，但它们是一个 Array

1242
00:51:16,541 --> 00:51:18,491
So, you can do
所以，你可以在转换它们

1243
00:51:18,492 --> 00:51:20,442
some interesting things with casting there.
时做些有趣的事情

1244
00:51:20,445 --> 00:51:23,045
So, let's use the toolbarItems one,
让我们以 toolbarItems 为例，

1245
00:51:23,047 --> 00:51:26,048
so that toolbarItems it's a, that's a property on
toolbarItems 是 UIViewController 的

1246
00:51:26,050 --> 00:51:29,184
UIViewController and it returns an Array that's gonna
一个属性，它返回一个 UIBarButtonItem 的

1247
00:51:29,186 --> 00:51:31,519
have UIBarButtonItem in it.
 Array

1248
00:51:31,521 --> 00:51:35,122
But, for historical reasons it returns the square bracket
但，由于历史原因，它返回

1249
00:51:35,124 --> 00:51:36,556
of AnyObject.
[AnyObject]

1250
00:51:36,558 --> 00:51:37,957
So, I can say for
所以，我可以说，

1251
00:51:37,959 --> 00:51:41,994
item in toolbarItems, then item is gonna be in AnyObject.
在 toolbarItems 中，item 会是 AnyObject

1252
00:51:41,996 --> 00:51:44,697
So, I'm enumerating those AnyObject.
所以，我遍历这些 AnyObject

1253
00:51:44,699 --> 00:51:47,499
And I'm actually having my variable item be AnyObject,
这些变量也确实是 AnyObject，

1254
00:51:47,501 --> 00:51:48,967
but then inside I'm saying,
但在里面，我判断，

1255
00:51:48,969 --> 00:51:51,736
if I can let the toolbarItem equal, you know,
如果我能 let toolbarItem =

1256
00:51:51,738 --> 00:51:55,172
be a UIBarButtonItem, then I'm good to go.
UIBarButtonItem，我就可以继续了

1257
00:51:55,174 --> 00:51:57,908
So, you see how I'm enumerating this Array of
我是这样遍历这个

1258
00:51:57,910 --> 00:51:58,842
AnyObject.
AnyObject 的 Array

1259
00:51:58,844 --> 00:52:00,611
Then the objects, and
然后这些 object，

1260
00:52:00,612 --> 00:52:02,379
then inside I'm doing the as question mark.
在里面我使用 as?

1261
00:52:02,381 --> 00:52:04,113
But I can do it another way to.
但我也可以使用其他方式，

1262
00:52:04,115 --> 00:52:05,815
Kay? Which is I can say, for
我可以使用 for

1263
00:52:05,817 --> 00:52:09,885
toolbarItem in toolbarItems as an Array of UIBarButtonItem.
toolbarItem in toolbarItems as [UIBarButtonItem]

1264
00:52:09,887 --> 00:52:12,454
Another words, I can cast the entire Array.
换句话说，我可以转换整个 Array ，

1265
00:52:12,456 --> 00:52:14,288
If I know that that Array of AnyObjects is
如果我确认这整个的 AnyObject 的 Array 是个

1266
00:52:14,290 --> 00:52:17,825
really an Array of UIBarButtonItem, I can just cast it.
UIBarButtonItem 的 Array  我就能转化它

1267
00:52:17,827 --> 00:52:20,561
Now this one, you can't do question mark, because it
现在这个，你不能使用问号，因为

1268
00:52:20,563 --> 00:52:24,197
wouldn't make sense to say for toolbarItem in nil, okay?
for toolbarItem in nil 是没有意义的

1269
00:52:24,199 --> 00:52:25,732
So, that makes no sense.
没有意义

1270
00:52:25,734 --> 00:52:28,017
So, you can't here,
你不能在这里，

1271
00:52:28,018 --> 00:52:30,301
you better be darn sure that that Array has what you want.
你最好确认那个 Array 是你想要的

1272
00:52:30,304 --> 00:52:32,838
But then inside, now toolbarItem is a tool,
但这里面，toolbarItem 是一个

1273
00:52:32,840 --> 00:52:36,008
UIBarButtonItem, cuz I've casted the whole Array from
UIBarButtonItem，因为我已经转换了整个 Array ，从 [AnyObject]

1274
00:52:36,010 --> 00:52:38,810
Array of AnyObject to Array of UIBarButtonItem.
转换到 [UIBarButtonItem]

1275
00:52:38,812 --> 00:52:42,380
You understand the difference there between those two?
你们明白这两个的不同吗？

1276
00:52:42,382 --> 00:52:46,350
Okay another example of AnyObject and
另一个出现

1277
00:52:46,352 --> 00:52:48,085
where it appears.
AnyObject 的例子

1278
00:52:48,087 --> 00:52:51,054
So, if we hadn't changed, when we control drag to
当我们 control 拖建一个

1279
00:52:51,056 --> 00:52:54,123
make a appendDigit, what if we had left at AnyObject?
appendDigit，如果我们保留 AnyObject 会怎样？

1280
00:52:55,259 --> 00:52:56,775
Kay? So we had
所以我们有一个

1281
00:52:56,776 --> 00:52:58,292
a appendDigit sender colon AnyObject.
appendDigit(sender: AnyObject)

1282
00:52:58,295 --> 00:52:59,794
How could we have dealt with that?
我们怎么处理这个呢？

1283
00:52:59,796 --> 00:53:01,996
Well, we just would've said,
好吧，我们刚才说的，

1284
00:53:01,998 --> 00:53:05,166
if we can let the sendingButton equal sender as
如果我们能够 let sendingButton = sender as UIButton

1285
00:53:05,168 --> 00:53:08,502
a UIButton, then do what we do, let digit equals
那么，做我们该做的，let digit ＝

1286
00:53:08,504 --> 00:53:12,072
sendingButton.currenTitle exclamation point,
sendingButton.currenTitle!

1287
00:53:12,074 --> 00:53:14,507
et cetera, et cetera, et cetera.
等等

1288
00:53:14,509 --> 00:53:15,775
Make sense?
有道理吧？

1289
00:53:15,776 --> 00:53:17,042
But we didn't want to put that extra if let and
但是我们不想使用这个额外的 if let，

1290
00:53:17,045 --> 00:53:18,844
I hadn't talked to you about as, so
我还没有跟你们讲 as，

1291
00:53:18,846 --> 00:53:22,014
that's why I said be sure to put that thing UIButton.
这是为什么我说要确保这个东西是 UIButton

1292
00:53:22,016 --> 00:53:22,581
All right?

1293
00:53:24,451 --> 00:53:27,485
Now you might ask, why is that even in AnyObject?
现在你们可能会问，为什么会有 AnyObject？

1294
00:53:27,487 --> 00:53:30,454
When I control dragged, why did he just put UIButton?
当我们 control 拖拽时， 为什么不只提供给我们 UIButton？

1295
00:53:30,456 --> 00:53:32,456
Why did it even offer AnyObject?
为什么它甚至提供了 AnyObject？

1296
00:53:32,458 --> 00:53:35,525
Well, because you could have an action that is sent
因为你们可能有一个 action，这个 action 是

1297
00:53:35,527 --> 00:53:38,695
by two different kinds of UI elements.
两个不同的 UI 元素发起的

1298
00:53:38,697 --> 00:53:41,464
Maybe it's set by a Button and also by a Slider.
它可能是由 Button 和 Slider 发起的

1299
00:53:41,466 --> 00:53:43,099
I don't know what that would be,
我不知道它会是什么

1300
00:53:43,101 --> 00:53:44,900
I couldn't even think of an example of that.
我甚至举不出例子

1301
00:53:44,902 --> 00:53:47,803
But you possibly could, It's theoretically possible.
但是你可以这么做，理论上是可以的

1302
00:53:47,805 --> 00:53:49,671
And in that case the sender would be AnyObject.
在这种情况下 sender 就应该是 AnyObject

1303
00:53:49,673 --> 00:53:51,573
And you would have,
这样你就可以这么写，

1304
00:53:51,574 --> 00:53:53,474
say if the sender is a Slider then do one thing, else,
if sender 是一个 Slider 的时候，做某些事情，else if

1305
00:53:53,476 --> 00:53:56,110
if the sender is a Button, then do something else.
sender 是一个 Button 的时候，做别的事

1306
00:53:56,112 --> 00:53:57,544
And you would do that with as.
可以用 as 来实现

1307
00:53:58,547 --> 00:53:59,112
Okay?

1308
00:54:00,181 --> 00:54:01,581
So, the rea,

1309
00:54:01,582 --> 00:54:02,982
that's why I'm saying I think that default should not be
这就是为什么我觉得默认不应该是 AnyObject

1310
00:54:02,984 --> 00:54:05,551
AnyObject cuz that's a pretty rare case, where two
的原因，毕竟两个不同的 UI 元素发送同样 action 是

1311
00:54:05,553 --> 00:54:07,986
different kinds of UI elements are sending the same thing.
比较罕见的例子

1312
00:54:07,988 --> 00:54:11,222
So, why do the rare case, even though that's the more
所以我不太明白为什么要适应罕见的情况，如果是为了适用

1313
00:54:11,224 --> 00:54:13,925
generic or more general case, I agree.
于一些非常常见的例子的话，我会同意的

1314
00:54:13,927 --> 00:54:17,595
It still just seems kinda error prone to me, but anyway.
对我来说，这个非常容易犯错，但是无所谓了

1315
00:54:17,597 --> 00:54:20,597
So there's another a, AnyObject example.
上面就是 AnyObject 的另一个例子

1316
00:54:20,599 --> 00:54:22,766
So here's one more AnyObject thing.
这还有一个例子

1317
00:54:22,768 --> 00:54:24,668
Let's go back to that button thing.
再来看看这个 button

1318
00:54:24,670 --> 00:54:29,505
So I told you the buttonWithType returns AnyObject, kay?
我说过 buttonWithType 返回一个 AnyObject

1320
00:54:29,507 --> 00:54:33,109
And so if I got a button and I wanted to find out
那么如果我有一个按钮，我需要知道它

1321
00:54:33,111 --> 00:54:36,011
it's title or something like that, I have to cast it.
的标题或者其他东西，我就需要做类型转换

1322
00:54:36,013 --> 00:54:40,315
So, I would call UIBut, I would call that buttonWithType
这里我会调用 buttonWithType

1323
00:54:40,317 --> 00:54:43,685
and I can cast on the fly, right in line.
然后做一个直接的类型转换，就在调用这行

1324
00:54:43,687 --> 00:54:46,354
So, if I called that line green at the top,
如果我调用上边那行绿色代码，

1325
00:54:46,356 --> 00:54:49,289
then down here I could say the title of the button
在下边我就可以写

1326
00:54:49,291 --> 00:54:52,125
equals button as UIButton.currentTitle.
title = (button as UIButton).currentTitle

1327
00:54:52,127 --> 00:54:54,361
So, I'm just casting that AnyObject,
这样我就把上边那个按钮的 AnyObject

1328
00:54:54,363 --> 00:54:57,363
that button AnyObject up there, to be a UIButton, and
转换成一个 UIButton

1329
00:54:57,365 --> 00:54:58,864
then sending it a message.
并且发送一个消息

1330
00:54:58,866 --> 00:55:00,132
So, you can cast on the fly.
所以你是可以做这样一个直接的类型转换

1331
00:55:00,134 --> 00:55:03,101
Again, crasheroo if that button is not a button,
再说一次，如果这个按钮不是 UIButton，程序就崩溃了

1332
00:55:03,103 --> 00:55:04,102
but that's okay.
不过也可以

1333
00:55:04,104 --> 00:55:06,020
In this case,
在这个例子里，

1334
00:55:06,021 --> 00:55:07,937
button with type better darn well return a UIButton.
buttonWithType 我觉得最好还是直接返回 UIButton 比较好

1335
00:55:10,876 --> 00:55:15,279
Okay, now this casting business is not just for AnyObject.
继续，类型转换并不仅仅针对 AnyObject

1337
00:55:15,280 --> 00:55:17,180
You can actually cast any two objects.
你可以对任意两种不同的对象进行类型转换

1338
00:55:17,182 --> 00:55:20,416
For all non AnyObject case though, obviously those two
对于所有的非 AnyObject 对象，需要类型转换的两个对象

1339
00:55:20,418 --> 00:55:23,886
objects will have to be in the same inheritance hierarchy.
必须在一条继承链上

1340
00:55:23,888 --> 00:55:24,920
Right?

1341
00:55:24,922 --> 00:55:26,221
Can only cast down you know,
并且只能向下转换，

1342
00:55:26,223 --> 00:55:29,290
down cast into your own inherit this hierarchy.
沿着继承链向下转换

1343
00:55:29,292 --> 00:55:34,061
So, for example, if I had a local variable called vc
举个例子，如果我有一个 UIViewController

1344
00:55:34,063 --> 00:55:36,897
which was of type UIViewController, but I set it
类型的局部变量 vc， 但是我需要把它

1345
00:55:36,899 --> 00:55:40,600
to CalculatorViewController, okay?
设置成 CalculatorViewController

1346
00:55:40,602 --> 00:55:43,169
I couldn't say vc.enter(), right?
我不可以直接写 vc.enter()，

1347
00:55:43,171 --> 00:55:45,338
Enter is a method in our CalculatorViewController.
因为 enter() 是 CalculatorViewController 类的方法

1348
00:55:45,340 --> 00:55:49,474
I couldn't say vc.enter because vc is a UIViewController.
所以我不能写 vc.enter()，因为vc是一个 UIViewController

1350
00:55:49,476 --> 00:55:52,477
So as far as Swift knows, it doesn't respond to enter.
至少 Swift 是这么认为的，所以 vc 不会响应 enter 方法

1351
00:55:52,479 --> 00:55:55,079
Even though it is in fact, a CalculatorViewController,
尽管它事实上是一个 CalculatorViewController

1352
00:55:55,081 --> 00:55:57,715
from Swift's point of view, that local variable is not.
但是从 Swift 的角度看，它明显不是

1353
00:55:57,717 --> 00:55:59,350
It's a type UIViewController.
它是一个 UIViewController 对象

1354
00:55:59,352 --> 00:56:04,154
But I could cast it and say if I can let the calcVC equal vc
但是我可以做一个类型转换，新建一个常量 calcVC = vc

1355
00:56:04,156 --> 00:56:09,525
as a CalculatorViewController, now I can say vc.,.calcVC.enter.
as CalculatorViewController，现在就可以写 calcVC.enter()

1357
00:56:09,527 --> 00:56:10,826
Okay.

1358
00:56:10,828 --> 00:56:15,229
So you can cast, downcast through your inherit hierarchy as well.
所以说，向下转换是可以的

1360
00:56:17,333 --> 00:56:19,967
We rarely do that but, you might occasionally.
我们很少这么做，但是你也许以后偶尔会做

1361
00:56:19,969 --> 00:56:21,969
All right.

1362
00:56:21,970 --> 00:56:23,970
So let's zoom on here to every,
你们需要深入的

1363
00:56:23,973 --> 00:56:26,139
any questions about that whole AnyObject thing?
研究一下 AnyObject 的所有细节

1364
00:56:26,141 --> 00:56:27,540
When you see it in action,
当你在实际的项目中见到的时候，

1365
00:56:27,542 --> 00:56:29,475
it'll make a lot more sense, okay?
你就会更加透彻的理解了

1366
00:56:31,212 --> 00:56:33,296
okay. So now let's just
下面咱们看一些在

1367
00:56:33,297 --> 00:56:35,381
talk about some fun functions throughout all our classes.
所有我们见过的类里很有趣的函数

1368
00:56:35,383 --> 00:56:36,682
And we're gonna start with Array.
从 Array 开始

1369
00:56:37,751 --> 00:56:41,385
First of all that you know, you know that Array does plus equals.
你们应该知道 Array 可以用 += .

1371
00:56:41,387 --> 00:56:42,853
Can do, say Array plus equals.
Array +=

1372
00:56:42,855 --> 00:56:45,489
But the argument plus equals is another Array.
但是 += 的另外一个参数是另一个 Array

1373
00:56:46,591 --> 00:56:49,559
Okay, so if you just wanna add one thing to an Array using
所以，如果你想用 += 把一个东西加到 Array 里，

1374
00:56:49,561 --> 00:56:51,627
plus equals, you would have to put it in another Array.
你需要把它放到另一个 Array 里

1375
00:56:51,629 --> 00:56:54,329
Just square brackets, put the thing inside, okay?
就是把它放到方括号里

1376
00:56:54,331 --> 00:56:56,415
Some people get tripped up by this.
有一些人在这里犯错误

1377
00:56:56,416 --> 00:56:58,500
They do plus equals, you know, they have an Array of Ints,
比如他们有一个 Int 的 Array ，他们想用 += ，

1378
00:56:58,502 --> 00:57:01,269
and they say my Array of Ints plus equals an Int, and
他们会写我的 Array  += 一个 Int

1379
00:57:01,271 --> 00:57:02,637
they're like, oh, why doesn't it work?
然后他们就会纳闷为什么不行

1380
00:57:02,639 --> 00:57:07,141
It's because plus equal only adds whole Arrays to other Arrays.
这是因为 += 只能是一个 Array 加上另外一个 Array

1382
00:57:07,142 --> 00:57:08,575
It's an Array concatenater, okay?
这是一个 Array 的连接器

1383
00:57:11,246 --> 00:57:15,381
There's a couple of interesting variables,
Array 还有一些有趣的变量，

1384
00:57:15,383 --> 00:57:18,283
properties in Array first and last that will
first 和 last 会分别返回

1385
00:57:18,285 --> 00:57:20,719
return the first or last item in the Array.
Array 的第一个和最后一个元素

1386
00:57:20,721 --> 00:57:22,053
What's interesting about them is
它们有趣的地方是

1387
00:57:22,055 --> 00:57:23,721
that they return an Optional.
他们返回一个 Optional

1388
00:57:23,723 --> 00:57:25,990
So, they don't do Array index out of bounds.
所以他们不会访问到越界的 Array 下标

1389
00:57:25,992 --> 00:57:28,359
So, thay'll return nil if your Array is empty.
当然如果 Array 是空的，它们会返回nil

1390
00:57:29,428 --> 00:57:31,345
Okay? So,

1391
00:57:31,346 --> 00:57:33,263
you should know, you should know about these because they
你们应该了解这些，这会让你们的代码

1392
00:57:33,265 --> 00:57:36,132
can make your code read really nicely sometimes.
有些时候看起来非常好看

1393
00:57:37,335 --> 00:57:38,700
so, for these next ones I'm
下边我还有一个关于

1394
00:57:38,702 --> 00:57:40,802
gonna have a little example Array here,
Array 的小例子，

1395
00:57:40,804 --> 00:57:42,937
this can be an Array that's got three things in it.
这是一个有3个元素的 Array

1396
00:57:42,939 --> 00:57:44,372
I'm not even gonna say what the types of
我们不需要知道它们的类型，

1397
00:57:44,374 --> 00:57:46,874
those three things in there, they could be anything, okay?
任何类型都可以

1398
00:57:46,876 --> 00:57:48,108
Cuz Array is generic, right?
因为 Array 是泛型的

1399
00:57:48,110 --> 00:57:49,743
Array angle bracket T.
Array<T>

1400
00:57:49,745 --> 00:57:50,743
You can assume for
你可以假设

1401
00:57:50,745 --> 00:57:52,878
the purposes of this, they're of type T.
它们都是 T 类型

1402
00:57:52,880 --> 00:57:56,248
Whatever the T is that I created the Array with, right?
无论 T 是什么类型，我创建了一个 T 类型的 Array

1403
00:57:56,250 --> 00:57:58,617
So, let's talk about, you know about append.
让我们继续，你应该知道 append（追加，即在 Array 的末尾增加元素）方法

1404
00:57:58,619 --> 00:57:59,984
That's how you add something to Array,
这就是我们在计算器的 App 中

1405
00:57:59,986 --> 00:58:02,020
we did that in the calculator all the time.
对 Array 操作一直在使用的方法

1406
00:58:02,022 --> 00:58:03,521
There's also insert, so
当然， Array 也有 insert（插入）操作

1407
00:58:03,522 --> 00:58:05,021
you can inset something in the middle of your Array.
你可以在 Array 中间的某个位置插入元素

1408
00:58:05,024 --> 00:58:06,924
You just specify what index.
通过指定一个 index（位置）

1409
00:58:06,926 --> 00:58:09,159
There is also splice.
同样也有 splice 操作

1410
00:58:09,161 --> 00:58:10,593
Kay? Splice will take
Splice 操作会

1411
00:58:10,595 --> 00:58:15,064
another Array and splice it into the middle of your Array.
将另外的一个 Array 加入到你的 Array 的中间位置

1412
00:58:15,066 --> 00:58:15,964
Kay? So that can
明白了吗？有时候

1413
00:58:15,966 --> 00:58:17,699
sometimes be invaluable.
这个操作是十分重要的

1414
00:58:17,701 --> 00:58:19,467
It's otherwise just like insert, it's just like
它不像 insert 操作插入一个元素，它是

1415
00:58:19,469 --> 00:58:22,270
inserting another Array inside the Array.
在 Array 中插入 Array 而不是元素的一种方法

1416
00:58:22,272 --> 00:58:25,673
Okay there's also removeAtIndex of course of
当然还有 removeAtIndex 这样一个方法

1417
00:58:25,675 --> 00:58:29,243
course its a var, if you've got your Array in
如果你确定 Array 是变量，你可以利用这个方法来

1418
00:58:29,245 --> 00:58:31,445
a var you can do removeAtIndex and
从一个 Array 中移除一个元素

1419
00:58:31,447 --> 00:58:33,913
there's also removeRange, okay?
有了这个方法，也有 removeRange 方法

1420
00:58:33,915 --> 00:58:36,683
So you can specify a range with the dot dot dot thing or
removeRange 的方法接受一个范围，并移除这个范围内的所有元素

1421
00:58:36,685 --> 00:58:38,451
the dot dot dot less than thing and
你可以通过 ... 或者 ..< 来创建一个范围

1422
00:58:38,453 --> 00:58:41,253
remove a range of your Array elements.
并在 removeRange 方法中使用这个范围

1423
00:58:41,255 --> 00:58:43,522
And there's also replaceRange, and
另外，还有 replaceRange 这样的方法

1424
00:58:43,524 --> 00:58:46,191
when you replace a range, the thing you replace it with
当你替换一个范围内的元素时，替换的元素个数

1425
00:58:46,193 --> 00:58:47,425
doesn't have to be the same length.
不需要等于被替换的元素个数

1426
00:58:48,428 --> 00:58:51,228
So, I can have an Array and replace a range that
假如我有一个包含3个元素的 Array ，我将这个 Array 的全范围

1427
00:58:51,230 --> 00:58:55,132
spans three things with something that is six long,
替换成包含6个元素的 Array

1428
00:58:55,134 --> 00:58:56,700
and make my Array it'll make my Array longer, okay?
这样就可以使原 Array 变长了

1429
00:58:56,702 --> 00:58:59,102
So you can replace range.
这就是 replaceRange

1430
00:58:59,104 --> 00:59:01,370
There's also sorting.
同样，Array 范型提供排序方法

1431
00:59:02,306 --> 00:59:04,006
You can sort an Array.
你可以对一个 Array 进行排序

1432
00:59:04,008 --> 00:59:08,676
The sorting method in Array takes one argument and
排序方法接受一个函数作为参数，

1433
00:59:08,678 --> 00:59:13,313
that's just a function to determine whether two
一个决定两个元素

1434
00:59:13,315 --> 00:59:16,516
things are ordered before each other or not.
谁放在前面的函数

1435
00:59:16,518 --> 00:59:17,868
Kay? So, it's
明白了吗？这个函数

1436
00:59:17,869 --> 00:59:19,219
going through the Array and putting everything in order.
将遍历整个 Array 并排序整个 Array

1437
00:59:19,221 --> 00:59:20,987
It needs to know, it pick, picks out,
排序方法需要知道元素谁放在前面，它接受一个 Array ，并传出一个 Array

1438
00:59:20,989 --> 00:59:23,055
however whatever sort, if it's Quicksort or
无论是怎么样的排序算法，例如快排

1439
00:59:23,057 --> 00:59:25,691
I don't know what sort it's using in there.
我不知道里面用的什么排序算法

1440
00:59:25,693 --> 00:59:27,092
But it needs to be able to compare things so
它只需要能够比较两个元素即可

1441
00:59:27,094 --> 00:59:30,795
you just provide a function desk comparison and
你只需要提供一个比较函数

1442
00:59:30,797 --> 00:59:32,997
usually you're going to do it with a closure just like this.
通常一般会把比较函数写成一个闭包

1443
00:59:32,999 --> 00:59:36,133
You can see this is kind of the default sorting assuming
这里你可以看到这样的排序函数默认

1444
00:59:36,135 --> 00:59:39,336
that this type can just be compared with less than.
两者之间通过小于来比较

1445
00:59:39,338 --> 00:59:44,174
I would just say a dot sort, closure, $0 < $1.
例如：a.sort { $0 < $1 }

1446
00:59:44,176 --> 00:59:45,992
Make sense?
明白了吗

1447
00:59:45,993 --> 00:59:47,809
And that's gonna return yes, if $0 < $1, and
如果 $0 < $1 的话，这个函数会返回 yes

1448
00:59:47,812 --> 00:59:49,745
that's what sort wants to know and
这个返回结果是我们想了解的

1449
00:59:49,747 --> 00:59:52,548
it's gonna call that closure repeatedly okay?
sort 方法会不断的调用这个闭包

1450
00:59:52,550 --> 00:59:55,684
As it's going through doing it's quick sort or whatever.
当它采用的是快速排序或者其他任何的排序算法

1451
00:59:55,686 --> 00:59:58,286
There's also another one call sorted.
这里还有另外一个方法叫 sorted

1452
00:59:58,288 --> 01:00:00,555
So we're ta, this is an in place sort.
在适当的地方

1453
01:00:00,557 --> 01:00:01,889
Right? Sorts the Array in place.
将整个 Array 进行排序

1454
01:00:01,891 --> 01:00:05,959
They're sorted, will return a new Array that is sorted.
如果一个 Array 是已排序，它将会返回一个已排序的新 Array

1455
01:00:05,961 --> 01:00:07,593
Okay? A copy of your Array sorted.
这个意思是，一个已排序的 Array 的拷贝

1456
01:00:10,298 --> 01:00:11,497
More Array methods.
接下来让我们看看更多的 Array 方法

1457
01:00:11,499 --> 01:00:14,466
Okay, so these three are pretty cool.
这里有3个非常酷的方法

1458
01:00:14,468 --> 01:00:16,034
This one's called filter.
这一个叫 filter

1459
01:00:16,036 --> 01:00:19,103
So filter will give you a new Array with all
filter 方法将你所有不想要的元素

1460
01:00:19,105 --> 01:00:22,807
the undesirable elements filtered out of there.
过滤掉然后返回给你那个过滤后的 Array

1461
01:00:22,809 --> 01:00:25,576
And the way you specify which ones are all undesirable is
你指定元素是不是你想要的方式，就是提供一个

1462
01:00:25,578 --> 01:00:27,511
with the argument which is a function,
函数作为参数

1463
01:00:27,513 --> 01:00:28,812
that just returns a Bool,
函数返回一个 Bool 的结果

1464
01:00:28,814 --> 01:00:31,080
whether something's undesirable or not.
来表明这个元素是不是想要的

1465
01:00:32,283 --> 01:00:32,848
Make sense?
明白了吗？

1466
01:00:33,850 --> 01:00:36,351
And there's another one you can do by mapping.
另外一个很酷的方法就是 mapping（映射）

1467
01:00:36,353 --> 01:00:39,387
So this will give you a new Array where every single
这将会将你原来的 Array 中每一个元素

1468
01:00:39,389 --> 01:00:43,023
element in your Array is mapped to something else.
映射到一个新的 Array

1469
01:00:43,025 --> 01:00:44,458
And the thing you map it to doesn't even have to
原来的元素通过映射后的类型甚至都

1470
01:00:44,460 --> 01:00:46,693
be the same type, so I can have an Array of Ints, and
不需要与原来的一样，好比我有一个 Int 型的 Array

1471
01:00:46,695 --> 01:00:49,095
I could map it to an Array of Strings.
我可以将这些元素映射为 String 类型

1472
01:00:49,097 --> 01:00:50,763
And that's what I've done here.
这就是我在这里所做的

1473
01:00:50,765 --> 01:00:52,231
So I have this Array of Ints, 1, 2, 3, and
这里，我有一个包含1，2，3的 Int 型 Array

1474
01:00:52,233 --> 01:00:54,399
I've mapped it using a closure that
我利用一个闭包将它们映射

1475
01:00:54,401 --> 01:00:59,804
returns the Stringification of it to an Arrayed Strings.
到它们的字符串形式

1476
01:00:59,806 --> 01:01:02,940
Now, you can see, incredibly concise language Swift.
从这些方法中你可以看到，Swift 语言是多么简洁

1477
01:01:02,942 --> 01:01:05,976
I mean, to take an Array of Ints and turn it into an Array
我的意思是，拿来一个 Int 型的 Array ，将

1478
01:01:05,978 --> 01:01:08,578
of Strings, no for loops, no nothing.
它转变成一个 String 型的 Array ，不需要循环

1479
01:01:08,580 --> 01:01:11,147
Just, you know, running a dozen characters here.
你只需要知道的是，你可以充分享受

1480
01:01:11,149 --> 01:01:13,116
So you really want to take advantage of some of
Swift 语言带给你的闭包特性

1481
01:01:13,118 --> 01:01:15,918
the things Swift can do with closures, syntax and
不需要撰写

1482
01:01:15,920 --> 01:01:16,485
things like that.
一大堆的代码

1483
01:01:16,487 --> 01:01:20,856
You can also reduce an entire Array to, to a single value.
还有，你可以将整个 Array  reduce（减少）为一个值

1484
01:01:20,858 --> 01:01:23,925
So this one takes an argument which is the initial value you
这个方法接受一个参数

1485
01:01:23,927 --> 01:01:25,059
want to start with.
这个参数是你自定的初始值

1486
01:01:25,061 --> 01:01:26,794
And then it just takes a function that
还有一个函数作为参数

1487
01:01:26,796 --> 01:01:30,364
takes the value so far and the next element in the Array and
这个函数传入当前的值和下一个 Array 中的元素

1488
01:01:30,366 --> 01:01:31,832
you return what the combination is.
你只需要返回他们两者的组合是什么

1489
01:01:31,834 --> 01:01:33,533
So you're just combining, combining, combining.
就这样你一直组合、组合、组合，直到得到最终的结果

1490
01:01:33,535 --> 01:01:36,069
So for example if you wanted to add up an Array,
举例来说，你想要累加整个 Array 中的值

1491
01:01:36,071 --> 01:01:38,571
you could say [1, 2, 3.]reduce.
你只需要输入 [1, 2, 3].reduce

1492
01:01:38,573 --> 01:01:41,473
Start with a 0, and then my closure just gonna add
然后我们以0为初始值，即第一个参数，我的闭包作为第二个参数

1493
01:01:41,475 --> 01:01:48,113
the next element, which is the $1 to, so far which is $0.
将下一个元素（$1）累加起来

1494
01:01:48,115 --> 01:01:52,516
Okay all right, String.
以上就是所有 Array 中的方法，String

1495
01:01:52,518 --> 01:01:54,618
So String is a little bit complicated.
String 有一点点复杂

1496
01:01:57,690 --> 01:01:59,055
I can tell all the, by the way,
今天的课程我无法将所有 String 的内容讲完

1497
01:01:59,057 --> 01:02:00,790
already I'm not gonna get to the end of this so
String 的内容可能一直要持续到

1498
01:02:00,792 --> 01:02:02,658
we'll finish this next Wednesday.
下周三的课程

1499
01:02:02,660 --> 01:02:05,327
This whole slide package here but.
这个 Slide 包在这里

1500
01:02:05,329 --> 01:02:06,945
So String.
String

1501
01:02:06,946 --> 01:02:08,562
String is complicated when it comes to indexing.
字符串处理的一个难点是处理索引

1502
01:02:08,565 --> 01:02:10,765
You know, creating sub Strings and stuff like that.
和创建字符串等其他的问题

1503
01:02:10,767 --> 01:02:13,368
A lot of people are like, oh, I can't even figure out how to
一堆人会说：“我根本弄不明白怎么

1504
01:02:13,370 --> 01:02:16,103
make a subString of a String in Swift.
在 Swift 中创建一个字符串的子串

1505
01:02:16,105 --> 01:02:18,155
It's so complicated.
太复杂了”

1506
01:02:18,156 --> 01:02:20,206
But once you understand that Strings are made of unicode
但是一旦你了解到字符串只不过是由一堆 Unicode 字符组成

1507
01:02:20,209 --> 01:02:23,844
characters and when you get a subString, you actually don't
的时候，你就不会希望你处理的子串的是

1508
01:02:23,846 --> 01:02:26,179
want a subString of unicode characters.
一堆由 Unicode 字符组成的了

1509
01:02:26,181 --> 01:02:27,213
You want a subString of
你想要处理的是

1510
01:02:27,215 --> 01:02:29,615
unicode characters that are on glyph boundaries.
单个的 Unicode 字素
[字素概念引用自：https://msdn.microsoft.com/zh-cn/library/vstudio/7h9tk6x8(v=vs.100).aspx]

1511
01:02:29,617 --> 01:02:33,752
A glyph is something you perceive to be a character.
字素是显示为单字符的文本单元

1512
01:02:33,754 --> 01:02:34,986
But in unicode, it could be
在 Unicode 编码中

1513
01:02:34,988 --> 01:02:36,821
multiple characters making up one glyph.
一个字素有可能由多个字符组成

1514
01:02:36,823 --> 01:02:38,522
For example, an accent.
举例说，一个重音符号

1515
01:02:38,524 --> 01:02:41,291
So you know, a lot of European languages, there's accents,
在一些欧洲语系中有重音符号

1516
01:02:41,293 --> 01:02:44,561
okay, maybe you know, in French, you have accent aigu,
你们中有些人应该知道，在法语中有 ´ 重音符号

1517
01:02:44,563 --> 01:02:46,396
right, which is the forward going top slash.
对，就是这个斜向上的横线

1518
01:02:46,398 --> 01:02:48,464
Well, that could be two unicode characters, E and
带有这个重音符号的 é 就是由两个 Unicode 字符组成，e 和

1519
01:02:48,466 --> 01:02:50,433
the accent character.
重音符号 ´

1520
01:02:50,435 --> 01:02:53,302
So two characters makes what you perceive to be one glyph.
两个 Unicode 字符组成一个字素

1521
01:02:53,304 --> 01:02:57,172
So you can't index into this String which is
所以你不能在一个字符串像数组一样

1522
01:02:57,174 --> 01:02:58,206
an Array of characters.
使用索引

1523
01:02:58,208 --> 01:02:59,674
That's what a String is,
字符串是

1524
01:02:59,675 --> 01:03:01,141
a String is Array of in essentially,
简单的说，内部是

1525
01:03:01,144 --> 01:03:03,010
internally a collection or
由一系列 Unicode 字符

1526
01:03:03,012 --> 01:03:04,778
collection of unicode characters.
组成的一个集合

1527
01:03:04,780 --> 01:03:06,312
You can't really index by Int or
你不能用整数来索引

1528
01:03:06,314 --> 01:03:08,981
you might be halfway through the e accent aigu, and
因为你有可能碰巧遇到类似的重音符号

1529
01:03:08,983 --> 01:03:12,284
you're getting you know, either the ac, accent aigu or
像数组一样用整数索引做有可能会把重音符号和

1530
01:03:12,286 --> 01:03:14,319
the e but not the character.
e 分开，而无法取得整个字符 é

1531
01:03:14,321 --> 01:03:17,055
So instead Strings are indexed by this other type called
所以字符串是由另外的一个类型来索引的

1532
01:03:17,057 --> 01:03:18,890
String.index.
这种类型叫 String.Index

1533
01:03:18,892 --> 01:03:20,024
Okay? Now how do
接下来，你如何

1534
01:03:20,026 --> 01:03:22,193
you get a String.index?
获得一个 String.Index 呢？

1535
01:03:22,195 --> 01:03:22,826
Okay, well, yes.
好

1536
01:03:22,828 --> 01:03:23,660
It's saying here.
用 Slide 上这里说的函数

1537
01:03:23,662 --> 01:03:25,862
Okay?
明白了吗？

1538
01:03:25,863 --> 01:03:28,063
So you get a sting.index by getting the startIndex of
你可以通过 startIndex 来获取这个字符串的开始位置

1539
01:03:28,066 --> 01:03:29,299
the String.
来得到一个 String.Index 类型的变量

1540
01:03:29,300 --> 01:03:30,533
That gives you String.index that point to
刚才的那个方法，它会返回给你一个指向字符串开头的

1541
01:03:30,535 --> 01:03:31,967
the first character of the String.
String.Index 的变量

1542
01:03:31,969 --> 01:03:34,903
And then you advance it forward,
然后你可以讲这个索引向后推进

1543
01:03:34,905 --> 01:03:36,505
however many times you wanna go.
随便你想推进多少次都行

1544
01:03:36,507 --> 01:03:38,306
So in other words, you have to look through the characters so
换言之，你在遍历整个字符的过程中

1545
01:03:38,308 --> 01:03:40,141
that it will jump over e accent aigu,
这种方法它会跳过整个 é 而不是只跳过一个 e 而停在重音符号上

1546
01:03:40,143 --> 01:03:42,443
both characters to the next one, you see?
明白了吗？

1547
01:03:43,646 --> 01:03:45,278
So you do that with this function,
而你可以你使用下面的这个函数来推进你的 String.Index

1548
01:03:45,280 --> 01:03:47,914
it's not a method in String, it's actually just a function,
这不是 String 类中的一个方法，这只是一个函数

1549
01:03:47,916 --> 01:03:50,183
a global function called advance.
一个叫 advance 的全局函数

1550
01:03:50,185 --> 01:03:52,618
And you give it the index, okay, and
你传入索引

1551
01:03:52,620 --> 01:03:55,187
you tell it how many times you want it to move forward.
同时，你告诉这个函数你想向后推进多少次

1552
01:03:55,189 --> 01:03:58,123
And it will give you back a new index.
然后它就会返回给你一个新的索引位置

1553
01:03:58,125 --> 01:03:59,491
So here's an example.
这里举一个例子

1554
01:03:59,493 --> 01:04:01,859
I have a String that says hello, okay?
我有一个内容为 hello 的字符串

1555
01:04:01,861 --> 01:04:05,462
I wanna get the index of the L, the first L.
我想要知道第一个 l 的位置

1556
01:04:05,464 --> 01:04:06,596
Okay? So I say,
我只需要输入

1557
01:04:06,598 --> 01:04:08,765
let the index equal advance,
let index = advance ...

1558
01:04:08,767 --> 01:04:11,767
the startIndex of that String, go forward two.
advance(s.startIndex, 2)

1559
01:04:12,903 --> 01:04:13,769
Okay?
明白了吗？

1560
01:04:13,771 --> 01:04:15,487
So now it's pointing at the l.
然后它就会指向第一个 l 了

1561
01:04:15,488 --> 01:04:17,204
It went forward one to the e, now forward one to the l.
向前1个会指向 e，向后一个会指向 l

1562
01:04:17,207 --> 01:04:18,806
And again, if that, it was e accent aigu,
这里我再重申，假如这里不是 e 而是一个 é

1563
01:04:18,808 --> 01:04:21,642
it would have gone forward four Unicode characters, but
刚才的操作他会向前推进4个 Unicode 字符

1564
01:04:21,644 --> 01:04:25,446
only three to the third glyph, as you perceive it, okay?
但只有第3个字符是 e

1565
01:04:25,448 --> 01:04:28,715
So now that I have a pointer to that L, I could use, for
接下来，既然我已经有一个指向 l 的指针

1566
01:04:28,717 --> 01:04:31,484
example, a nice String function called splice.
我就可以用一个 String 类中的方法，叫 splice

1567
01:04:31,486 --> 01:04:33,953
So splice is just like the splice in Array.
字符串中的 splice 和数组中的 splice 方法很像

1568
01:04:33,955 --> 01:04:38,157
It will splice a String into the middle of another String.
它会将一个字符串拼合到另外的一个字符串之中

1569
01:04:38,159 --> 01:04:40,459
Okay? And I'm gonna have a splice at
明白吗？如果我在这个位置使用了 splice 方法

1570
01:04:40,461 --> 01:04:44,229
that index, and that's gonna make it be heabcllo.
（另外一个字符串是 abc 的话）那么原先的字符串就会变成 heabcllo

1571
01:04:44,231 --> 01:04:47,265
Splice the abc right into the middle there.
将 abc 加入到这个中间的位置

1572
01:04:47,267 --> 01:04:49,233
Okay?
明白了吗？

1573
01:04:49,235 --> 01:04:53,303
So, this startIndex is the magic behind making that work.
所以 startIndex 是在幕后起关键作用的

1574
01:04:53,305 --> 01:04:56,840
Also if I said, if I got two local variables star deck,
另外假如我说，我有两个局部变量 startIndex

1575
01:04:56,842 --> 01:05:00,477
Index, and endIndex, which I made by taking advance of
和 endIndex

1576
01:05:00,479 --> 01:05:02,478
the startIndex by one and six.
startIndex 是由最初的 startIndex 向后推进1个字符得到的，endIndex 是向后推进6个得到的

1577
01:05:02,480 --> 01:05:05,448
So this is going to be, I want it to be from index one to
这也就意味着，我想这两个变量一个指向索引1的位置

1578
01:05:05,450 --> 01:05:08,150
index six, then I could get a subString and
另一个指向索引6的位置，然后我可以在这两个范围内创建一个子串

1579
01:05:08,152 --> 01:05:11,253
I get a subString and in the String exactly the same like
就像数组创建子数组一样

1580
01:05:11,255 --> 01:05:13,221
an Array, square brackets.
使用方括号得到一个字符串的子串

1581
01:05:13,223 --> 01:05:14,689
String, square brackets.
也就是说，字符串也可以使用方括号来创建子串

1582
01:05:14,691 --> 01:05:17,792
But inside that square brackets goes a range.
方括号里面是一个范围

1583
01:05:17,794 --> 01:05:19,326
And the range, the dot, dot,
范围由两个 String.Index 类型的

1584
01:05:19,328 --> 01:05:22,529
dot thing has to have a String.index on the left and
变量组成，一个在左侧

1585
01:05:22,531 --> 01:05:26,265
a String.index on the right, not Ints.
一个在右侧，中间是 ..

1586
01:05:26,267 --> 01:05:27,633
Okay?
String.Index 类型而不是 Int 型，明白了吗？

1587
01:05:27,634 --> 01:05:29,000
So here I got String.index.
这里我

1588
01:05:29,003 --> 01:05:31,937
By doing this advance for the left and a String.Index on
通过向前推进到左侧的位置和右侧的位置，得到

1589
01:05:31,939 --> 01:05:34,673
the right, until the subString will be eabcl.
截断的子串为 eabcl 的两个 String.Index 类型的变量

1590
01:05:34,675 --> 01:05:36,574
Cuz I went from index one,
因为我从索引1的位置

1591
01:05:36,576 --> 01:05:41,112
which is the second character, index zero is the first, or,
也就是是第二个字符，索引0是第一个字符，这跟数组索引情况相似

1592
01:05:41,114 --> 01:05:44,581
to index six, not including index six, okay?
到索引6，但是不包括索引6

1593
01:05:44,583 --> 01:05:46,049
Everyone understand String.Index now?
每个人都理解了 String.Index 了吗？

1594
01:05:46,051 --> 01:05:49,552
It's all about advance, 'kay?
以上这些是关于 advance 函数的

1595
01:05:49,554 --> 01:05:52,588
The advance function is the key to understanding how to
advance 函数是理解如何创建子串的关键

1596
01:05:52,590 --> 01:05:54,957
subString Strings.

1597
01:05:54,959 --> 01:05:57,126
And, there's lots of other, once you understand this,
还有其他的东西，一旦你弄懂了这个

1598
01:05:57,128 --> 01:05:58,527
there's things like range of String.
类似 rangeOfString 这样的东西你也会明白了

1599
01:05:58,529 --> 01:06:01,629
Remember we used range of String in calculator, and it,
还记得我们在我们的计算器应用中用到了 rangeOfString

1600
01:06:01,631 --> 01:06:04,365
I told you it returned nil if it couldn't find it?
我告诉过你们，如果 rangeOfString 不能找到的想要的范围的话，会返回 nil

1601
01:06:04,367 --> 01:06:06,834
Well, what does it return if it could find it?
那么如果 rangeOfString 能找到范围的话，它会返回什么？

1602
01:06:06,836 --> 01:06:09,536
Well, it returns a Range of String.Index.
它会返回 Range<String.Index>

1603
01:06:09,538 --> 01:06:11,388
Actually, it
实际上

1604
01:06:11,389 --> 01:06:13,239
returns an Optional Range of String.Index.
它会返回一个 Optional 的 Range<String.Index>

1605
01:06:13,242 --> 01:06:14,607
Okay? That's how, if you used it for
明白了吗？这就是如何使用这个方法

1606
01:06:14,609 --> 01:06:15,908
your assignment, that's how you used it.
你们的作业中可能会用到它

1607
01:06:15,910 --> 01:06:17,543
You used the Optional nature of it,
你可以用到它 Optional 的性质

1608
01:06:17,545 --> 01:06:20,212
but now you can even use the Range nature of it.
你更可以用到它 Range 的性质

1609
01:06:20,214 --> 01:06:22,498
So for example, if we wanted to
比如我们想要在一个含有数字的字符串中

1610
01:06:22,499 --> 01:06:24,783
get the whole number portion of a String that had a number.
获取其中的数字部分

1611
01:06:24,785 --> 01:06:27,252
So I have, let's say, 56.25 as a String,
这里我有一个“56.25”的字符串

1612
01:06:27,254 --> 01:06:29,020
I wanna get the whole number part.
我想要获取整个数字部分

1613
01:06:29,022 --> 01:06:33,457
I could just say find me that decimal point.
我可以这么做——首先找到小数点

1614
01:06:33,459 --> 01:06:34,942
Kay? And that's gonna
然后

1615
01:06:34,943 --> 01:06:36,426
return a range if, if it can find it.
它会返回一个范围，如果它能够找到小数点

1616
01:06:36,428 --> 01:06:37,844
If there's a decimal point in
如果在我刚才的字符串中有小数点的话

1617
01:06:37,845 --> 01:06:39,261
there it's gonna return that range.
这个方法会返回那个范围

1618
01:06:39,264 --> 01:06:43,232
And I'm gonna grab the part from the num.startIndex,
接着我就可以用 num.startIndex 来获取那部分了

1619
01:06:43,234 --> 01:06:46,102
you see the num is the number, it's startIndex all the way
这里你可以看到 num 是一个数字，他的 startIndex 是

1620
01:06:46,104 --> 01:06:49,805
to where the decimal is, not including the decimal, okay?
小数点之后的那个位置，而不是小数点，明白了吗？

1621
01:06:49,807 --> 01:06:51,406
Now I've got sub String which is the whole part.
现在我已经从字符串中提取了我想要的那部分

1622
01:06:53,476 --> 01:06:54,108
Are we cool with that?
理解了吗？

1623
01:06:55,544 --> 01:06:57,644
So sub Stringing and Strings actually,
所以，字符串和子字符串

1624
01:06:57,646 --> 01:07:01,247
once you understand this whole index thing pretty powerful.
一旦你了解了这些方法，

1625
01:07:01,249 --> 01:07:03,416
We could even remove the whole number part.
我们就可以利用它们在字符串中移除整个数字部分

1626
01:07:03,418 --> 01:07:06,185
'Kay, just by using removeRange of that same
只需要对相同的范围使用 removeRange

1627
01:07:06,187 --> 01:07:09,421
range, num.startIndex, the decimal range.
num.startIndex，小数的范围

1628
01:07:09,423 --> 01:07:12,357
Or we can replace the range with other things, etc.
或者我们可以将这个范围替换成其他的东西，等等

1629
01:07:12,359 --> 01:07:15,060
Okay, so there's a lot of String methods there for
好的，对字符串进行修改的方法大多数

1630
01:07:15,062 --> 01:07:17,895
doing that and they're all based on that String index.
都基于字符串的索引

1631
01:07:17,897 --> 01:07:19,363
Okay, other String methods,
还有另外一些字符串的方法

1632
01:07:19,365 --> 01:07:21,265
I'm gonna start blasting through a lot of this.
我会快速讲解其中的一些

1633
01:07:21,267 --> 01:07:22,933
You could look these all up in the documentation.
你可以在文档里找到所有的这些方法

1634
01:07:22,935 --> 01:07:24,567
Some of these it actually gets from NSString,
其中一些实际上从 NSString 中来的

1635
01:07:24,569 --> 01:07:26,402
which I'm gonna talk about in a moment.
稍后我会讲一下 NSString

1636
01:07:26,404 --> 01:07:28,771
You can see that you can find the endIndex,
你看你从 Slide 上可以找到 endIndex

1637
01:07:28,773 --> 01:07:31,740
there is the join takura talked about before
还有我们之前讨论过的 join 方法

1638
01:07:31,742 --> 01:07:36,544
notice that there's toInt but not toDouble.
注意，还有一个方法是 toInt 而不是 toDouble

1639
01:07:36,546 --> 01:07:38,880
Why is there toInt in String and not toDouble?
为什么在字符串操作中只有 toInt 而没有 toDouble？

1640
01:07:38,882 --> 01:07:40,614
Anybody having any idea why it is?
有人知道原因吗？

1641
01:07:43,118 --> 01:07:45,485
It's because when you convert to a Double,
这是因为如果你转换到一个 Double 时

1642
01:07:45,487 --> 01:07:46,986
you have to specify things.
你需要指定一些东西

1643
01:07:46,988 --> 01:07:48,721
How many significant digits do you want?
你需要多少的有效位数？

1644
01:07:48,723 --> 01:07:50,723
How many digits after the fraction do you want,
你需要小数点后几位？

1645
01:07:50,725 --> 01:07:52,258
things like that?
如此之类的问题

1646
01:07:52,259 --> 01:07:53,792
And so there's really nowhere to specify that.
事实上没有地方去指定这些东西

1647
01:07:53,794 --> 01:07:55,560
It would have to be toDouble with a whole bunch of
如果有一个 toDouble 方法，那么会有一大堆的

1648
01:07:55,562 --> 01:07:57,795
arguments to specify how you wanna do that conversion.
参数来指定转换中的一些细节

1649
01:07:57,797 --> 01:08:00,498
When you convert to an Int, there's nothing inside,
但当你将字符串转换为 Int 时，这些细节都不存在了

1650
01:08:00,500 --> 01:08:01,899
you just convert it to the Int, right?
你仅仅需要将它转换为 Int，对吗？

1651
01:08:01,901 --> 01:08:05,602
So the whole number so but notice that toInt does return
注意，toInt 方法返回的是一个 Optional Int，

1652
01:08:05,604 --> 01:08:08,672
an Optional Int, that's because if you say toInt,
那是因为，当你调用 toInt 方法时

1653
01:08:08,674 --> 01:08:13,509
if you send out to hello, it's going to be nil, okay?
但是你的字符串是“hello”，此时会返回 nil，明白了吗？

1654
01:08:13,511 --> 01:08:15,844
So, String methods, all right?
String 中的方法，没问题了吧？

1655
01:08:16,880 --> 01:08:20,248
Okay, there's kind of a hidden bunch of methods which you
好的，其实有一些隐藏的方法

1656
01:08:20,250 --> 01:08:24,018
don't even know about, which is conversions using init.
这些方法你根本不知道，这就是使用初始化方法实现转换

1657
01:08:24,020 --> 01:08:26,220
So for example, if I had a Double and
比如，我有一个 Double 的值

1658
01:08:26,222 --> 01:08:31,224
a Float, I could say, let x equal Int of that Double, and
浮点数，我可以利用 let x = Int(d)，

1659
01:08:31,226 --> 01:08:35,461
I just basically create a floor and turned it to an int.
我就可以对这个值取下整并将它转化为一个 Int

1660
01:08:35,463 --> 01:08:37,029
So I converted it.
这就是我如何转换的

1661
01:08:37,030 --> 01:08:38,596
So I know you convert things and
我知道你们把这个东西转换成那个东西

1662
01:08:38,599 --> 01:08:39,865
convert them from one thing to another.
或者从那个东西转换成这个东西

1663
01:08:39,867 --> 01:08:42,834
It makes total sense with the number values like Ints and
像 Int 和 Float 或者类似的

1664
01:08:42,836 --> 01:08:44,152
Floats and things like that.
都可以这么做来相互转换

1665
01:08:44,153 --> 01:08:45,469
And you're gonna see CGFloat next week.
下周你们会使用到 CGFloat

1666
01:08:45,472 --> 01:08:47,905
That's another kind of floating point number.
这是另外一种浮点数

1667
01:08:47,907 --> 01:08:49,340
And you can convert using.
同样你可以通过转换使用它

1668
01:08:49,342 --> 01:08:50,741
There's no toInt or anything.
但是 CGFloat 没有 toInt 或者其他的方法

1669
01:08:50,743 --> 01:08:53,410
You just create a new one with the initializer.
你只能通过初始化方法（initializer）创建一个 CGFloat 对象

1670
01:08:53,412 --> 01:08:54,411
'Kay, so the numbers.
接下来，Numbers

1671
01:08:54,413 --> 01:08:56,212
But you almost might be surprised.
你会感到惊讶的是

1672
01:08:56,214 --> 01:08:57,747
Actually, if you read the homework carefully or
如果你之前认真地读过了课后作业的要求

1673
01:08:57,749 --> 01:08:59,715
the reading assignment, you saw this.
你会看到

1674
01:08:59,717 --> 01:09:02,217
Is that you can convert Arrays and
你可以在 Array 和字符串之间

1675
01:09:02,219 --> 01:09:06,521
Strings using these initializer.
通过初始化方法完成相互转化

1676
01:09:06,523 --> 01:09:11,158
For example, you can say Array of a String, so create a new
举例，你通过调用 Array("abc") 来

1677
01:09:11,160 --> 01:09:13,927
Array and the initializers argument is a String.
创建一个数组

1678
01:09:13,929 --> 01:09:15,095
And it will return you an Array of
这个方法会返回一个数组

1679
01:09:15,097 --> 01:09:18,231
all the characters in that String, right?
而数组中的元素是字符串中的字符

1680
01:09:18,233 --> 01:09:20,800
Unicode characters.
Unicode 字符

1681
01:09:20,801 --> 01:09:23,368
Or vice versa, you can have an Array of unicode characters.
相反的，你有一个包含一堆 Unicode 字符的数组

1682
01:09:23,371 --> 01:09:25,404
Right?
是吧？

1683
01:09:25,405 --> 01:09:27,438
And it will, and you pass that to Strings constructor and
你可以使用 String 的构建器（constructor）来创建一个字符串

1684
01:09:27,441 --> 01:09:29,974
it will return the String with those things zipped up.
字符串中字符由数组中元素拼接而成

1685
01:09:31,377 --> 01:09:32,660
Okay?
明白了吗？

1686
01:09:32,661 --> 01:09:33,944
So there's kind of a hidden thing there.
所以还有一些隐藏的方法

1687
01:09:35,647 --> 01:09:38,214
Notice that you can't do String of 52.5,
但是，注意你不能调用 let s = String(52.5)

1688
01:09:38,216 --> 01:09:40,950
but that's okay because you have that back slash,
但是你可以通过 let s = "\(37.5)" 来实现

1689
01:09:40,952 --> 01:09:43,319
open-parenthesis thing to convert.
浮点数到字符串之间的

1690
01:09:43,321 --> 01:09:45,087
Of Floats to Strings.
转换

1691
01:09:46,857 --> 01:09:47,722
Okay? You can do
明白了吗？你可以

1692
01:09:47,724 --> 01:09:49,190
String of 52 though.
let s = String(52) 这么做

1693
01:09:49,192 --> 01:09:51,359
Cuz it has toInt, it kinda knows how to do that.
因为 String 有 toInt 这个方法，它知道如何将 Int 转换成字符串

1694
01:09:52,728 --> 01:09:54,294
All right, assertions.
接下来，Assertions

1695
01:09:54,296 --> 01:09:57,364
So assertions, really valuable debugging aid.
Assertions 是一个很有用的 debug 方法

1696
01:09:57,366 --> 01:10:01,200
They basically take a closure as the first argument.
它们接受一个闭包作为其第一个参数

1697
01:10:01,202 --> 01:10:02,434
It's an auto closure,
闭包是 autoclosure 的

1698
01:10:02,436 --> 01:10:03,635
which means you don't need the curly braces.
这意味着你不需要花括号

1699
01:10:03,637 --> 01:10:05,937
Is this just kind of funky think, okay.
这是一个很有意思的事情

1700
01:10:06,940 --> 01:10:10,041
So the first argument is what would be inside the,
总而言之，第一个参数应该是

1701
01:10:10,043 --> 01:10:11,275
the curly braces of a closure.
在闭包括号内的那些东西

1702
01:10:11,277 --> 01:10:14,244
And the second argument is some String that's gonna be
assert() 的第二个参数是一个字符串

1703
01:10:14,246 --> 01:10:18,181
printed out on your console because assert, if whatever
假如 assert 方法的第一个参数返回的是 false

1704
01:10:18,183 --> 01:10:21,184
that thing that was in the auto-closure evaluates to,
这个字符串将会在你的控制台中输出

1705
01:10:21,186 --> 01:10:22,818
if that's not true.

1706
01:10:22,820 --> 01:10:24,720
'Kay, cuz you're asserting that that's true,
这是因为你 assert 的条件应该是成立的

1707
01:10:24,722 --> 01:10:26,154
then it's gonna crash your program.
如果不成立，那么它会导致你的程序崩溃

1708
01:10:27,257 --> 01:10:28,356
Okay, and print that message out.
这时在控制台中输出一个信息

1709
01:10:28,358 --> 01:10:30,241
So it's a great way to make
对程序的 debug 是很有帮助的

1710
01:10:30,242 --> 01:10:32,125
your program crash when things that should be true aren't.
因为你的程序因为某些条件的不满足而导致崩溃

1711
01:10:32,128 --> 01:10:35,796
Now, asserts don't work when you build your program for
assert 方法会在你生成程序的 Release 版本的时候

1712
01:10:35,798 --> 01:10:37,497
release, like to the App Store.
失效，比如提交到 App Store 的版本

1713
01:10:37,499 --> 01:10:40,600
When you're shipping to the App Store, asserts don't work.
当你在把程序提交到 App Store 的时候，assert 不会工作

1714
01:10:40,602 --> 01:10:42,635
It doesn't even evaluate the closure, okay,
这时，它甚至不会对闭包求值

1715
01:10:42,637 --> 01:10:43,302
they're just ignored.
它们被忽略了

1716
01:10:44,405 --> 01:10:46,138
But for debugging, it's pretty good.
这个在 debug 中很有用

1717
01:10:46,140 --> 01:10:50,108
So I might have a function called validation that should,
我可能会有一个叫 validation 的函数

1718
01:10:50,110 --> 01:10:52,944
at this point that I'm executing this assert
当我在执行 assert 的时候

1719
01:10:52,946 --> 01:10:54,945
not be returning nil.
不应该返回 nil

1720
01:10:54,947 --> 01:10:59,249
And if it does return nil then I'm going to crash here.
而且，它如果返回 nil 了，这会把程序搞崩溃

1721
01:10:59,251 --> 01:11:01,685
So I say the assertion is that validation should not be
这里我写 assert(validation() != nil, "the validation fucniton return nil")

1722
01:11:01,687 --> 01:11:04,087
nil right now.

1723
01:11:04,089 --> 01:11:04,653
'Kay?

1724
01:11:05,890 --> 01:11:10,291
So a lot of languages have assert so Swift does too.
assert 在很多语言中都有实现，Swift 也有一样

1725
01:11:10,293 --> 01:11:12,827
okay, other function, so there's a lot of function and
好的，还有一些其他的函数

1726
01:11:12,829 --> 01:11:15,830
these do not appear to be documented anywhere yet.
这些函数并没有出现在文档中

1727
01:11:15,832 --> 01:11:18,332
So the slide might be your only documentation.
所以我的 Slide 可能是唯一你们可以参考的文档

1728
01:11:18,334 --> 01:11:20,033
I'm sure you can find about them on the internet instead
我相信你们在网上也可以找到这些

1729
01:11:20,035 --> 01:11:22,002
of too but there's a lot of functions.
可能网上的资料还要更详细一点

1730
01:11:22,004 --> 01:11:24,303
These are global functions, not methods.
这些是全局函数，并不是 String, Array 或者其他的 struct 的方法

1731
01:11:24,305 --> 01:11:26,872
They take arguments which are hard for
它们接受一些参数，这些参数

1732
01:11:26,874 --> 01:11:28,907
me to explain to you right now.
目前我很难跟你们解释

1733
01:11:28,909 --> 01:11:32,044
But basically they take Arrays and Strings, and Dictionaries,
但是你们只需要知道这些函数可以接受 Array, Dictionary, String 的参数

1734
01:11:32,046 --> 01:11:34,245
because they take other things that Arrays and
因为它们还接受 Array, Dictionary, String 的参数

1735
01:11:34,247 --> 01:11:37,448
Strings, and Dictionaries are, those things.
和其他的一些东西

1736
01:11:37,450 --> 01:11:40,985
But you can look through this list kinda interesting things.
你可以看一遍这个列表

1737
01:11:40,987 --> 01:11:42,853
I can combine it with the thing I
我会将它和 String 中的方法

1738
01:11:42,855 --> 01:11:45,956
was talking about at the end there with the String.
混合在一起

1739
01:11:45,958 --> 01:11:47,624
Passing in an Array of characters.
传入一个由字符组成的数组

1740
01:11:47,626 --> 01:11:51,694
I can actually take a String, call a reverse, which returns
我可以拿一个字符串，在它之上调用 reverse 方法

1741
01:11:51,696 --> 01:11:55,731
an Array of the characters reversed and then call String
返回这些字符的反转，然后再调用

1742
01:11:55,733 --> 01:11:59,201
to push it back and call it, create a String again.
String 的方法创建一个新的字符串

1743
01:11:59,203 --> 01:12:00,502
All right?
明白了吗？

1744
01:12:00,504 --> 01:12:02,070
Objective-C Compatibility.
Objective-C 兼容性

1745
01:12:02,072 --> 01:12:04,322
You know what?
这个话题

1746
01:12:04,323 --> 01:12:06,573
We are going to wait and talk about this next time.
我们下一次再讲

1747
01:12:06,576 --> 01:12:08,009
Very important topic.
这是一个很重要的话题

1748
01:12:08,010 --> 01:12:09,443
But I don't want to give it short shrift.
我想好好探讨一下

1749
01:12:09,445 --> 01:12:11,178
So, that is it for today.
这就是今天课程的所有内容

1750
01:12:11,180 --> 01:12:15,882
Let me, quickly, show you, this slide.
最后让我快速给你们看一下这页 Slide

1751
01:12:17,719 --> 01:12:20,052
Okay coming up, no Friday section this week.
周五没有课程

1752
01:12:20,054 --> 01:12:21,820
Next Monday is holiday, no lecture.
下周一是节假日，也没有课程

1753
01:12:21,822 --> 01:12:23,138
Next Wednesday,
下周三

1754
01:12:23,139 --> 01:12:24,455
I might not be talking about auto layout next week,
我可能会讲一些 Auto Layout 的话题

1755
01:12:24,458 --> 01:12:26,425
I'm not sure.
但不一定

1756
01:12:26,426 --> 01:12:28,393
Your homework one was due today, your homework two was
课后作业一今天截止，课后作业二

1757
01:12:28,395 --> 01:12:31,529
already posted, your reading assignment two was posted on
我也贴出来了，你们的阅读作业二会在

1758
01:12:31,531 --> 01:12:35,165
Monday, all that stuff is due next Wednesday.
（下）周一贴上来，然后所有的东西下周三截止

1759
01:12:35,167 --> 01:12:36,933
If you have any questions, I'm here.
如果你们有其他的疑问，欢迎来询问

1760
01:12:36,935 --> 01:12:42,405
[SOUND] For more, please visit us at stanford.edu.
更多课程，请访问 stanford.edu
