1
00:00:00,001 --> 00:00:04,636
[MUSIC]
音乐

2
00:00:04,638 --> 00:00:07,171
Stanford University.
斯坦福大学

3
00:00:09,809 --> 00:00:13,343
Okay, well welcome to CS193p, Winter 2015.
好的，热烈欢迎来到 CS193p 2015 冬季课程。

4
00:00:13,345 --> 00:00:15,445
This is Lecture NO.3.
这是第三堂课。

5
00:00:15,447 --> 00:00:17,714
This is gonna be all demo.
这节课将全部是演示。

6
00:00:17,716 --> 00:00:21,283
today, my voice is mostly recovered from last week,
跟上周比我今天的声音基本上恢复了，

7
00:00:21,285 --> 00:00:22,918
not 100% as you can tell.
但如你们听到的，我并没有完全恢复。

8
00:00:22,920 --> 00:00:23,985
But it's getting there.
但是差不多了。

9
00:00:25,455 --> 00:00:29,924
So what we're gonna be doing today is a demo.
好的，我们今天将要进行一个演示。

10
00:00:29,926 --> 00:00:31,825
We're gonna extend our calculator a little bit,
我们会给计算器加点东西，

11
00:00:31,827 --> 00:00:33,460
we're gonna make it more powerful.
让它功能更强大。

12
00:00:33,462 --> 00:00:36,629
But more importantly, we're gonna have it obey this MVC
更重要的是，我们将会让它遵从 MVC

13
00:00:36,631 --> 00:00:37,930
design paradigm.
设计范例。

14
00:00:37,932 --> 00:00:39,682
'Kay?
好么？

15
00:00:39,683 --> 00:00:41,433
So it's good, a pretty good example of showing how
因此，这是一个演示如何把（计算器里的）内容

16
00:00:41,436 --> 00:00:44,670
we're gonna separate the stuff into the camps here.
分成不同的部分（把 Model 从 View 中独立出来）的好例子。

17
00:00:44,672 --> 00:00:46,138
Now, we're gonna cover a bunch of other things,
现在我们要讲讲其他的，比如

18
00:00:46,140 --> 00:00:48,473
language features and stuff as I always do.
语言特性和用法这些惯例内容。

19
00:00:48,475 --> 00:00:52,143
That's really the primary goal of these first three lectures
这是前三节有演示的课的

20
00:00:52,145 --> 00:00:54,078
with the demo.
最主要的目标。

21
00:00:54,079 --> 00:00:56,012
So I just mean for you to see it in action because you can
我之所以将要向你们实时演示

22
00:00:56,015 --> 00:00:59,750
read all you want about Swift or, about iOS, but until you
是因为虽然你们能读到所有你们想读的关于 Swift 或者 iOS 的内容

23
00:00:59,752 --> 00:01:02,619
actually see it act, turning into an app, it's not real.
但直到你看到代码如何成为应用，才融会贯通。

24
00:01:02,621 --> 00:01:04,420
So I'm just trying to make it real for you.
因此我会试着将应用的编写的过程展示给你们。

25
00:01:06,057 --> 00:01:08,590
I'm going to go to my last slide, because,
我会讲完最后一张幻灯片, 因为,

26
00:01:08,592 --> 00:01:11,093
once I go to the demo, I'll forget to come back.
我一旦开始做演示就停不下来了。

27
00:01:11,095 --> 00:01:13,895
Which is just the what's coming up in this class.
这张幻灯片仅仅是说明接下来这门课要讲什么。

28
00:01:13,897 --> 00:01:17,031
On Wednesday, it's gonna be no demo, it's gonna be all
本周三没有课上演示，全是幻灯片，

29
00:01:17,033 --> 00:01:19,967
slides, it's going to be one of the few lectures where it's all slides
这种课不会多，但这节是其中之一。

30
00:01:21,186 --> 00:01:22,402
But what I'm gonna try to do,
我会尝试

31
00:01:22,405 --> 00:01:25,205
on Wednesday, is give you the highlights of this all
在周三的课上划出你们现阶段

32
00:01:25,207 --> 00:01:27,307
this reading that you're doing.
所学重点。

33
00:01:27,309 --> 00:01:28,658
Okay? Because you're
可以么？因为

34
00:01:28,659 --> 00:01:30,008
reading a lot of stuff and it's sometimes hard to
你们要读很多的东西，有时候区分

35
00:01:30,011 --> 00:01:32,611
tell what's really important in there and what's not.
哪些是重点哪些不是重点会比较困难。

36
00:01:32,613 --> 00:01:34,279
So I'm gonna kinda give you the highlights so
因此我会给你们划重点，

37
00:01:34,281 --> 00:01:36,448
you can get an idea of what's important.
这样你们会对重点内容有些概念。

38
00:01:36,450 --> 00:01:40,618
And then I'm also gonna start talking about some of
接着我会开始讲一些

39
00:01:40,620 --> 00:01:45,255
the foundation layer API in iOS that's the non,
iOS 中基础层的

40
00:01:45,257 --> 00:01:47,891
user interface layer basically and
非用户界面 API，大体上讲，

41
00:01:47,893 --> 00:01:51,227
kinda what some of the classes are in there.
和其中包含的一些类。

42
00:01:51,229 --> 00:01:54,130
And then also just a little bit of how we use the language
接着是一点点关于如何使用 iOS 中 Swift 语言特性

43
00:01:54,132 --> 00:01:57,099
features of Swift, and Foundation, in iOS so
和一些关于 Foundation 框架的东西。

44
00:01:57,101 --> 00:02:00,169
that you can kinda get this kind of your
这样在一定程度上，

45
00:02:00,171 --> 00:02:01,870
next Wednesday's lecture,
本周三的课，

46
00:02:01,872 --> 00:02:03,772
is gonna be your baseline lecture,
会成为你当做奠基的课程。

47
00:02:03,774 --> 00:02:07,241
can kinda get you grounded in how to do all this stuff.
你在一定程度会获得如何做这些东西的根基。

48
00:02:07,243 --> 00:02:10,044
And then next week we'll start diving in,
然后接下来一周我们开始深入，

49
00:02:10,046 --> 00:02:13,814
to build a more sophisticated iOS application.
写一个更成熟高端的 iOS 应用。

50
00:02:13,816 --> 00:02:15,682
Okay, I know this is kind of a whirlwind in first two
好的，我知道头两周会有些吃力，

51
00:02:15,684 --> 00:02:18,752
weeks, you're learning a new language, all new system.
你们将在其间学一门新的编程语言，一个全新的体系。

52
00:02:18,754 --> 00:02:20,920
But hopefully by the end of this week and the end of your
但是希望在这周以及

53
00:02:20,922 --> 00:02:24,757
second assignment which will go out on Wednesday you'll be
将在周三布置的第二个作业结束之后，

54
00:02:24,759 --> 00:02:26,225
pretty confident that you'll at least,
你能够比较确信，至少自己，

55
00:02:26,227 --> 00:02:30,595
you know, have a, solid ground foundation to build from,
额...有一个的坚实的基础。

56
00:02:30,597 --> 00:02:31,662
no pun intended there.
我不是在说笑。

57
00:02:33,032 --> 00:02:36,767
There's a holiday weekend this weekend no Friday section and
这周末有公众假期，所以这周五没课，

58
00:02:36,769 --> 00:02:39,603
no class on Monday until we resume next Wednesday, and
下周一也没课，直到下周三重新开始上课，

59
00:02:39,605 --> 00:02:42,305
the primary thing I'm gonna do next Wednesday,
下周三我的首要任务是

60
00:02:42,307 --> 00:02:44,341
not day after tomorrow but
不是后天的周三

61
00:02:44,342 --> 00:02:46,376
the next Wednesday, is talk a little more about AutoLayout.
是下周周三，是讲一些关于 AutoLayout 的内容。

62
00:02:46,378 --> 00:02:49,445
Cause you've only just seen kind of a glimpse of
因为到目前为止你们只是瞥见了一点关于

63
00:02:49,447 --> 00:02:51,013
AutoLayouts so far and
AutoLayout 的内容。

64
00:02:51,015 --> 00:02:53,849
I haven't even really told you how to do AutoLayout and so
我实际上并没有告诉你们如何做 AutoLayout

65
00:02:53,851 --> 00:02:55,383
you're kinda just fumbling around and trying,
你们差不多只是在摸索和尝试

66
00:02:55,385 --> 00:02:58,619
trying to reproduce what I do so next Wednesday we'll
重现我做过的内容，所以下周三

67
00:02:58,621 --> 00:03:01,588
talk about how to really do AutoLayout hm, and all that.
我们会讲如何做真正的 AutoLayout 和相关内容。

68
00:03:02,825 --> 00:03:05,225
'Kay, any questions before I dive into this demo?
好的，在我开始演示之前还有没有问题？

69
00:03:06,194 --> 00:03:10,396
Hopefully my voice will hold out I can already hear it
希望我的声音能坚持住，我已经感觉到

70
00:03:10,398 --> 00:03:14,065
starting to not hold out but we will see.
嗓子有些挺不住了，但是...看看吧。

71
00:03:14,067 --> 00:03:15,266
All right.
好的。

72
00:03:15,268 --> 00:03:21,839
So, I'm going to just go to Xcode here, launch Xcode.
嗯，我现在点这里的 Xcode，运行 Xcode。

73
00:03:22,941 --> 00:03:25,942
And we're gonna leave off right where we, were,
我们将继续上次课程，

74
00:03:25,944 --> 00:03:27,410
last time, in the calculator.
计算器程序的编写。

75
00:03:28,846 --> 00:03:32,681
There it is right here, and so these are UI.
都在这里了，这是 UI。

76
00:03:32,683 --> 00:03:34,783
Hopefully you recognize that and you did,
希望你们都认出来了并且

77
00:03:34,785 --> 00:03:36,051
did your homework.
做了作业。

78
00:03:36,053 --> 00:03:38,070
I hope.
我希望。

79
00:03:38,071 --> 00:03:40,088
And here is this area that I selected at the end,
这是我在代码尾部选中的区域，

80
00:03:40,090 --> 00:03:43,290
which is this area that's really has not,
这块区域并不是，

81
00:03:43,292 --> 00:03:47,928
this is not about how, how the calculator gets presented on
并不是负责计算器如何在屏幕上呈现的（并不是 Controller 的工作），

82
00:03:47,930 --> 00:03:51,064
screen, this blue area is about how the calculator is
这块蓝色的区域是关于这个计算器，

83
00:03:51,066 --> 00:03:52,165
a calculator, Okay?
为什么是个计算器（应该是 Model 的工作），可以么？

84
00:03:52,167 --> 00:03:54,367
This is where all our calculations are and
这里是存放运算的地方，

85
00:03:54,369 --> 00:03:57,302
this blue area really shouldn't be in this class,
这个蓝色区域不应该出现在这个类里,

86
00:03:57,304 --> 00:04:00,839
this ViewController class because this is the C
这个视图控制器类，因为这是我们 MVC 模型的中的 C

87
00:04:00,841 --> 00:04:01,973
of our MVC, Okay.
控制器（Controller），好么？

88
00:04:01,975 --> 00:04:06,910
And our MVC, this is the C, this is the V, the View,
我们的 MVC 模型，这是控制器（Controller），这是视图（View），

89
00:04:06,912 --> 00:04:09,546
these are the minions that this Controller's using.
它们是控制器使用的小兵们。

90
00:04:09,548 --> 00:04:11,948
And today we're gonna create the M.
今天我们将构建计算器的模型（Model）。

91
00:04:11,950 --> 00:04:13,349
Okay? The Model.
好么？模型。

92
00:04:13,351 --> 00:04:15,351
The Model is gonna be what our calcu,
这个模型将会决定我们的计（口误），

93
00:04:15,353 --> 00:04:18,854
what our application is, which is, it's a calculator.
我们的应用是什么，也就是一个计算器。

94
00:04:18,856 --> 00:04:20,155
'Kay?
好么？

95
00:04:20,157 --> 00:04:23,758
We're also going to enhance our calculator the primary new
我们将会加强这个计算器, 我们将赋予

96
00:04:23,760 --> 00:04:26,360
feature we're gonna give our calculator is that
它的首要新特性是

97
00:04:26,362 --> 00:04:30,030
our calculators Model is gonna remember every operand and
我们的计算器模型将会记住所有我们要求的

98
00:04:30,032 --> 00:04:32,833
operation you ever asked it to do.
操作数和操作符。

99
00:04:32,835 --> 00:04:38,271
Okay, so right now as we do operations we consume all
好的，现在当我们做运算的是时候我们假设我们用完了所有

100
00:04:38,273 --> 00:04:39,505
the operands.
操作数。

103
00:04:39,507 --> 00:04:41,040
'Kay, they consume, kinda, they're gone.
他们都用完了，没有了。

104
00:04:42,276 --> 00:04:43,792
So in this case,
所以在这种情况下，

105
00:04:43,793 --> 00:04:45,309
we're going to actually collect all the operations and
我们要收集所有在堆栈中的操作符和

106
00:04:45,312 --> 00:04:48,346
operands in our, in a stack and then we can
操作数，然后我们可以

107
00:04:48,348 --> 00:04:53,350
ask the Model to, evaluate that stack of operations and
要求我们模型，在任何时候求出我们

108
00:04:53,352 --> 00:04:55,385
operands at any time we want.
所有操作运算的值。

109
00:04:55,387 --> 00:04:57,654
And the reason we're adding that ability is because your homework,
我们增加这个功能的原因是因为你们的家庭作业，

110
00:04:57,656 --> 00:05:00,256
assignment number two, you're gonna add two
第二份作业，你需要添加两个

111
00:05:00,258 --> 00:05:03,726
major features where having all the operands and the
主要功能，它包括所有的操作数和操作符，

112
00:05:03,728 --> 00:05:06,628
operations in a stack is gonna be really valuable to you.
这将会对你很有用的。

113
00:05:06,630 --> 00:05:09,264
So you'll be starting your second homework with what I
所以你要开始做第二份作业，

114
00:05:09,266 --> 00:05:12,334
do today cause you'll need this capability to do what I
用我今天讲的东西，因为在里面你将会用到

115
00:05:12,336 --> 00:05:13,735
ask you there.
这些知识。

116
00:05:13,737 --> 00:05:14,902
Okay, and I'll talk about that at the end.
我会在结束的时候说一下这个问题。

117
00:05:14,904 --> 00:05:17,237
If I forget to talk about that, remind me.
如果我忘记说的话，提醒我一下。

118
00:05:17,239 --> 00:05:21,240
Say, tell us about assignment two. Okay.
就说和我们说一下第二份作业。

120
00:05:21,242 --> 00:05:22,908
So, how do we create a new class.
那么，我们怎么去创建一个新的类呢？

121
00:05:22,910 --> 00:05:25,911
Because we're gonna put our Model, 'kay, the calculator,
因为我们要把我们的模型，这个计算器，

122
00:05:25,913 --> 00:05:28,680
kind of, it, it's the guts, in a different class.
它的内脏，放在另一个类里面（不放在 Controller 里面）。

123
00:05:28,682 --> 00:05:31,983
So how do we create a new class, in Xcode.
那么，我们应该怎么用 Xcode 创建一个新的类？

124
00:05:31,985 --> 00:05:33,651
We do that up here from the File menu.
我们从这上面找到文件菜单。

125
00:05:33,653 --> 00:05:35,619
We go, New > File.
然后选择，New -> File。

126
00:05:35,621 --> 00:05:38,489
So, you're gonna do File menu > New > File for a lot of
所以你要使用 File -> New -> File

127
00:05:38,491 --> 00:05:41,291
different things you're gonna add to your project.
来为你的项目来添加很多各种不同的东西。

128
00:05:41,293 --> 00:05:43,693
Not even just, new classes or
不仅如此，新的类

129
00:05:43,695 --> 00:05:46,863
whatever, but, when you click that you're gonna see
或者随便什么，当你点击那里的时候你将会看到，

130
00:05:46,865 --> 00:05:48,497
there's a lot of different things you could add.
你可以添加很多不一样的东西。

131
00:05:48,499 --> 00:05:49,865
And, we're in iOS, so
我们现在做的是 iOS，所以

132
00:05:49,867 --> 00:05:52,267
you're gonna click on this iOS thing at the top.
你需要点击上面的 iOS

133
00:05:52,269 --> 00:05:53,635
And we wanna add a source file.
我们想要添加一个资源文件。

134
00:05:53,637 --> 00:05:56,671
And over here we're gonna be doing this later in the quarter,
在之后的学习中，我们将会添加这种文件，

135
00:05:56,673 --> 00:06:04,378
this is how we basically add subclasses of iOS classes, Co, Cocoa Touch classes.
我们主要用这种方式来添加 iOS 的类和 Cocoa Touch 的类的子类。

137
00:06:04,380 --> 00:06:06,446
But we're gonna do today this one Swift File,
但是今天我们添加一个 Swift 的文件，

138
00:06:06,448 --> 00:06:08,948
you can see it's an empty Swift File.
你可以看到这是一个空的 Swift 文件。

139
00:06:08,950 --> 00:06:11,517
And since our Model is completely UI independent it doesn't inherit,
因为我们的模型是一个完全和 UI 独立的类，它不需要继承，

140
00:06:11,519 --> 00:06:15,287
it doesn't subclass any iOS class or anything,
它不是 iOS 或者其他的类的子类，

141
00:06:15,289 --> 00:06:17,923
it's just a basic, Swift File.
它只是一个基本的 Swift 文件。

142
00:06:17,925 --> 00:06:19,824
So I'm gonna pick on this Swift File,
所以我要选中这个 Swift 文件，

143
00:06:19,826 --> 00:06:23,394
click Next, and now it wants to know the name of
点击下一步，现在它需要知道文件名

144
00:06:23,396 --> 00:06:26,564
it and where we wanna put it, and we're gonna put it in
和存放的位置，我们想把它放在

145
00:06:26,566 --> 00:06:29,466
the same place that all our other Swift files are.
和其他 Swift 文件相同的位置。

146
00:06:29,468 --> 00:06:30,901
Here's our Controller and
这是我们的 Contriller，

147
00:06:30,902 --> 00:06:32,335
this AppDelegate, we moved it out of the way at the very
这个 AppDelegate，在第一节课最开始的时候我们把它移出去了，

148
00:06:32,338 --> 00:06:34,571
beginning of the very first lecture but it's in there too.
但是它现在又在这里了。

149
00:06:34,573 --> 00:06:36,439
So we want to put it in this same directory.
所以我们想把它放在相同的路径下面。

150
00:06:36,441 --> 00:06:41,910
And we're gonna call this new class CalculatorBrain.
我们把这个新的类叫做 CalculatorBrain

151
00:06:41,912 --> 00:06:43,645
Now, you don't have to have the name of
在这里，你不用非得把这个 Swift 文件的名字

152
00:06:43,647 --> 00:06:47,048
this Swift File here be the name of the primary class but
写成和这个主类一样，

153
00:06:47,050 --> 00:06:48,049
we always do that.
但是我们一般都这么写。

154
00:06:48,051 --> 00:06:49,617
It would be kinda confusing to
如果 Swift 的文件名，

155
00:06:49,619 --> 00:06:52,019
people a little bit if the name of the Swift File
不同于这里面的任何的主类，

156
00:06:52,021 --> 00:06:54,554
was different than whatever the primary class is in there.
会让人有点困惑。

157
00:06:54,556 --> 00:06:55,755
But it's certainly legal.
但是它是完全合法的。

158
00:06:55,757 --> 00:06:56,422
All right.
好了。

159
00:06:56,424 --> 00:06:58,857
And Swift, the name of the file really doesn't mean anything.
而且在 Swift 中，文件名并不代表着什么。

161
00:06:58,859 --> 00:07:00,359
It's what's inside that matters.
它里面有什么才是主要的。

162
00:07:00,361 --> 00:07:04,929
But, CalculatorBrain is gonna be the name of our class, our Model.
但是，CalculatorBrain 将会是我们类和模型的名字，

164
00:07:04,930 --> 00:07:06,396
I'm calling it that cause it's the brain of our calculator,
我这么叫它是因为它是我们计算器的大脑，

165
00:07:06,399 --> 00:07:07,898
I'm trying to pick a descriptive name.
我尝试着取一个描述性的名字。

166
00:07:09,201 --> 00:07:12,302
Notice the capitalization here,
注意这里的大写，

167
00:07:12,304 --> 00:07:16,306
types in Swift, we always capitalize them.
Swift 里面的类型，我们一般都用大写（名字的第一个字母）。

168
00:07:16,308 --> 00:07:19,409
And we do not put underbars and other stuff in there.
我们不把下划线之类的东西放在这里。

169
00:07:19,411 --> 00:07:20,609
Okay? We use what's called this
在这里我们使用一个叫做

170
00:07:20,611 --> 00:07:25,380
camel notation here, where every word gets capitalized,
驼峰命名法（camel notation），每一个单词（第一个字母）都要有大写，

171
00:07:25,382 --> 00:07:27,882
including the first name, word for types.
包括名字和类型。

172
00:07:27,884 --> 00:07:31,219
Everything else, we don't capitalize.
其他的东西，我们都不用大写（第一个字母）。

173
00:07:31,221 --> 00:07:34,755
So property names and things like that, function names,
所有属性的名字和其他一些类似的，函数名，

174
00:07:34,757 --> 00:07:36,457
those all start with lower case,
这些都要开头都用小写，

175
00:07:36,459 --> 00:07:38,992
they still do the uppercase and the other words.
但是他们后面的单词的首字母要用大写。

176
00:07:38,994 --> 00:07:40,427
That way we, in our reading our code we
用这种方法，我们读代码的时候，

177
00:07:40,429 --> 00:07:43,196
can really quickly pick out what to type and what to not.
我们可以很快的找到我们想要的。

178
00:07:43,198 --> 00:07:45,164
'Kay? So please adhere to that.
所有请坚持这么写，

179
00:07:45,166 --> 00:07:48,334
If you don't, you're gonna look like a newb out there.
如果你不这么做的话，那你看起来就像一个新手了。

180
00:07:48,336 --> 00:07:49,501
'Kay. CalculatorBrain's what we're
好了，我们叫它 CalculatorBrain 的，

181
00:07:49,503 --> 00:07:50,835
gonna call it, I'm gonna create it.
下面我要开始创建它。

182
00:07:51,938 --> 00:07:53,121
Here it is right here.
这里。

183
00:07:53,122 --> 00:07:54,305
I'm gonna make it my whole screen.
我把它设置为全屏。

184
00:07:55,541 --> 00:07:58,975
You can see that the import here is not import UIKit,
你可以看到这里导入的库，但是没有导入 UIKit，

185
00:07:58,977 --> 00:08:00,477
it's import Foundation.
只导入了 Foundation。

186
00:08:00,479 --> 00:08:03,379
Foundation is that layer, that kinda core services layer I
Foundation 是一个核心的服务层，

187
00:08:03,381 --> 00:08:05,581
talked about in the first lecture.
在第一节课里我已经讲过了。

188
00:08:05,583 --> 00:08:07,883
It don't have many UI stuff in it which is good because our
它没有太多 UI 的东西，这是很好的，因为

189
00:08:07,885 --> 00:08:11,687
Model is UI independent so there should be no UI in here.
我们的模型是独立于 UI 的，所以这里应该没有 UI 的东西。

190
00:08:11,689 --> 00:08:17,392
So we would never be importing UIKit into a Model class, 'kay?
所以我们永远不要在模型类里导入 UIKit。

192
00:08:17,393 --> 00:08:18,826
You can feel free to stop me, by the way,
顺便说一句，你们可以随时让我停下来，

193
00:08:18,828 --> 00:08:19,793
if you have any questions.
如果你有任何的问题。

194
00:08:19,795 --> 00:08:22,095
All right, so we're gonna create a new class,
好，那么我们要创建一个新类，

195
00:08:22,097 --> 00:08:23,029
you already know how to do that.
你已经知道该怎么去做了。

196
00:08:23,031 --> 00:08:24,364
We just type class and
我们创建这个类，

197
00:08:24,366 --> 00:08:27,500
then the name of the class, it's gonna be CalculatorBrain.
然后给这个类取一个名字，我们就叫它 CalculatorBrain。

198
00:08:27,502 --> 00:08:32,537
Now, this class is not going to inherit from any other class,
现在，这个类不会继承其他的类，

200
00:08:32,539 --> 00:08:35,640
Just gonna be a basic Swift, class.
只是一个基本的 Swift 类。

201
00:08:35,642 --> 00:08:38,509
Now sometimes your Model might inherit from a class called
有时候你的模型会继承一个叫做

202
00:08:38,511 --> 00:08:40,861
NSObject, and
NSObject 的类，

203
00:08:40,862 --> 00:08:43,212
I'll talk about that a little later maybe on Wednesday even.
这个我后面会讲解，甚至可能在周三讲。

204
00:08:43,215 --> 00:08:46,683
You'll get a little bit if you inherit from NSObject, but
如果继承 NSObject，你将会得到一些（函数），但是

205
00:08:46,685 --> 00:08:50,587
we're just gonna have it be basic Swift base class, 'kay.
这里我们就用 Swift 基类。

206
00:08:50,589 --> 00:08:55,224
It doesn't, doesn't need to inherit any functionality. Okay.
它不需要继承任何功能函数。

208
00:08:55,225 --> 00:08:56,758
So what's gonna be our data structure of
所以，我们的 CalculatorBrain 的

209
00:08:56,761 --> 00:08:57,859
our CalculatorBrain.
数据结构是什么样的呢？

210
00:08:57,861 --> 00:08:59,961
It, it has to be a little different than the data
它必须有点不同于我们的

211
00:08:59,963 --> 00:09:01,662
structure we used in our Controller to
Controller 中用于捕获操作数的数据结构，

212
00:09:01,664 --> 00:09:04,565
capture the operand because we gotta capture operand,
因为我们得捕获操作数，操作符

213
00:09:04,567 --> 00:09:07,368
operations and operands both into this.
以及两者的运算。

214
00:09:07,370 --> 00:09:12,305
So we want it to be a stack, I'm gonna call it opStack and
所以，我们需要一个栈，我称之为 opStack，

215
00:09:12,307 --> 00:09:14,741
but the type can't be array of Double.
但是这个类型不能是 Double 数组。

216
00:09:15,743 --> 00:09:20,245
Okay, because operands are Doubles but operations
因为操作数是 Doubles，但操作符则像

217
00:09:20,247 --> 00:09:23,648
are like a combination of a syn, a mathematical symbol
一种符号的结合，一个数学符号。

218
00:09:23,650 --> 00:09:26,651
like plus, times and then also a function.
比如相加，相乘，当然也包括函数。

219
00:09:26,653 --> 00:09:29,186
Function that actually does the thing, 'kay?
函数实际上也是同样的东西。

220
00:09:29,188 --> 00:09:30,888
So obviously we can't do that so
所以显然，我们不能这么做，

221
00:09:30,890 --> 00:09:32,022
we're gonna have to need some,
我们需要一些，

222
00:09:32,024 --> 00:09:34,691
some new data structure I'm gonna call that data
新的数据结构，我叫这种数据结构

223
00:09:34,693 --> 00:09:37,760
structure op and we're gonna define that in a second.
为 op，我们随后就定义这个结构。

224
00:09:37,762 --> 00:09:41,663
So op is gonna be something that could be an operand or
所以 op 可能是操作数，

225
00:09:41,665 --> 00:09:43,532
maybe it could be an operation.
也可能是操作符。

226
00:09:43,534 --> 00:09:47,519
'Kay? It could be either or. 'Kay?
它可能是两者中的任一种

228
00:09:47,520 --> 00:09:49,804
Now a couple of things about this here is of course I
现在有几件事情要做，当然，

229
00:09:49,806 --> 00:09:51,572
have to initialize this so I'm gonna do
我需要初始化，

230
00:09:51,574 --> 00:09:54,575
the exact same thing that I did in the Controller which is
我将做在 Controller 中同样的事情，

231
00:09:54,577 --> 00:09:59,496
I'm just gonna create an empty array of op. 'Kay?
那就是我要创建一个新的 op 数组，

233
00:09:59,497 --> 00:10:02,181
And I'm even gonna use a little different syntax, 'kay?
我甚至要用一点不一样的语法，

234
00:10:02,183 --> 00:10:03,382
We've been using this.
我们使用这个，

235
00:10:03,384 --> 00:10:05,851
I like this syntax because especially for
我喜欢这个语法，特别是对于

236
00:10:05,853 --> 00:10:08,553
people who are first time to Swift it's very clear,
那些初次接触 Swift 的同学，它非常清晰，

237
00:10:08,555 --> 00:10:12,624
this is an array and inside the array are these ops but
这是一个数组，在数组中，是这些 op，

238
00:10:12,626 --> 00:10:17,661
this is evidently not the syntax that is preferred.
但这明显并不是推荐使用的语法，

239
00:10:17,663 --> 00:10:23,433
The preferred syntax is actually to do [Op] 'kay?
推荐的语法实际上是使用 [Op]。

240
00:10:23,435 --> 00:10:27,070
So this is just an alternate syntax, putting square
这是另一种可选择的语法，把类型放在

241
00:10:27,072 --> 00:10:29,739
brackets with the type in the middle for declaring an array.
方括号中，这样就声明了一个数组。

242
00:10:29,741 --> 00:10:32,008
It's exactly the same thing just different way of
这是一样的东西，只是不一样的方式，

243
00:10:32,010 --> 00:10:34,276
typing in, identical in every possible way,
写法不一样，但其他都一样。

244
00:10:34,278 --> 00:10:37,062
it's exactly the same. Okay.
真的是相同的东西。

246
00:10:37,063 --> 00:10:38,346
I think this is a little bit preferred because if
我认为这是更好的方式因为

247
00:10:38,348 --> 00:10:41,449
you ever initialize an array which will see later.
如果你曾初始化过数组，你就会明白的。

248
00:10:41,451 --> 00:10:43,884
You use this syntax to create the array and
你使用这种语法创建数组，

249
00:10:43,886 --> 00:10:45,686
put things in it.
并将东西放在其中。

250
00:10:45,687 --> 00:10:47,487
So I, I can understand why they do that.
所以我很理解他们这样做的原因。

251
00:10:47,490 --> 00:10:50,257
Okay? So this is an array of op.
这是一个 op 数组。

252
00:10:50,259 --> 00:10:50,924
That make sense?
这很容易理解。

253
00:10:51,860 --> 00:10:53,859
Now, let's talk about op.
现在，让我们说说 op。

254
00:10:53,861 --> 00:10:55,094
What kinda thing should op be?
op 是什么东西呢？

255
00:10:55,096 --> 00:10:57,596
Well, we could make op a class.
好吧，我们可以将 op 变成一个类。

256
00:10:57,598 --> 00:10:59,731
An op could have a property for op,
然后 op 应当有这些属性，

257
00:10:59,733 --> 00:11:02,033
for an operand, which would be the value of the operand.
操作数，也就是操作数的值。

258
00:11:02,035 --> 00:11:05,169
It could have another property, which is the,
他还应该有另一个属性，那就是，

259
00:11:05,171 --> 00:11:07,371
symbol, mathematical symbol for the operation and
符号，用于运算的数学符号，

260
00:11:07,373 --> 00:11:10,173
another property, which was a function, which does it,
还有个属性，函数，用于实现计算，

261
00:11:10,175 --> 00:11:12,509
and obviously, if the operand is set,
很明显，如果一个操作数被赋值了，

262
00:11:12,511 --> 00:11:15,144
then the other two would be not set and vice versa.
那另两个（操作符和函数）就不会被赋值，反过来也一样。

263
00:11:15,146 --> 00:11:18,481
But that, that's a little bit weird to have a class that
但这样就有些奇怪，一个类拥有一些

264
00:11:18,483 --> 00:11:21,250
has properties that sometimes they're set and,
属性，有时他们被赋值了，

265
00:11:21,252 --> 00:11:23,218
and if other things are set, they're not set.
但其他东西被赋值了，他们却没有值了。

266
00:11:23,220 --> 00:11:24,285
It's really not what we want.
这不是我们想要的。

267
00:11:24,287 --> 00:11:27,621
What we really want is an enum.
我们需要的是枚举类型。

268
00:11:28,591 --> 00:11:31,658
Okay, so you're probably used to enums in other languages so
你可能在其他编程语言中使用过枚举，

269
00:11:31,660 --> 00:11:32,959
I'm gonna create an enum,
所以我将创建一个枚举，

270
00:11:32,961 --> 00:11:35,728
[UNKNOWN] enum, it looks very similar creating a class.
和创建一个类类似。

271
00:11:35,730 --> 00:11:38,397
I just use the word enum instead of class,
我使用 enum，而不是 class。

272
00:11:38,399 --> 00:11:41,633
obviously no inheritance for enum, sorry.
显然，枚举没有继承特性。

273
00:11:41,635 --> 00:11:45,537
But enums can have functions, just like the class,
但枚举和类一样，有函数，

274
00:11:45,539 --> 00:11:49,474
they can also have properties but only computed properties.
他们也有属性，但只能是计算类属性。

275
00:11:49,476 --> 00:11:51,242
'Kay, the Camry's stored properties.
Camry 存储属性。

276
00:11:52,278 --> 00:11:55,779
So you know enums are kinda for basic types and
你们知道枚举是基本类型，

277
00:11:55,781 --> 00:11:58,782
enums are really great when you have something that can be
枚举非常棒，特别是你有一些东西，在某个

278
00:11:58,784 --> 00:12:01,317
one thing one time and a different thing another time.
时候有一个值，在别的一些时候有另外的值。

279
00:12:01,319 --> 00:12:02,585
And never both at the same time,
但不会同时拥有两个值。

280
00:12:02,587 --> 00:12:03,952
that's kinda what enums are right,
这样，使用枚举是对的，

281
00:12:03,954 --> 00:12:06,421
they're enumerating different possibilities so
它们枚举不同的可能性，所以

282
00:12:06,423 --> 00:12:09,257
we could say you know case Operand and we could have
我们可以写"case Operand"，同样我们也可以写

283
00:12:09,259 --> 00:12:15,563
a case Operation, to have the different things that we have.
"case Operation"，去表达我们拥有的不同的东西。

284
00:12:15,565 --> 00:12:19,133
Now, in other languages, this would be as far as we can go.
在其他编程语言中，这就是我们所能做的最多的了。

285
00:12:19,135 --> 00:12:21,101
And this would be pretty useless.
然后这也是相当没用的，

286
00:12:21,103 --> 00:12:24,270
Because if we had an array that just said whether it
因为如果我们有一个数组，他可能是一个

287
00:12:24,272 --> 00:12:26,105
was an operand or an operation, that doesn't help.
操作数，或者操作符，这没有任何帮助。

288
00:12:26,107 --> 00:12:27,973
I need the actual operand.
我需要一个实际的操作数。

289
00:12:27,975 --> 00:12:30,242
I need the operations mathematical symbol and
我需要的是数学符号，还有

290
00:12:30,244 --> 00:12:31,977
its function.
它的函数。

291
00:12:31,978 --> 00:12:33,711
I need them, they have to be in this enum.
我需要它们，它们要在这个枚举（enum）中。

292
00:12:33,714 --> 00:12:36,448
And Swift has a really cool feature where you can
Swift 有一个非常酷的特性，你们可以

293
00:12:36,450 --> 00:12:41,085
associate data with any of the cases in the enum.
将数据和任何 case 中的枚举关联起来。

294
00:12:41,087 --> 00:12:44,021
So for an operand I'm gonna associate the data Double.
所以对于一个操作数，我将关联 Double 数据。

295
00:12:45,123 --> 00:12:48,157
So if my enum is an operand it'll have this
所以如果我的枚举是一个操作数，它将有这个

296
00:12:48,159 --> 00:12:49,558
Double associated with it,
和它关联的 Double 数据，

297
00:12:49,560 --> 00:12:52,194
that's gonna be the value of the operand.
这将是这个操作数的值。

298
00:12:52,196 --> 00:12:54,013
And similarly for
类似地，

299
00:12:54,014 --> 00:12:55,831
operation I'm actually gonna do unary operation first,
对于操作符，我实际上首先使用一元操作（比如平方，开方等），

300
00:12:55,833 --> 00:12:57,866
that's a single argument operation.
这是单个参数的运算。

301
00:12:57,868 --> 00:13:00,768
I'm gonna have a String which is gonna be the symbol,
首先我需要用一个字符串来表示符号，

302
00:13:00,770 --> 00:13:01,936
the mathematical symbol for
数学运算符

303
00:13:01,938 --> 00:13:04,238
it and of course I'm gonna have a function.
我当然还需要一个函数来做这个运算

304
00:13:05,341 --> 00:13:08,408
Okay again functions are just types in Swift,
再重提一遍，函数在 Swift 里也是一种类型，

305
00:13:08,410 --> 00:13:11,344
it's no different than String 'kay we're just saying this is
与字符串相比并没有任何的不同，我们只需要知道

306
00:13:11,346 --> 00:13:13,612
a function, put a function in there.
这是个函数，放在这就好了

307
00:13:13,614 --> 00:13:15,147
A lot of times we'll do the curly braces and
很多时候在这里我们会通过用花括号

308
00:13:15,149 --> 00:13:17,883
put a closure use closures to create our function but
写一个闭包来实现这个函数，

309
00:13:17,885 --> 00:13:19,584
we could create actual functions and
但是我们也可以通过在其他地方写一个真正的函数

310
00:13:19,586 --> 00:13:21,185
pass them in there, that's fine.
然后传递进来，也是没有问题的

311
00:13:21,187 --> 00:13:25,289
So, and we'd also want a binary function here that takes two arguments.
继续，我们还需要一个有 2 个参数的二元运算函数，

313
00:13:26,959 --> 00:13:28,625
Binary operation and
二元运算，然后

314
00:13:28,627 --> 00:13:34,296
just those two arguments here in it's function. Okay?
在里面加一个带 2 个参数的函数

316
00:13:34,297 --> 00:13:37,499
So now we have the stack. Okay. Which is an array of Ops.
我们这里还有一个栈，是由 Op 组成的数组

318
00:13:37,501 --> 00:13:41,369
And these ops are either each op in this, is array is either
这个数组的元素要么是一个操作数，

319
00:13:41,371 --> 00:13:44,638
an operand or it's one of these two kinds of operations.
要么是刚才这个枚举里两种运算中的一种

320
00:13:46,308 --> 00:13:49,142
Okay so so this is great.
很好

321
00:13:49,144 --> 00:13:53,979
We got this op it's either an operation or an operand.
我们现在有了 Op，它是操作数或者是运算

322
00:13:53,981 --> 00:13:59,251
How are we going to, you know, put things into this opStack for example and something like that.
下边我们要做的是往 opStack 这个数组里放东西


324
00:13:59,253 --> 00:14:01,653
So let, let's go talk about, the API.
这里简单说一下 API

325
00:14:01,655 --> 00:14:05,356
A, API stands for application programing interface.
API 指的是应用程序接口

326
00:14:05,358 --> 00:14:09,060
API is kind of the methods, all the methods and properties
API 就是组成你的类里边所有属性


327
00:14:09,062 --> 00:14:13,230
that make up your class, the description of them.
和方法的描述

328
00:14:13,232 --> 00:14:16,066
So I'll use that word a lot, API.
我之后会经常提到这个词

329
00:14:16,068 --> 00:14:18,835
And we really need to be able to put an operand on there and
现在我们需要想办法往 opStack 这个栈里压入

330
00:14:18,837 --> 00:14:20,736
stack, and we need to be able to put an operation on.
操作符和运算

331
00:14:20,738 --> 00:14:24,573
So I'm gonna have a function called pushOperand, and
所以我写一个叫 pushOperand 的函数，

332
00:14:24,575 --> 00:14:27,809
it's gonna take an operand, which is a Double.
需要传入一个 Double 类型的参数作为操作数

333
00:14:27,811 --> 00:14:30,578
Okay it's not gonna return anything yet anyway.
不需要返回值

334
00:14:30,580 --> 00:14:33,715
And to push an operand on my stack, could not be easier,
要把一个操作数压进栈非常简单，

335
00:14:33,717 --> 00:14:36,217
I'm just gonna say opStack.append,
 我只需要写 opStack.append,

336
00:14:36,219 --> 00:14:42,355
you'll remember that append is a function in array and the thing that you put on,
要记住 append 是数组从尾部添加元素的函数，


338
00:14:42,357 --> 00:14:45,858
obviously has to be this little type T.
这有一个类型 T，

339
00:14:45,860 --> 00:14:48,627
T is whatever you put in here, so op in this case.
T 代表你添加到数组里的类型，在这里是Op

340
00:14:48,629 --> 00:14:50,729
So we have to have an op here.
我们要加一个 Op 进去

341
00:14:50,731 --> 00:14:52,964
How do you create an enum item?
我们怎么新建一个枚举项呢？

342
00:14:52,966 --> 00:15:01,539
You just Op.Operand and you give it the associated value. Okay？
只需要写 Op.Operand 然后给它一个相关值

344
00:15:01,541 --> 00:15:10,013
So, very simple kind of way to create these enums and associate the value with them.
看，新建枚举项以及他们的相关值非常简单

346
00:15:10,015 --> 00:15:11,114
Any questions about that?
这里有问题吗？

347
00:15:12,450 --> 00:15:13,749
Okay, and then how about operations?
好，那运算呢？

348
00:15:13,751 --> 00:15:15,384
We'll have instead of push,
我们这次不写 push，

349
00:15:15,386 --> 00:15:18,720
we're gonna call this performOperation.
而是写一个叫 performOperation（执行运算）的函数

350
00:15:18,722 --> 00:15:20,922
And I think when I do performOperation, what I'm
并且我希望当我执行 performOperation 的时候，

351
00:15:20,924 --> 00:15:23,024
gonna have is, my CalculatorBrain is going to have
我的 CalculatorBrain 类已经有一些

352
00:15:23,026 --> 00:15:26,493
a bunch of known operations, things it knows how to do.
已知的运算以及他们具体的运算方法

353
00:15:26,495 --> 00:15:27,861
And when you perform an operation,
然后当你执行一个运算的时候，

354
00:15:27,863 --> 00:15:30,697
you just specify the mathematical symbol of it.
你只需要写出它的数学符号就可以了

355
00:15:30,699 --> 00:15:36,301
So the argument here is going to be symbol, which is a String.Okay?
所以这个函数的参数是一个数学符号，也就是字符串

358
00:15:36,303 --> 00:15:41,306
So, to append an op on here that is, an operation,
我们要把运算，也就是一个 Op 压进栈，

359
00:15:41,308 --> 00:15:43,274
I'm gonna need to have these known operations.
我需要用到已知的运算

360
00:15:43,276 --> 00:15:44,775
So, how am I gonna do that?
要怎么做呢？

361
00:15:44,777 --> 00:15:47,878
Well, to have known operations, I'm gonna create
我们要新建另外一个实例变量 knownOps 作为

362
00:15:47,880 --> 00:15:51,048
another instance variable here called knownOps, so
存储已知运算的地方

363
00:15:51,050 --> 00:15:55,251
my known operations. And it's gonna be a dictionary.
这些已知的运算，是一个字典类型

365
00:15:55,253 --> 00:15:58,987
Okay, now, you read about dictionaries in last week's reading assignment.
上周的阅读材料里你们应该已经读到过字典类型了

367
00:15:58,989 --> 00:16:00,489
That's why I have the reading assignment due today.
这就是为什么今天是阅读材料的截止日期，

368
00:16:00,491 --> 00:16:02,257
Cuz then I can know you've read about them.
这样我就能知道你们已经读过了

369
00:16:02,259 --> 00:16:02,824
I hope you have.
希望你们确实读了

370
00:16:05,495 --> 00:16:07,428
And so, how do I create a dictionary?
我们如何新建一个字典？

371
00:16:07,430 --> 00:16:08,995
It looks like this,  Dictionary.
像这样

372
00:16:08,997 --> 00:16:11,531
And it's the same kind of thing with these angled
同样是使用尖括号，

373
00:16:11,533 --> 00:16:14,434
brackets, because you have to say for the dictionary,
你必须为字典

374
00:16:14,436 --> 00:16:17,036
what type are the keys, what type are the values.
建立相对应的键值关系

375
00:16:17,038 --> 00:16:20,506
And our dictionary is gonna have keys that are Strings and
在这里，键是字符串

376
00:16:20,508 --> 00:16:22,874
it's gonna have values that are ops.
值的类型是 Op

377
00:16:22,876 --> 00:16:26,478
Oops, sorry, ops.
哦，对不起，Op

378
00:16:26,480 --> 00:16:29,947
Okay, and I'm gonna create one. Okay?
好，新建了一个字典

380
00:16:29,949 --> 00:16:32,316
Everyone understand this?
大家都明白这个了吗？

381
00:16:32,317 --> 00:16:34,684
Now, this knownOps, I'm just gonna put all of the ops that
现在在这个 knownOps 变量里，我要把所有

382
00:16:34,687 --> 00:16:38,955
I know in there, where the key is the symbol and the value is
我知道的运算放进去，键是符号

383
00:16:38,957 --> 00:16:42,392
the actual op, and then when someone says performOperation,
值是实际的 Op 也就是运算方法，每次我要执行 performOperation 时，

384
00:16:42,394 --> 00:16:44,527
I'm gonna look it up in the knownOps.
我会去 knownOps 里去找那些已知的运算

385
00:16:44,529 --> 00:16:47,329
And when I find it, then that's the operation I'm
当我找到的时候，我就要把这个

386
00:16:47,331 --> 00:16:49,531
gonna push onto the stack, all right?
运算压到 opStack 这个栈里

387
00:16:49,533 --> 00:16:51,183
Make sense?
能明白吗？

388
00:16:51,184 --> 00:16:52,834
But I have to load this knownOps up.
但是我需要预先载入 knownOps

389
00:16:52,836 --> 00:16:55,903
Oh, but first of all, so let me talk about this syntax.
哦，首先，我要说一下这个语法

390
00:16:55,905 --> 00:17:00,941
Just like array has a special syntax with the square brackets, so does dictionary.
跟前边数组使用方括号的特殊语法一样，字典也可以这么写

392
00:17:00,943 --> 00:17:03,510
So to have a dictionary like this with this kind of
如果字典用这种写法，

393
00:17:03,512 --> 00:17:07,080
special syntax, we're gonna do open square bracket.
我们需要用方括号，

394
00:17:07,082 --> 00:17:12,752
And then a colon in between the key and
然后中间用冒号隔开键和值，

395
00:17:12,754 --> 00:17:15,254
the value type, so it looks like that.
就像这样

396
00:17:15,256 --> 00:17:17,789
So it looks very similar to array, but
跟数组很像，但是

397
00:17:17,791 --> 00:17:22,660
you've got this thing where you've got the key and the value separated by a colon. Okay？
你需要用冒号把键和值分隔开

400
00:17:23,796 --> 00:17:25,429
Same thing, though, exact same thing.
其实是完全一样的

401
00:17:25,431 --> 00:17:27,430
Just a dictionary, Strings,
仅仅是字典，字符串，

402
00:17:27,432 --> 00:17:28,698
looking up in Strings to find ops.
用字符串找 op

403
00:17:28,700 --> 00:17:32,701
All right, so how am I gonna initialize this knownOps?
好，那我们怎么初始化这个已知的 op

404
00:17:32,703 --> 00:17:33,869
Well, this is a great time for
这是我们

405
00:17:33,871 --> 00:17:37,906
the first time for you see an initializer, Okay?
第一次提到 initializer

406
00:17:37,908 --> 00:17:41,876
So far we've been creating classes like right here, Okay,
到此，我们已经通过加括号

407
00:17:41,878 --> 00:17:44,311
just by putting these parentheses.
创建了一个像这样类。

408
00:17:44,313 --> 00:17:46,680
And I told you that was calling an initializer in
这就是在调用字典的 initializer ，

409
00:17:46,682 --> 00:17:47,947
Dictionary, Okay, and
好的，

410
00:17:47,949 --> 00:17:50,817
this one was calling an initializer in Array.
这是在调用数组的 initializer

411
00:17:50,819 --> 00:17:52,585
And so we're gonna have our own initializer in
然而，我们会为 CalculatorBrain 设置自己的 initializer

412
00:17:52,587 --> 00:17:55,421
CalculatorBrain, and
并且

413
00:17:55,422 --> 00:17:58,256
we just do that by saying init, like this, Okay.
通过像 init 这样的形式

414
00:17:58,258 --> 00:18:01,726
Now any time someone says something like let brain equal
现在不论何时 使用 let brain = CalculatorBrain()

415
00:18:01,728 --> 00:18:05,296
CalculatorBrain, with the parentheses, Okay?
得加上括号。

416
00:18:05,298 --> 00:18:07,531
It's going to call an init that
就会调用匹配对应

417
00:18:07,533 --> 00:18:09,667
matches the same arguments.
参数的 init 方法

418
00:18:09,669 --> 00:18:11,668
In this case, no arguments, so it's gonna call this init.
在这里，没有参数，所以将会调用这个 init 方法

419
00:18:13,505 --> 00:18:14,070
Okay.

420
00:18:15,439 --> 00:18:16,838
Couldn't be simpler there.
就是这么简单

421
00:18:16,840 --> 00:18:18,173
So what are we gonna do in this init?
那我们要在这个初始化方法里做什么呢？

422
00:18:18,175 --> 00:18:20,375
We're just gonna initialize this known op, so
我们将要初始化 op

423
00:18:20,377 --> 00:18:24,545
I'm just gonna start putting some known ops into this
于是，加入一些已知的 op

424
00:18:24,547 --> 00:18:26,780
knownOps dictionary.
到 op 的字典里

425
00:18:26,782 --> 00:18:31,617
We need our friend special characters here for that.
我们需要刚才用过的特殊字符

426
00:18:31,619 --> 00:18:34,253
So let's go ahead and
让我们继续

427
00:18:34,254 --> 00:18:36,888
put, well, let's put times here first, I guess.
先加入乘法

428
00:18:36,891 --> 00:18:39,257
Okay, and we need to create an operation.
再创建一个操作

429
00:18:39,259 --> 00:18:40,392
How do we create an operation?
怎么创建一个操作呢？

430
00:18:40,394 --> 00:18:43,461
Very similar to how we created this enum.
跟我们创建这个枚举很像

431
00:18:43,463 --> 00:18:47,431
Op, dot, and times is a binary operation.
op，点，乘法是一个二元操作符

432
00:18:47,433 --> 00:18:49,566
And you can see that it's typing this for me.
自动为我补全了

433
00:18:49,568 --> 00:18:51,735
I'm just pressing Tab to get along.
按 Tab 继续

434
00:18:51,737 --> 00:18:56,105
This is the symbol, which is this thing here.
这是这里的符号

435
00:18:56,107 --> 00:18:58,908
Now, this is kinda bad code that I ended up
现在，我完成一个糟糕的代码

436
00:18:58,910 --> 00:19:00,809
typing this twice in the same line.
同一行输入了这段两次

437
00:19:00,811 --> 00:19:03,378
If I accidentally use the wrong x,
假如不小心输错 x

438
00:19:03,380 --> 00:19:06,881
like some x from somewhere else or the x just from my
比如 x 来自别的地方或者

439
00:19:06,883 --> 00:19:10,451
keyboard might be different from this x, than this x, ugh,
我键盘的 x 不同于这个 x

440
00:19:10,453 --> 00:19:12,920
we could get in trouble where these things don't match up.
万一它们不匹配，我们就会遇到问题

441
00:19:12,922 --> 00:19:15,489
So later, in the, right at the very end of the demo,
晚点在演示快结束的时候，

442
00:19:15,491 --> 00:19:16,857
I'm gonna show you how we could do this in
我会向你展示

443
00:19:16,859 --> 00:19:20,960
a way where we don't have to type this x twice like that.
不需要像这样输入两次 x 的方法

444
00:19:20,962 --> 00:19:22,161
Okay.

445
00:19:22,162 --> 00:19:23,361
But now we just need the function.
但是现在我们只需要这个方法

446
00:19:23,364 --> 00:19:25,230
We know how to do that with closures.
我们知道如何用闭包实现

447
00:19:25,232 --> 00:19:27,866
We say $0 times $1.
用 $0 * $1

448
00:19:27,868 --> 00:19:29,000
End the closure.
结束闭包

449
00:19:29,002 --> 00:19:31,736
And yes, I could put this closure outside,
当然，这是最后，于是我也可以把闭包放到外面

450
00:19:31,738 --> 00:19:33,838
since it's the last thing here.
因为这个闭包在代码结尾处

451
00:19:33,840 --> 00:19:37,107
That is also legal to do when you're creating
当你创建这样的操作时，

452
00:19:37,109 --> 00:19:39,109
the operations like this.
也是合法的。

453
00:19:39,111 --> 00:19:40,310
'Kay?

454
00:19:40,312 --> 00:19:41,377
So that's kinda nice.
这看上去很棒吧。

455
00:19:41,379 --> 00:19:44,880
Let's do our other three binary operations here.
让我们来加入另外三种二元操作

456
00:19:44,882 --> 00:19:46,982
We'll go divide.
除法

457
00:19:46,984 --> 00:19:49,784
And this is where it really gets annoying to have to
这就是非得输入两遍

458
00:19:49,786 --> 00:19:51,736
type it twice.
的烦人的地方

459
00:19:51,737 --> 00:19:53,687
But I have to show you something else before I can
但是在这之前，

460
00:19:53,690 --> 00:19:56,357
show you how to do that right.
我得给你们演示一下别的。

461
00:19:57,726 --> 00:19:58,591
Let's go here.
从这里开始

462
00:19:58,593 --> 00:20:02,362
And there we have minus.
这里我们有减法

463
00:20:02,364 --> 00:20:04,997
You can see there's two different minuses there, so
你可以看到有两种减法

464
00:20:04,999 --> 00:20:07,866
hopefully I clicked the same minus in both those spots.
我在这两处都点了同一个减法符号

465
00:20:07,868 --> 00:20:09,434
And then we change these things.
改一下这里

466
00:20:09,436 --> 00:20:13,671
We know that divide is 1 divided by $0, and
除法是用 $1 除以 $0

467
00:20:13,673 --> 00:20:15,106
this is plus.
加法

468
00:20:16,742 --> 00:20:21,678
And this is 1 minus 0, $1 minus $0, Okay, so
减法 $1 - $0

469
00:20:21,680 --> 00:20:23,813
everyone cool here?
大家跟得上吧？

470
00:20:25,350 --> 00:20:27,483
These enums are really easy to create.
枚举简单地就能创建

471
00:20:27,485 --> 00:20:31,920
The API of them is really, really nice, simple.
它们的接口非常简单、漂亮

472
00:20:31,922 --> 00:20:34,055
And then we have our other operation,
接下来我们来看看其它操作

473
00:20:34,057 --> 00:20:37,058
which is our unary operation, which is square root.
一个一元操作符——开方

474
00:20:37,060 --> 00:20:40,861
So let's put that in here, square root is right here.
那那个放这，开方放这

475
00:20:40,863 --> 00:20:43,830
And we'll put it right here.
把它放这里

476
00:20:45,266 --> 00:20:48,267
And square root is not a binary operation it's
开方不是一个二元操作符，

477
00:20:48,269 --> 00:20:49,601
a unary operation.
而是一元操作符

478
00:20:49,603 --> 00:20:53,738
Oops, look at all this.
看这

479
00:20:53,740 --> 00:20:56,591
'Kay?

480
00:20:56,592 --> 00:20:59,443
And of course, inside here, it's square root of $0.
当然，这里，它是 $0 的平方根

481
00:20:59,445 --> 00:21:01,745
Okay, you remember that from last time.
跟之前说的一样

482
00:21:01,747 --> 00:21:02,879
So this is good.
不错

483
00:21:02,881 --> 00:21:04,864
Now, while I'm here,
这里

484
00:21:04,865 --> 00:21:06,848
I wanna show you a couple things more about closures.
我再给大家介绍一些闭包相关的东西

485
00:21:06,851 --> 00:21:07,950
Okay.

486
00:21:07,952 --> 00:21:10,052
This, what is this curly brace?
看这里，这个大括号是什么？

487
00:21:10,054 --> 00:21:12,721
It's a function that takes one argument and
这是一个接受一个参数，

488
00:21:12,723 --> 00:21:14,356
returns one argument.
返回一个参数的函数

489
00:21:14,358 --> 00:21:16,308
And we know that
我们知道

490
00:21:16,309 --> 00:21:18,259
it's Doubles because we're creating a unary operation.
我们创建一元操作，所以是 Double

491
00:21:18,261 --> 00:21:21,962
And so, it's inferring the type here, right?
于是，它推出这里的类型，对吧？

492
00:21:21,964 --> 00:21:23,530
Everyone understand that?
大家都能理解吗？

493
00:21:23,532 --> 00:21:27,133
Well, there's another function that returns a function, or
这里有另外一个函数返回一个函数，或者

494
00:21:27,135 --> 00:21:28,901
there's another function that takes a Double and
一个函数接受一个 Double

495
00:21:28,903 --> 00:21:31,570
returns a Double, that does square root,
返回一个开方后的 Double

496
00:21:31,572 --> 00:21:33,772
it's called square root.
称作 sqrt

497
00:21:33,774 --> 00:21:36,941
So inside here, we could just say square root.
所以这里，我们可以就说 sqrt

498
00:21:38,178 --> 00:21:40,811
Okay, we don't even need this business.
甚至不需要这个

499
00:21:42,881 --> 00:21:44,080
Just wanna emphasize that
需要强调的是

500
00:21:44,082 --> 00:21:45,515
we're just passing a function here.
我们在这里传入了一个函数

501
00:21:45,517 --> 00:21:47,450
And it can be a named function, or
它可以是一个被命名的函数

502
00:21:47,452 --> 00:21:49,518
we could use these curly braces.
或者可以用花括号

503
00:21:49,520 --> 00:21:52,754
Now, this is really gonna freak you out, cuz watch this.
现在，让你惊讶的事来了，看好了

504
00:21:52,756 --> 00:21:57,091
For times, there's a function that does times called times.
对于乘法，有一个做乘法运算的函数就叫做“*”

505
00:21:58,728 --> 00:22:00,728
Okay.

506
00:22:00,729 --> 00:22:02,729
So in Swift, all these operators, times and
在 Swift 里，所有的操作符，乘号等等

507
00:22:02,732 --> 00:22:04,664
all these things, are just functions.
都是函数

508
00:22:04,666 --> 00:22:06,966
They just happen to be specified in a way that says
只不过它们刚好以某种方式规定了

509
00:22:06,968 --> 00:22:09,068
that they can be infix, right, between the two
可以插入到两个参数之间

510
00:22:09,070 --> 00:22:11,370
arguments instead of taking the arguments in parentheses.
而不需要从圆括号里获取参数

511
00:22:11,372 --> 00:22:13,138
And we do the same thing here with plus.
然后我们对加法做同样的事

512
00:22:14,641 --> 00:22:16,074
All right, plus.
好的，加号

513
00:22:16,076 --> 00:22:17,508
Now, we can't do it with divide and
现在要注意，这种方法不适用于除法和减法

514
00:22:17,510 --> 00:22:20,378
minus because the order is backwards.
因为运算方向是反的

515
00:22:20,380 --> 00:22:22,146
Right, we put the things on the stack,
对吧，我们把这些东西放到栈上

516
00:22:22,148 --> 00:22:23,513
we pull them out backwards, so
然后反方向取出来，所以

517
00:22:23,515 --> 00:22:25,081
we can't do it with those, but.
这种方法不适用于除法和减法

518
00:22:27,919 --> 00:22:31,086
I just wanna emphasize, that's what's going on there.
我只是想强调一下，这里是怎么运作的

519
00:22:31,088 --> 00:22:33,455
Okay, so now we have this nice knownOps.
好，现在我们做好了这些 knwonOps

520
00:22:33,457 --> 00:22:34,222
So we have this thing.
做好了

521
00:22:34,224 --> 00:22:36,724
It's loaded up.
它已经装载好了

522
00:22:36,725 --> 00:22:39,225
It gets loaded up whenever the CalculatorBrain gets created.
每当 CalculatorBrain 被创建它就会被装载

523
00:22:39,228 --> 00:22:41,612
So that's all good.
万事俱备

524
00:22:41,613 --> 00:22:43,997
Now we can use that down here in performOperation.
现在我们可以将它用在 performOperation 上

525
00:22:43,999 --> 00:22:47,134
All right, so how are we gonna use this in performOperation?
好，那我们要怎么使用呢

526
00:22:47,136 --> 00:22:50,870
Well, we basically wanna let the operation equal
我们让 operation 等于

527
00:22:50,872 --> 00:22:53,172
knownOps sub symbol.
knownOps[symbol]

528
00:22:53,174 --> 00:22:55,240
Okay? Someone passed us a symbol.
明白了吗？使用者传递给我们一个参数 symbol

529
00:22:55,242 --> 00:22:56,641
They're trying to perform this operation.
当他们想用这个方法的时候

530
00:22:56,643 --> 00:22:58,810
So this is either a plus or a times.
参数可以是加号或者乘号

531
00:22:58,812 --> 00:23:00,111
Hopefully an operation we know.
是我们已知的操作符

532
00:23:00,113 --> 00:23:02,747
And we're gonna look it up in knownOps.
然后我们会来到 knownOps

533
00:23:02,749 --> 00:23:05,683
And the way we do that is with the subscript notation with
我们要做的就是根据在方括号里的下标

534
00:23:05,685 --> 00:23:06,650
the square brackets.
在字典里找到需要的东西

535
00:23:06,652 --> 00:23:07,951
Okay? That's how you
明白了吗？这就是

536
00:23:07,952 --> 00:23:09,251
look something up in a dictionary.
在字典里查找东西的方法

537
00:23:09,254 --> 00:23:11,454
But what might be kind of surprising to you,
不过有一点可能会让你惊讶

538
00:23:11,456 --> 00:23:13,622
what type do you think this would be, operation?
得到的 operation，你觉得是什么类型的呢？

539
00:23:15,292 --> 00:23:17,959
Any guesses, yeah, some people are saying the right thing.
猜猜？哈，有人说出了正确答案

540
00:23:17,961 --> 00:23:20,128
You'd think this might be an Op,
你可能会觉得这个是一个 Op

541
00:23:20,130 --> 00:23:24,498
because I'm looking up in knownOps right here, a String.
因为我在 knownOps 这里看，String：Op

542
00:23:24,500 --> 00:23:27,134
And so hopefully I'm getting an Op, but this is not an Op,
因此可以预见得到的会是一个 Op，事实上它并不是 Op

543
00:23:27,136 --> 00:23:30,971
this actually is an Optional Op.
实际上它是一个 Optional Op

544
00:23:30,973 --> 00:23:33,173
Okay, now why is that an Optional Op, because you
好了，为什么它会是一个 Optional Op，因为

545
00:23:33,175 --> 00:23:35,541
might be looking up something that's not in there.
因为它可能不存在于此

546
00:23:35,543 --> 00:23:38,344
And it has to return, oh, nil, sorry, couldn't find it,
而且它没有返回值“噢，nil，不好意思找不到该值”

547
00:23:38,346 --> 00:23:41,413
so that's why it has to be an Optional, is returned.
所以这就是为什么它必须是 Optional

548
00:23:41,415 --> 00:23:43,015
So a dictionary,
比方说字典

549
00:23:43,016 --> 00:23:44,616
whenever you look up something in a dictionary,
每当你要在字典里面寻找东西的时候

550
00:23:44,618 --> 00:23:47,118
it always returns an Optional, Okay, either nil or
它总是会返回一个 Optional 类型 nil 或者是

551
00:23:47,120 --> 00:23:50,655
the type of thing you said was supposed to be in there.
其他它原本的类型

552
00:23:50,657 --> 00:23:53,457
So I'm gonna if let here, I'm gonna say,
所以我在这里加上 if

553
00:23:53,459 --> 00:23:56,827
if I'm able to look up my operation in my knownOps,
如果 我能在 knownOps 里取得我的 operation

554
00:23:56,829 --> 00:23:59,696
then I'm going to push it on to my opStack.
那我就将它放进我的 opStack.

555
00:24:02,534 --> 00:24:03,232
Okay.

556
00:24:03,234 --> 00:24:06,068
Are you cool with that?
明白了吗？

557
00:24:06,070 --> 00:24:08,303
Make sense?
理解？


558
00:24:08,305 --> 00:24:10,171
Okay.

559
00:24:10,173 --> 00:24:12,407
Now, what's next?
好，下一步是什么呢

560
00:24:12,409 --> 00:24:13,908
Well.

561
00:24:13,910 --> 00:24:14,541
Now we have.
现在我们有…

562
00:24:14,543 --> 00:24:15,509
Oh, well.
噢，等等

563
00:24:15,510 --> 00:24:16,476
I'm gonna take a pause here to
在这我先暂停一下

564
00:24:16,478 --> 00:24:18,845
talk a little bit about access control.
谈一下 access control（访问控制）

565
00:24:18,847 --> 00:24:20,697
Okay?

566
00:24:20,698 --> 00:24:22,548
Access control is about public and private.
access control 是关于公有和私有

567
00:24:22,550 --> 00:24:25,017
Okay? What methods in this class
在这个类里面什么方法是共有的

568
00:24:25,019 --> 00:24:27,353
are public, in other words, other people can use them,
换言之，其他人能够使用它

569
00:24:27,355 --> 00:24:30,022
other classes in my code allowed to call them?
其他类能调用它

570
00:24:30,024 --> 00:24:31,189
And what things are private?
而什么方法是私有的呢

571
00:24:31,191 --> 00:24:32,757
My internal data structures that I
里面的一些内部数据

572
00:24:32,759 --> 00:24:34,458
don't want people messing with?
并不想给别人乱搞

573
00:24:34,460 --> 00:24:38,428
Okay, so the way public private works in
Swift 处理公有和私有的方法

574
00:24:38,430 --> 00:24:41,064
Swift is kind of interesting.
很有趣

575
00:24:41,066 --> 00:24:42,999
You basically specify the things you want to
基本上，你只在想要私有化的东西前

576
00:24:43,001 --> 00:24:45,935
be private by putting the word private on them.
加上 private

577
00:24:45,937 --> 00:24:47,569
If you don't put any word on them,
如果你什么都不加

578
00:24:47,571 --> 00:24:50,639
then they're public inside your program.
那他们就是在你的程序里公有的

579
00:24:50,641 --> 00:24:52,040
'Kay?

580
00:24:52,042 --> 00:24:55,109
And you only use the word public if you're shipping out,
当你想要打包

581
00:24:55,111 --> 00:24:58,979
like, a framework of objects to other people, and
比如说一个框架给别人，

582
00:24:58,981 --> 00:25:02,215
you want stuff in there to be public outside the framework.
并且你希望里面框架里的东西对框架外是公开的，你才会使用 public

583
00:25:03,251 --> 00:25:04,684
So I'm making some framework,
比如我做一些框架

584
00:25:04,686 --> 00:25:07,153
a bunch of objects that I'm trying to sell to people or
一些对象想要卖给别人用

585
00:25:07,155 --> 00:25:09,555
I get people to use to do something, and
别人可以用这些东西做点什么

586
00:25:09,557 --> 00:25:12,624
of course I'm gonna have things where my objects inside
我当然希望在框架内部的一些类

587
00:25:12,626 --> 00:25:14,192
my framework can talk to each other.
可以互相交流

588
00:25:14,194 --> 00:25:16,361
There's no keyword needed for that.
那就不需要什么关键字

589
00:25:16,363 --> 00:25:18,229
Then I'll have things inside certain objects
然后我可以对某些类里面的东西加上 private

590
00:25:18,231 --> 00:25:20,464
that are private only to that object, I'll say private.
让它们私有化

591
00:25:20,466 --> 00:25:24,267
And then some of them might be public that the customer who's
而另外的东西就是公有的，那些

592
00:25:24,269 --> 00:25:27,404
buying my objects, my framework, can use.
买了我们的类、框架的顾客就可以使用它们

593
00:25:27,406 --> 00:25:29,238
Now, in this class we're not gonna be doing frameworks,
在这节课我们不会做框架

594
00:25:29,240 --> 00:25:30,840
we don't really have time to get to that, so
我们没有那个时间

595
00:25:30,842 --> 00:25:32,508
we're not gonna be using the keyword public,
所以我们不需要用到关键字 public

596
00:25:32,510 --> 00:25:34,076
we won't ever use that,
我们之后都不会用它

597
00:25:34,078 --> 00:25:35,510
because we don't have any frameworks.
因为我们没有什么框架

598
00:25:35,512 --> 00:25:37,578
But we are gonna use private.
但我们会用 private

599
00:25:37,580 --> 00:25:39,180
And, starting with assignment two,
然后，从第二次作业开始

600
00:25:40,216 --> 00:25:42,516
it's one of your evaluation criteria is gonna be,
它将是你们的评分标准之一

601
00:25:42,518 --> 00:25:45,985
make private things private. OK?
让应该是 private（私有化） 的东西 private

603
00:25:45,987 --> 00:25:47,453
So that is important to do.
所以这点很重要

604
00:25:47,455 --> 00:25:48,354
And you could just say,
也许你会这么说，

605
00:25:48,356 --> 00:25:49,988
well, I like everything to be public.
呃，我喜欢让所有对象和方法都是 public 的

606
00:25:49,990 --> 00:25:51,156
Well, that's bad.
可惜，这样做会很糟糕

607
00:25:51,158 --> 00:25:53,391
Okay? If you make your internal structure public,
假如你让内部的 structure（结构体）public 化，

608
00:25:53,392 --> 00:25:55,625
and some other object in your program
然后其他在你程序中的对象可能会修改它的内容，

609
00:25:55,628 --> 00:25:58,796
starts muck in with it and breaks your object, and
这将会导致你的对象错乱，

610
00:25:58,798 --> 00:26:00,931
then you come to a new version of your program, and
随后，你又可能新建了一个程序版本号，

611
00:26:00,933 --> 00:26:03,467
you change something, and now everybody's breaking.
改变了一些代码，好了，所有对象都错乱了

612
00:26:03,469 --> 00:26:05,335
That's bad, Okay, that's chaos.
所以这么做是不好的，这会导致混乱明白了吗？

613
00:26:05,337 --> 00:26:08,671
So the only things that want to be not private are things
只有当你想用来给别的类或对象提供支持的时候，

614
00:26:08,673 --> 00:26:11,507
that you're committing to sign up to support.
你才会想让它不是 private 的

615
00:26:11,509 --> 00:26:14,677
So in this class, the only public things so
因此在这个 class 里面，目前为止唯一是 public

616
00:26:14,679 --> 00:26:17,279
far are the initializer.
的，只有 initializer

617
00:26:17,281 --> 00:26:18,513
Obviously, we want to allow people to
很显然，我们希望让别人

618
00:26:18,515 --> 00:26:19,847
create a CalculatorBrain.
创建一个 CalcualtorBrain 的对象

619
00:26:19,849 --> 00:26:21,349
That's clearly public.
很明显，这应当是 public 的

620
00:26:21,351 --> 00:26:25,385
Also pushing and performing operands and operations.
同样的，将操作数和操作符压栈然后计算的这些操作

621
00:26:25,387 --> 00:26:28,238
That's public. Okay?
也都应当是 public 的

623
00:26:28,239 --> 00:26:29,889
Everything else, for now, I'm gonna make private.
而目前为止我们不需要对外提供的东西，我们都让它们成为 private 的

624
00:26:29,891 --> 00:26:31,657
So I'm gonna make this private.
现在，我将让 Op 变成 private 的

625
00:26:31,659 --> 00:26:33,592
Notice that if I make this private,
注意，当我把这个变成了 private 以后，

626
00:26:33,594 --> 00:26:35,427
it's gonna start saying, whoa,
这边将提示，

627
00:26:35,429 --> 00:26:38,730
wait a second, this can't be public, you know, it can't be
这（opStack）不能是 public 的，不能

628
00:26:38,732 --> 00:26:42,100
non-private because this is private and it uses it.
因为 Op 是 private 的，然后 opStack 使用了 Op，所以 opStack 也只能是 private 的

629
00:26:42,102 --> 00:26:44,368
That's what this warning's gonna say right here, see.
如果不这么做，这个位置将会出现一个警告，看

630
00:26:44,370 --> 00:26:45,720
Property must be
Property 必须

631
00:26:45,721 --> 00:26:47,071
declared private because its type is private.
声明为 private，因为它的类型是 private 的

632
00:26:47,073 --> 00:26:48,205
Okay, that's the type of this.
好的，这个就是它的类型


633
00:26:48,207 --> 00:26:49,906
But I want this to be private anyway,
在这个情况下，我都希望它是 private 的，

634
00:26:49,908 --> 00:26:52,742
this is my internal data structure, opStack.
opStack 就是我程序内部的数据结构了

635
00:26:52,744 --> 00:26:56,278
Now, knownOps is kind of an interesting one.
现在我们来看看 knownOps，它是个很有意思的对象

636
00:26:56,280 --> 00:26:58,614
Maybe I would want that to be public one day,
也许我在某种情况下想让它变成 public ，

637
00:26:58,616 --> 00:27:01,650
because maybe I want people to use my CalculatorBrain and
比如我希望人们使用我的 CalculatorBrain 的同时

638
00:27:01,652 --> 00:27:03,685
teach it new ops.
并为它增加新的运算功能

639
00:27:03,687 --> 00:27:05,386
That wouldn't be that unreasonable.
这种情况是真实存在的

640
00:27:05,388 --> 00:27:08,356
However, I'm not ready to support that functionality in
但是呢，我现在还没准备好让我的 CalculatorBrain 来

641
00:27:08,358 --> 00:27:09,456
my CalculatorBrain.
支持这些功能

642
00:27:09,458 --> 00:27:12,059
I'm just not sure I wanna do it this way.
或许我只是还不确定我想这么做

643
00:27:12,061 --> 00:27:13,827
Maybe I don't want this property to be public,
所以在某种情况下，我可能又不想让这个 property 变成 public 的，

644
00:27:13,829 --> 00:27:17,263
I might want to just have some functions to learn an op or
我希望只是有些函数去增加一个运算操作或者

645
00:27:17,265 --> 00:27:18,982
something like that, so
类似的东西，所以

646
00:27:18,983 --> 00:27:20,700
I'm just not sure, so I'm gonna start out private.
我不确定我会怎么做，所以我默认设置它为 private 的

647
00:27:20,702 --> 00:27:23,268
And that's really, when you're designing APIs,
上面这些这就是当你在设计 APIs 的时候需要考虑的问题，

648
00:27:23,270 --> 00:27:24,536
you wanna kinda start out,
你总得找个地方入手，

649
00:27:24,538 --> 00:27:27,405
make it private first, and then open it up as you're
所以比较好的做法是，先让它是 private 的，然后等到你想要支持一些功能

650
00:27:27,407 --> 00:27:30,308
willing to support that functionality.
的时候，再让其变成 public 的

651
00:27:30,310 --> 00:27:31,709
-Question? -Is the common view in
- 有什么问题吗？- [学生提问]


652
00:27:31,711 --> 00:27:34,278
Swift to make most instance variables private and
- [学生提问]

653
00:27:34,280 --> 00:27:36,980
use getters and setters, or is it to make them, if,
- [学生提问]

654
00:27:36,982 --> 00:27:38,882
if they are supposed to be public, or
- [学生提问]

655
00:27:38,884 --> 00:27:40,683
make them public and then let the?
- [学生提问]

656
00:27:40,685 --> 00:27:43,052
All right. So the question is, is it,
好的那么这个学生的问题是，

657
00:27:43,054 --> 00:27:45,854
is it kind of part of the Swift way to make
“是不是有 Swift 的标准做法让

658
00:27:45,856 --> 00:27:47,889
most instant variables private and
一个 private 的实例变量可以

659
00:27:47,891 --> 00:27:50,75
then have getters and setters that are public to get them.
用 public 的 getters 和 setters 方法去访问它们”

660
00:27:50,761 --> 00:27:52,226
That doesn't really even make sense in Swift.
这在 Swift 中根本没有意义

661
00:27:52,228 --> 00:27:53,961
That's more of an Objective-C thing.
这更像是 Objective-C 的做法

662
00:27:53,963 --> 00:27:56,263
In Objective-C, you had instance variables, and
在 Objective-C 中，你有一个实例变量，然后

663
00:27:56,265 --> 00:27:59,032
then you had properties that would get and set them.
你有 properties ，会用 getter 和 setter 方法去获取和设置它们

664
00:27:59,034 --> 00:28:00,967
And Swift has kind of merged those a little bit
Swift 把这些东西进一步

665
00:28:00,969 --> 00:28:05,638
closer together so that properties are really kind of
融合在一起了，所以 properties 事实上是一种

666
00:28:05,640 --> 00:28:08,907
the public or private getters and setters.
public 或者 private 的 getters 和 setters 方法

667
00:28:08,909 --> 00:28:11,043
So, if you have a property, you just have to
因此，如果你有一个 property，你只需要

668
00:28:11,045 --> 00:28:13,178
decide whether you want people to access it or
决定你是否想要别人能够访问它，

00:28:13,180 --> 00:28:15,246
not, and if not, make it private.
如果不是，将它变成 private 的

670
00:28:15,248 --> 00:28:16,681
And if so, make it public.
如果是，将它变成 public 的

671
00:28:16,683 --> 00:28:19,350
And that, you know, don't make it non-private, basically.
一般来说不要让它是 public 的

672
00:28:19,352 --> 00:28:21,685
And that's, just that's all you need to think about.
所以，你需要考虑的是这些

673
00:28:21,687 --> 00:28:24,854
I wouldn't even think in Swift in terms of instance variable
我甚至不会在 Swift 中考虑实例变量

674
00:28:24,856 --> 00:28:26,289
versus the property.
和 property 的区别

675
00:28:26,291 --> 00:28:28,557
Now, it is still possible in Swift to do that,
但是目前，用 Swift 还是有可能做到的你说的这些的，

676
00:28:28,559 --> 00:28:30,526
because you have computed properties.
因为有 computed properties（计算属性）

677
00:28:30,528 --> 00:28:32,328
And those could be setters and
这些都可以成为设置 private properties

678
00:28:32,329 --> 00:28:34,129
getters that are setting private properties.
的 setters 和 getters 方法

679
00:28:34,131 --> 00:28:36,464
But we're gonna see on Wednesday, even,
我们将会在周三的课程中了解到更多相关的东西，

680
00:28:36,466 --> 00:28:39,634
I'm gonna talk to you a little bit about a way that when your
我甚至会和你们讨论一点点关于

681
00:28:39,636 --> 00:28:41,902
properties get set, you can intervene,
properties 的 get 和 set 方面的东西，你可以介入到它们其中，

682
00:28:41,904 --> 00:28:44,571
you can check them to make sure the value is Okay.
检查一下，来保证它们的值是正确的

683
00:28:44,573 --> 00:28:46,373
So if you have a public property,
所以说，如果你有一个 public 的 property，

684
00:28:46,375 --> 00:28:49,142
you can still protect it by intervening a little bit
当人们尝试获取或者设置它的值的时候，

685
00:28:49,144 --> 00:28:51,110
when people set it or try and get it.
你仍然可以介入这个 property 来保护它

686
00:28:51,112 --> 00:28:52,912
So it is possible to still have some protection there,
这里面仍可以设置一些保护机制，

687
00:28:52,914 --> 00:28:53,545
we'll see that.
在周三的课程中，我们都会有所了解

688
00:28:56,016 --> 00:28:57,749
All right, so these are our only public things.
好，回到主题，这些就是我们仅有的 public 的东西

689
00:28:57,751 --> 00:29:00,651
Now, there's only one other public thing we need to do in
那么现在，在我们的 CalculatorBrain 里，

690
00:29:00,653 --> 00:29:02,420
our CalculatorBrain, which is,
还剩一个 public 的东西要做的是，

691
00:29:02,422 --> 00:29:04,688
we need to let people evaluate this stack.
我们需要允许用户对这个 stack 求值

692
00:29:06,058 --> 00:29:09,492
So people are pushing operands and performing operations,
用户把操作符压栈然后进行计算，

693
00:29:09,494 --> 00:29:11,828
now they wanna know what's the result.
随后，他们想知道结果是什么

694
00:29:11,830 --> 00:29:14,129
Okay? They pushed an operand of a five.
举例，我们往栈里压了一个数字5

696
00:29:14,132 --> 00:29:15,898
They pushed an operand of a four.
然后我们再压一个数字4

697
00:29:15,900 --> 00:29:18,166
They performed operation plus,
做加法操作，

698
00:29:18,168 --> 00:29:19,668
they want to see four plus five.
我们想看到的是 4 + 5

699
00:29:19,670 --> 00:29:21,202
Where's that nine, Okay?
得到的答案应该是 9，对吧？

700
00:29:21,204 --> 00:29:22,403
They need the result.
他们需要看到结果

701
00:29:22,405 --> 00:29:25,606
So we need another public method here,
所以，这里我们还需要一个公共方法，

702
00:29:25,608 --> 00:29:29,876
which I'm gonna call evaluate.
将其命名为 evaluate

703
00:29:29,878 --> 00:29:31,344
'Kay? And evaluate,

704
00:29:31,346 --> 00:29:34,880
we could have it return a Double, for example.
像这样，我们可以设置其返回类型为 Double

705
00:29:34,882 --> 00:29:38,917
And it would just evaluate this opStack and
这个方法会对 opStack 求值并

706
00:29:38,919 --> 00:29:40,535
return the value.
返回结果

707
00:29:40,536 --> 00:29:42,152
But I really can't make this a Double.
但现在我并不能设置这个返回类型为 Double

708
00:29:43,390 --> 00:29:46,524
Really, this has to be an Optional.
事实上，它必须为 Optional (Double?)

709
00:29:46,526 --> 00:29:48,892
'Kay, why does this have to be an Optional?
为什么它必须为 Optional?

710
00:29:48,894 --> 00:29:52,295
Well, that's because someone might get my CalculatorBrain,
这是由于，当某人使用 CalculatorBrain 时，

711
00:29:52,297 --> 00:29:53,963
and the first thing they do is,
他们做的第一件事

712
00:29:53,965 --> 00:29:55,932
they say, perform operation plus.
是——执行加法

713
00:29:55,934 --> 00:29:57,600
Okay, well I have no operands.
但我们此时并没有可以被加的数

714
00:29:57,602 --> 00:29:59,051
Okay? And

715
00:29:59,052 --> 00:30:00,501
you're asking to evaluate plus.
可这个时候又被要求执行加法计算

716
00:30:00,504 --> 00:30:02,287
I can't do that.
这个操作是无法完成的

717
00:30:02,288 --> 00:30:04,071
So, I have to return something to you, that lets you know,
所以我必须返回一些东西，让用户知道

718
00:30:04,074 --> 00:30:07,776
I could not evaluate what you ask me to evaluate.
我无法计算你让我计算的东西

719
00:30:07,778 --> 00:30:09,477
So, I'm gonna return nil in that case,
这种情况下，我就会返回 nil，

720
00:30:09,479 --> 00:30:12,213
so valuate here really needs to be an Optional.
所以这里需要返回一个 Optional

721
00:30:13,249 --> 00:30:14,848
'Kay, so you can see some of the thinking,
你可以看到我们对于什么时候

722
00:30:14,850 --> 00:30:17,283
when do you make something an Optional when not.
应该使用 Optional 的思考

723
00:30:17,285 --> 00:30:19,285
'Kay, so this is a classic case of that,
这里就是 Optional 一个典型的使用场景，

724
00:30:19,287 --> 00:30:21,787
where you got sometimes you wanna return it and
有时你想要返回一些东西，

725
00:30:21,789 --> 00:30:23,889
you can't do it, so you have to return nil.
但又无法返回的时候，那么就返回 nil.

726
00:30:23,891 --> 00:30:28,793
All right, so how we going to implement evaluate?
那么，接下来我们应该怎么实现 evaluate 呢？

727
00:30:28,795 --> 00:30:30,595
Okay, how many people in the class,
对了，在这个班上有多少人

728
00:30:30,597 --> 00:30:34,365
raise your hands don't be shy, are you comfortable with
不要害羞，举起你们的手，

729
00:30:34,367 --> 00:30:37,067
the computer science concept of recursion?
有多少人熟悉计算机科学中递归的概念？

730
00:30:39,271 --> 00:30:40,903
Okay. Excellent, that's about 80 or
很好，大概有80~90%，

731
00:30:40,905 --> 00:30:43,939
90%, so I'm gonna explain this really fast then.
那么我将只是快速地解释一下

732
00:30:43,941 --> 00:30:45,974
And if you don't understand recursion,
如果你不明白递归

733
00:30:45,976 --> 00:30:47,309
if you didn't raise your hand,
如果你刚才没有举手的话

734
00:30:47,311 --> 00:30:48,843
that's something you should go review.
那就意味着你需要回去复习

735
00:30:48,845 --> 00:30:50,378
Okay? [LAUGH] Recursion is
递归是

736
00:30:50,379 --> 00:30:51,912
something, you should know by the time you take this class,
当你在学习这门课程的时候，应该了解的东西

737
00:30:51,915 --> 00:30:53,714
so that's something you definitely wanna know.
而且是必须了解的东西

738
00:30:53,716 --> 00:30:57,317
So, how are we going to use recursion to
那么在这种情况下，

739
00:30:57,319 --> 00:30:59,252
evaluate this stack?
我们应该怎样在 evaluate 中使用递归？

740
00:30:59,254 --> 00:31:00,653
All right, looks like this.
看这里

741
00:31:00,655 --> 00:31:02,988
I'm gonna do a sample stack, right here.
我将会在这里写一个栈

742
00:31:02,990 --> 00:31:08,393
So, let's say I put a 6 on the stack, and then I put a 5, and
这样说吧，我放了一个 6 在这个栈上，然后我再放了一个5，

743
00:31:08,395 --> 00:31:14,065
then I put a plus, and then I put a 4, and then I put times.
随后我再放了加号，再放4，最后放上乘号

744
00:31:14,067 --> 00:31:15,166
Okay?

745
00:31:15,168 --> 00:31:17,968
So here's our stack, and I'm gonna evaluate this,
这就是我们的栈，我将要使用递归

746
00:31:17,970 --> 00:31:18,702
I'm gonna recursion.
计算这个栈

747
00:31:18,704 --> 00:31:19,769
How am I gonna do that?
我要怎么做？

748
00:31:19,771 --> 00:31:21,437
Well, really, what I'm gonna do is I'm gonna
我要这样

749
00:31:21,439 --> 00:31:24,740
have a helper method here, a recursive helper method.
在这里我需要一个 helper 方法，一个帮助实现递归的方法

750
00:31:24,742 --> 00:31:27,543
I'm gonna call it evaluate also, actually.
事实上这个方法我也叫 evaluate

751
00:31:27,545 --> 00:31:29,644
And it's gonna take a stack, as an argument,
它会将我们的栈当做一个参数，

752
00:31:29,646 --> 00:31:31,012
a stack of things to evaluate.
一堆用来计算的东西

753
00:31:31,014 --> 00:31:34,449
And it's only gonna evaluate the top thing on the stack.
它计算处于这个栈顶的元素

754
00:31:34,451 --> 00:31:36,717
That's it just gonna value the top of the stack and
而且它只计算处于栈顶的元素，并且返回，

755
00:31:36,719 --> 00:31:38,819
return it, but the top thing of the stack might
但是计算栈顶的这个元素时，

756
00:31:38,821 --> 00:31:41,421
involve looking at every single of one of these, right?
可能也会涉及到栈中的每一个元素

757
00:31:41,423 --> 00:31:44,157
Cuz, this times needed to two operations.
因为，乘法需要两个数才能进行

758
00:31:44,159 --> 00:31:47,026
So, lets look at this, this recursive evaluates gonna come
所以，这个递归计算将

759
00:31:47,028 --> 00:31:48,961
in here, it's gonna try and
将尝试着计算处于栈顶的元素

760
00:31:48,962 --> 00:31:50,895
evaluate the top of the stack, which is a times.
也就是乘法

761
00:31:50,898 --> 00:31:51,597
Okay? So it's like,
这将是

762
00:31:51,599 --> 00:31:53,265
Okay, I'm doing times.
我在算乘法

763
00:31:53,267 --> 00:31:56,101
Now for times it needs two operate,
我需要要找到乘数和被乘数

764
00:31:56,103 --> 00:31:58,302
two operands here for times.
来做乘法，

765
00:31:58,304 --> 00:31:59,737
So, it recursively calls,
evaluate 开始递归

766
00:31:59,739 --> 00:32:03,807
itself to say give me to first operand for time.
它说，给我第一个操作数来做乘法

767
00:32:03,809 --> 00:32:07,010
And so recursively, comes in here, it finds a 4 on
然后从这里递归地，在子栈的栈顶找到了一个 4，

768
00:32:07,012 --> 00:32:10,913
the top it's like, I know how to evaluate 4, it's 4.
它找到了一个操作数

769
00:32:10,915 --> 00:32:12,148
So, it just returns.
所以直接返回

770
00:32:12,150 --> 00:32:15,751
Okay, so now I have my first operands.
好，现在我就有了第一个操作数

771
00:32:15,753 --> 00:32:16,618
'Kay? Now,
现在

772
00:32:16,620 --> 00:32:18,386
I take the rest of the stack and
我在剩下的栈上进行递归，

773
00:32:18,388 --> 00:32:21,255
evaluate it, to get the second one.
以得到第二个操作数

774
00:32:21,257 --> 00:32:24,291
And when I do that, I get plus, 'kay?
当在剩下的栈上递归时，我得到一个加号

775
00:32:24,293 --> 00:32:26,393
So, plus says, oh, I have to evaluate plus.
然后加号说："噢，我要计算加法"

776
00:32:26,395 --> 00:32:27,727
It needs operands.
"那需要操作数才行"

777
00:32:27,729 --> 00:32:30,763
So, I come over here, I'm getting a plus.
然后我在这里写上，我有了一个加号

778
00:32:30,765 --> 00:32:34,700
And I gotta go recursive again, to go get its operands.
我要再次递归，用于获取做加法的操作数

779
00:32:34,702 --> 00:32:36,401
I get the 5, that's good.
我得到 5，不错

780
00:32:36,403 --> 00:32:41,072
I'm gonna go recursive again, get the 6, over here.
我还要再次递归，得到一个 6，填写到这里

781
00:32:41,074 --> 00:32:42,907
And I've evaluated the whole stack.
这样，我计算完整个栈

782
00:32:42,909 --> 00:32:45,876
So, you see how I have to keep going backward recursively to
就这样，你看到我这样通过来回

783
00:32:45,878 --> 00:32:46,576
my evaluate
递归

784
00:32:46,578 --> 00:32:47,911
[COUGH]

785
00:32:47,912 --> 00:32:49,245
To get the operands for my operations.
获取操作符所需要的操作数

786
00:32:49,247 --> 00:32:51,848
Once, I get to an operand I can stop,
一旦我取得的是操作数，本次递归就可以停止，

787
00:32:51,850 --> 00:32:54,483
Okay number, I got it and I'm out of of there.
因为我得到我需要的数字，我可以停止递归

788
00:32:54,485 --> 00:32:56,418
But every time I encounter another operation,
但每一次我遇到另一个操作符时，

789
00:32:56,420 --> 00:32:58,153
I have to keep going recursively to
我就必须继续递归来

790
00:32:58,155 --> 00:33:00,822
get all my arguments, any questions about that?
获取所需要的操作数，有人对这个过程有疑问吗？

791
00:33:00,824 --> 00:33:06,327
'Kay, so it's actually gonna be pretty simple recursion.
这是一个非常简单的递归算法

792
00:33:06,329 --> 00:33:08,862
When you see the code, you're gonna be, that makes sense.
但你看到了代码，你就会觉得："哦，还真是这样"

793
00:33:08,864 --> 00:33:12,832
So, I'm gonna have this separate I'm gonna put this up
我将把这个分开，放在最上面

794
00:33:12,834 --> 00:33:15,201
on top for scrolling reasons.
为了更好地滚动

795
00:33:15,203 --> 00:33:18,237
Oops. Didn't mean that.
Opps，我不是故意的

796
00:33:18,239 --> 00:33:19,672
The separate evaluate.
这是分离的另一个 evaluate

797
00:33:20,808 --> 00:33:25,677
And this evaluate is going to take a stack of ops,
这个 evaluate 将会取得栈上的操作数，

798
00:33:25,679 --> 00:33:27,078
as its argument.
作为参数

799
00:33:27,080 --> 00:33:28,645
And why does it take a stack of ops?
为什么它会获取栈上的操作数呢？

800
00:33:28,647 --> 00:33:31,048
Because as it's recursing,
因为当它递归时，

801
00:33:31,050 --> 00:33:32,882
it's using the rest of the
ops.
它使用剩下的操作数

802
00:33:32,884 --> 00:33:34,050
So, you see what I mean?
所以，你们明白我的意思了吗？

803
00:33:34,052 --> 00:33:35,618
It's not,
它不能

804
00:33:35,619 --> 00:33:37,185
it can't be looking at the big opStack in our brain.
访问我们的程序里巨大的 opStack

805
00:33:37,188 --> 00:33:38,320
It can't look at this.
它无法这么做

806
00:33:38,322 --> 00:33:40,756
'Kay, cuz it's kind of consuming it.
因为这有点太消耗时间了

807
00:33:40,758 --> 00:33:42,991
Right? And every time I call it
我每次递归调用

808
00:33:42,992 --> 00:33:45,225
recursively, I'm gonna get fewer operands to work with.
都只需要处理很少的操作数

809
00:33:45,228 --> 00:33:46,194
So this is what I'm doing.
所以这就是我做的事情

810
00:33:46,196 --> 00:33:47,962
Now, the first time I call it,
在这里，我第一次调用，

811
00:33:47,964 --> 00:33:50,864
right here, I'm gonna give it the full opStack.
这时需要给出完整的 opStack

812
00:33:50,866 --> 00:33:53,767
So, I'll call my recursive one from here.
我从这里开始调用递归函数

813
00:33:53,769 --> 00:33:56,036
Now, what's this thing gonna return?
那么，这里将要返回什么？

814
00:33:56,038 --> 00:33:56,836
'Kay.

815
00:33:56,838 --> 00:33:57,770
That's interesting and
这将会很有趣

816
00:33:57,772 --> 00:34:00,873
here's a big new thing for you to see.
而且这里有其他的新鲜东西等待你们发现


817
00:34:00,875 --> 00:34:03,709
You've read about it I, I can't remember I
你们看过了吧，我不记得

818
00:34:03,711 --> 00:34:05,910
even asked you to read about this but I think I.
有没有叫你们去看相关内容，不过

819
00:34:05,912 --> 00:34:06,811
No, I guess I didn't.
我猜我没有

820
00:34:06,813 --> 00:34:08,846
Which is Tuples, 'kay?
什么是 Tuple（元组）？

821
00:34:08,848 --> 00:34:14,484
So in Swift, you can combine multiple things together
在 Swift 里，你可以把多个东西组合起来

822
00:34:14,486 --> 00:34:16,853
into one kind of really te,
成为一个相当

823
00:34:16,855 --> 00:34:19,922
mini data structure called a Tuple, 'kay?
迷你的数据结构叫做 Tuple

824
00:34:19,924 --> 00:34:22,124
Don't let the tu [LAUGH] sound in there fool you.
不要被 tu 的发音愚弄了

825
00:34:22,126 --> 00:34:24,560
It's not just two, it's any number, Okay?
这不代表 two，它可以是任意数目

826
00:34:24,562 --> 00:34:26,762
And you just put them in a parentheses, Okay?
你只需要把它们放进一对圆括号里

827
00:34:26,764 --> 00:34:28,664
And, and that's it.
这就好了

828
00:34:28,665 --> 00:34:30,565
So you can use this for return values.
你可以用它来做返回值

829
00:34:30,567 --> 00:34:32,033
So I've gotta function right here,
我在这里使用了这一功能，

830
00:34:32,035 --> 00:34:34,735
and I actually need to return two things from this evaluate.
实际上我需要在求值后返回两个东西

831
00:34:35,771 --> 00:34:37,754
'Kay? One thing I
一个是

832
00:34:37,755 --> 00:34:39,738
need to return is the result of a evaluating it.
求值运算的结果

833
00:34:40,975 --> 00:34:43,042
But the other thing I
另一个是

834
00:34:43,043 --> 00:34:45,110
need to return is the rest of the stack that I didn't use.
剩余的未使用的栈

835
00:34:45,112 --> 00:34:48,647
Cuz as I'm working my way down here and I take off that
因此就像我在这里演示的，

836
00:34:48,649 --> 00:34:52,884
times, and the 4 and the 5, Okay, I'm consuming things but
我取走了乘号，然后是4跟5我拿走了栈里的一些东西，

837
00:34:52,886 --> 00:34:54,652
then I'm leaving the rest of the stacks, so
同时栈有剩余部分，

838
00:34:54,654 --> 00:34:56,920
I have to keep returning what's left of the stacks,
所以我需要在求值过程中

839
00:34:56,922 --> 00:34:58,722
while we keep consuming it.
返回栈的剩余部分

840
00:34:58,724 --> 00:34:59,689
Okay?

841
00:34:59,691 --> 00:35:01,958
So, I'm gonna return this in a Tuple.
所以，我要在 Tuple 里返回这个

842
00:35:01,960 --> 00:35:04,126
Tuples could not be simpler syntax,
Tuple 的语法不能再简单了，

843
00:35:04,128 --> 00:35:08,097
just open parentheses, not nine, open parentheses.
只要左括号，不是9，左括号

844
00:35:08,099 --> 00:35:11,066
Open parentheses, and just all the types that you,
然后是所有你要的类型数据

845
00:35:11,068 --> 00:35:12,634
of things that you want in here.
统统放在这里

846
00:35:12,636 --> 00:35:14,569
So, I'm gonna return a Double question mark,
所以我要在这里返回 Double?

847
00:35:14,571 --> 00:35:16,070
that's my results.
这是我的结果

848
00:35:16,072 --> 00:35:17,683
'Kay?

849
00:35:17,684 --> 00:35:19,295
That's what's eventually, gonna be
这是最终

850
00:35:19,296 --> 00:35:20,907
returned out here after all the recursion unwinds.
所有递归都被展开后返回的结果

851
00:35:20,910 --> 00:35:23,643
And then also I'm going to
同时我也需要

852
00:35:23,645 --> 00:35:28,348
have the ops that are left over.
剩下的 op

853
00:35:28,350 --> 00:35:32,851
Now, a Tuple could look just like this, unnamed.
现在，一个未命名的 Tuple 看上去像这样

854
00:35:32,853 --> 00:35:34,519
Did you see how these things are not named,
你们看到这些未命名的格式，

855
00:35:34,521 --> 00:35:35,920
each of these things in here.
里面每一个东西

856
00:35:35,922 --> 00:35:38,956
But you can also put names in here as, if you want, as well.
如果你想要，你也可以把名称放在这里

857
00:35:38,958 --> 00:35:41,092
So maybe I would call this one the result.
我会把这个（Tuple 的第一项）命名为 result

858
00:35:42,061 --> 00:35:44,728
Okay? And

859
00:35:44,729 --> 00:35:47,396
I would call this one remainingOps, 'kay?
把这个（Tuple 的第二项）命名为 remainingOps

860
00:35:47,399 --> 00:35:49,666
And I kinda recommend putting those in there, and
我推荐给 Tuple 中的对象命名，

861
00:35:49,668 --> 00:35:52,601
you'll see why in a second because there's two ways to
马上你们就会知道为什么因为有两种方法

862
00:35:52,603 --> 00:35:56,138
call a function that returns a Tuple and get the results.
的返回值是 Tuple

863
00:35:56,140 --> 00:36:00,208
And one of the ways requires that you name these, 'kay?
其中一种强制要求命名

864
00:36:00,210 --> 00:36:01,843
So, it doesn't hurt to name the, you might, as well.
所以，加上名字没什么要紧的

865
00:36:01,845 --> 00:36:03,111
It's good documentation.
这是很好的代码习惯

866
00:36:03,113 --> 00:36:05,379
Someone looking at this now knows, oh, yeah,
有些人看到这个方法就会明白

867
00:36:05,381 --> 00:36:07,147
this is the result of the evaluation, and
这个（Tuple 的第一项）是求值的结果，

868
00:36:07,149 --> 00:36:09,783
these the ops that were left over.
这个（Tuple 的第二项）是剩下的栈

869
00:36:09,785 --> 00:36:10,784
'Kay?

870
00:36:10,786 --> 00:36:13,419
All right.

871
00:36:13,421 --> 00:36:15,121
So let's dive in here.
好，我们从这里开始

872
00:36:15,123 --> 00:36:16,956
The first thing,
第一件事，

873
00:36:16,957 --> 00:36:18,790
line of code I'm gonna put in this recursive function
编写这个递归函数

874
00:36:18,793 --> 00:36:21,193
is the failure line of code,
处理失败的情况的代码，

875
00:36:21,195 --> 00:36:25,930
which is return nil, ops, Okay?
这里，我们直接返回 (nil, ops)

876
00:36:25,932 --> 00:36:28,566
So if I fail, Okay, I'm gonna try and
如果失败了，我会尝试

877
00:36:28,568 --> 00:36:33,303
do my best in here to evaluate these ops you passed me, but
用这里传入的 ops 求值，

878
00:36:33,305 --> 00:36:36,272
if I fail I'm just gonna return my result of nil.
如果失败了，就以 nil 为结果返回

879
00:36:36,274 --> 00:36:37,974
'Kay?

880
00:36:37,975 --> 00:36:39,675
And that's gonna be my default is to return nil so
返回 nil 将是默认行为，

881
00:36:39,678 --> 00:36:40,643
I know I failed.
如果返回 nil，我就知道我失败了

882
00:36:40,645 --> 00:36:42,344
So, if I run out of operands or
再者，比如当我处理完毕所有的操作数，

883
00:36:42,346 --> 00:36:44,613
I run out of stack can't find it for
或者处理完毕整个栈时，

884
00:36:44,615 --> 00:36:47,915
example, it's just gonna fall out here and return nil.
那么也会跳转到这里，返回 nil

885
00:36:49,152 --> 00:36:49,683
Okay?

886
00:36:49,685 --> 00:36:50,784
So that's good.
这样挺不错的

887
00:36:50,786 --> 00:36:52,619
So, what do I need to do here?
在这里需要我做什么呢？

888
00:36:52,621 --> 00:36:56,089
Well, first thing is I need to make sure I have some ops.
首先我要确定栈中有元素

889
00:36:56,091 --> 00:36:59,859
So I'm gonna check to see if the ops is not empty.
我要检查栈是不是空的

890
00:36:59,861 --> 00:37:04,529
Okay, if you've handed me a stack of no ops to evaluates,
如果传入一个没有元素的栈

891
00:37:04,531 --> 00:37:05,463
I can't do that.
我将无法求值

892
00:37:05,465 --> 00:37:06,698
So I'm just gonna return nil.
我简单地返回 nil 即可

893
00:37:06,700 --> 00:37:07,615
'Kay? So

894
00:37:07,616 --> 00:37:08,531
that's the very first thing,
这是最开始要做的事，

895
00:37:08,534 --> 00:37:11,035
I gotta make sure I have some ops to work with.
我要确定我有待处理的栈元素

896
00:37:11,037 --> 00:37:14,237
Now, I'm gonna grab the first op of the stack, so
现在，我要获取栈里的第一个操作符或者操作数，

897
00:37:14,239 --> 00:37:16,639
in this example, I'm gonna grab that x off of here.
在这个例子里，我要在这里获取 x

898
00:37:16,641 --> 00:37:17,206
'Kay?

899
00:37:17,208 --> 00:37:18,574
I'm gonna do that,
想要这么做，

900
00:37:18,576 --> 00:37:24,012
I'm gonna try to do that by saying, let op equal ops.
这么实现： let op ＝ ops

901
00:37:38,994 --> 00:37:40,594
that's how we do it, Okay?
我们就会那样做

902
00:37:40,595 --> 00:37:42,195
We push things by putting these on the end of the array.
我们通过在数组的最后插入元素来压栈

903
00:37:42,197 --> 00:37:44,196
We pop things by, by pulling it out.
我们再把数组的最后一个元素取出来来出栈

904
00:37:44,198 --> 00:37:45,431
But you can see I got an error there.
但是，你们看到这里我有个 error

905
00:37:45,433 --> 00:37:48,166
[BLANK_AUDIO]

906
00:37:48,168 --> 00:37:49,768
And it's very important to understand why I
要理解为什么我在这里

907
00:37:49,770 --> 00:37:50,835
have an error here, Okay?
有个 error，这非常重要

908
00:37:51,838 --> 00:37:53,704
So I'm gonna click on it.
我点击这里

909
00:37:53,706 --> 00:37:54,805
We're gonna read what it says,
我们看看它说什么

910
00:37:54,807 --> 00:38:00,009
it says, immutable value of type array of op,
它说，数组中的 op 是不可变类型，

911
00:38:00,011 --> 00:38:04,113
only has a mutating member named removeLast.
只有一个可变的成员函数，命名是 removeLast

912
00:38:04,115 --> 00:38:06,548
Okay, well this is kind of a formal way of saying,
好吧这只是一种“正式”的说法

913
00:38:06,550 --> 00:38:13,221
you can't do removeLast on ops because ops is immutable.
你不能在 ops 数组中移除最后一个元素，因为 ops 是不可变的

914
00:38:13,223 --> 00:38:14,455
It's read-only.
它是只读的

915
00:38:14,457 --> 00:38:15,556
You cannot mutate it.
你不能改变它

916
00:38:15,558 --> 00:38:16,990
You cannot change it.
你不能更改它

917
00:38:16,992 --> 00:38:20,160
Okay, why is ops read-only?
ops 为什么是只读的？

918
00:38:20,162 --> 00:38:23,063
Well, there's two things to think about here.
这里有两个问题需要大家思考

919
00:38:23,065 --> 00:38:26,899
One is, when you pass arguments into functions,
一个是，当你给方法传递参数时

920
00:38:26,901 --> 00:38:29,702
unless it's a class that you're passing,
只要你传入的不是一个类

921
00:38:29,704 --> 00:38:32,137
unless you're passing an instance of a class.
只要你传入的不是一个类的实例

922
00:38:32,139 --> 00:38:34,172
The thing you pass is copied.
那么你传入的参数就是拷贝过的

923
00:38:34,174 --> 00:38:35,791
Okay?
Okay?

924
00:38:35,792 --> 00:38:37,409
It's very important to understand that,
弄明白这一点非常重要

925
00:38:37,411 --> 00:38:38,876
that's passed by value.
就是传入的是值

926
00:38:38,878 --> 00:38:40,845
You're used to it in other languages,
你在其他语言中习惯了这一点，

927
00:38:40,847 --> 00:38:43,313
most languages do this, pass by value.
大多数的语言是传递值的

928
00:38:43,315 --> 00:38:46,516
Arrays and dictionaries are not classes.
数组和字典不是类，

929
00:38:47,652 --> 00:38:49,952
They're not classes in Swift.
它们在 Swift 中不是类

930
00:38:49,954 --> 00:38:50,886
They're structs.
它们是结构体

931
00:38:50,888 --> 00:38:52,754
You know, like a C struct?
你知道的，就像 C 语言中的结构体

932
00:38:52,756 --> 00:38:53,955
Okay?
Okay?

933
00:38:53,957 --> 00:38:55,723
Arrays and dictionaries are structs.
数组和字典是结构体

934
00:38:55,725 --> 00:38:58,759
Structs in Swift look a lot like classes.
结构体在 Swift 中看起来很像类

935
00:38:58,761 --> 00:39:00,594
They have functions,
它们有方法

936
00:39:00,595 --> 00:39:02,428
they can even have properties that have storage.
它们甚至拥有带有存取方法的属性

937
00:39:02,431 --> 00:39:04,865
They're almost identical to a class, really.
它们几乎等同于一个类，真的

938
00:39:04,867 --> 00:39:09,102
The only two huge differences between structs and classes.
这里的结构体和类仅有两大不同之处

939
00:39:09,104 --> 00:39:12,638
One is that classes can have inheritance.
一个是，类可以继承

940
00:39:12,640 --> 00:39:15,274
And structs cannot, Okay?
但结构体不可以

941
00:39:15,276 --> 00:39:20,745
But number two is that structs are passed by value and
第二个就是，结构体传递的是值，

942
00:39:20,747 --> 00:39:25,049
classes are passed by reference, Okay?
而类传递的是引用，Okay?

943
00:39:25,051 --> 00:39:27,751
Very important that you understand that distinction.
非常重要，你弄明白这里面的区别

944
00:39:27,753 --> 00:39:30,687
So structs are usually only used for basic.
因此结构体通常仅用于基础数据类型

945
00:39:30,689 --> 00:39:33,289
You know, components like arrays and dictionaries.
你知道的，像数组和字典这样的元素

946
00:39:33,291 --> 00:39:37,159
Even Doubles and Ints are structs in Swift, Okay?
甚至 Double 类型和 Int 类型在 Swift 中都是结构体

947
00:39:37,161 --> 00:39:38,627
>> [COUGH]

948
00:39:38,628 --> 00:39:40,094
>> And that's great because that means Doubles and
这非常棒，因为这意味着 Double 和

949
00:39:40,097 --> 00:39:42,564
Ints can have functions on them and things like that,
Int 也拥有方法和其他类似的语法，

950
00:39:42,566 --> 00:39:44,599
which we will see as the quarter goes by.
随着时间的推移我们可能会看到

951
00:39:44,601 --> 00:39:46,501
But those things are all passed by values.
但是这里传递的都是值

952
00:39:46,503 --> 00:39:48,669
So that's the first thing to understand is that this ops,
因此首先要做的事是

953
00:39:48,671 --> 00:39:52,139
when I call evaluate, whatever array of ops I pass to it,
理解当我调用 evaluate 方法，无论我传什么给 ops 数组

954
00:39:52,141 --> 00:39:53,840
it's gonna be copied.
它都会被拷贝

955
00:39:53,842 --> 00:39:55,108
Okay?
Okay?

956
00:39:55,110 --> 00:39:57,643
The second thing to understand here is that they're kind of
第二件事是理解在这里

957
00:39:57,645 --> 00:40:03,682
an implicit let in front of all things you pass.
在你传递的参数前面，实际上隐含了一个 let

958
00:40:03,684 --> 00:40:05,484
In other words, they're read-only.
换言之，它们是只读的

959
00:40:05,486 --> 00:40:06,651
Make sense?
明白了吗？

960
00:40:06,653 --> 00:40:12,390
And a read-only array can't be mutated.
一个只读的数组不能被改变

961
00:40:12,392 --> 00:40:14,475
I can't append things to it.
我不能给它添加元素

962
00:40:14,476 --> 00:40:16,559
You can't remove things from it cuz it's read-only.
你不能从它身上移除元素，因为它是只读的

963
00:40:16,562 --> 00:40:21,364
Now, I can actually put the word var here, Okay?
现在，你实际上可以写一个 var 在这 ，Okay？

964
00:40:21,366 --> 00:40:22,999
If I, sorry.
如果我...抱歉

965
00:40:23,001 --> 00:40:25,267
If I put the word var here,
如果我写一个词 var 在这里

966
00:40:25,269 --> 00:40:29,204
then ops inside here look no error.
那么 ops 在这个方法体里面看起来就没有错误了

967
00:40:29,206 --> 00:40:32,674
Ops is a mutable array.
Ops 是一个可变数组了

968
00:40:32,676 --> 00:40:34,575
It's still a copy though.
不过它仍然是一个拷贝

969
00:40:34,577 --> 00:40:36,711
So they copied it, made it mutable.
那么它们把 ops 拷贝成了一个可变的副本

970
00:40:36,713 --> 00:40:41,381
And now inside here, I have a mutable copy to work with.
于是在这里面，有一个可变的拷贝在工作了

971
00:40:41,383 --> 00:40:45,084
Now, I'm not a big fan of doing that, kay?
但现在我不想要这么做

972
00:40:45,086 --> 00:40:46,118
Putting var up here.
写一个 var 在这里

973
00:40:46,120 --> 00:40:47,586
I think it's a little confusing for readers of the code,
我认为这对于读代码的人会造成一些困惑，

974
00:40:49,222 --> 00:40:50,855
to understand exactly what's going on there.
要确切地理解这里到底发生了什么

975
00:40:50,858 --> 00:40:53,208
So, I'm not gonna do that,
因此，我不会这样做

976
00:40:53,209 --> 00:40:55,559
instead, I'm gonna make a local variable here, which I'm
而是替换成一个局部变量在这里，

977
00:40:55,562 --> 00:41:00,865
gonna call remainingOps and I'm gonna set it equal to ops.
命名为 remainingOps ，让 remainingOps 等于 ops

978
00:41:00,867 --> 00:41:03,000
Now, when you set equals like this,
注意，当你像这样赋值时，

979
00:41:04,103 --> 00:41:07,103
that copies it if it's not a class.
就将它拷贝了，只要用来赋值的对象不是一个类

980
00:41:07,105 --> 00:41:08,571
Classes are all by reference.
类赋值的都是引用

981
00:41:08,573 --> 00:41:09,438
It's exactly, what you would think.
就好像你们想的那样

982
00:41:09,440 --> 00:41:10,539
But anything else,
但是别的，

983
00:41:10,541 --> 00:41:12,808
strucks or enums or anything else.
像结构体、枚举或者其他的什么

984
00:41:12,810 --> 00:41:14,543
When you do equals here,
当你像这样赋值时，

985
00:41:14,544 --> 00:41:16,277
this is actually going to make a copy of this, and
实际上是做了，这个的拷贝，

986
00:41:16,279 --> 00:41:17,895
put it in here.
然后把它赋给这里

987
00:41:17,896 --> 00:41:19,512
And since it's a var, it's going to be mutable.
因为它是一个变量，所以它是可变的

988
00:41:21,584 --> 00:41:23,083
Okay?
Okay?

989
00:41:23,084 --> 00:41:24,583
So now I have a mutable array of ops and
因此现在我有了一个可变数组 ops

990
00:41:24,586 --> 00:41:26,519
now I can say remainingOps.
现在我可以说 remainingOps

991
00:41:26,521 --> 00:41:27,854
Remove the first one.
移除了栈顶元素

992
00:41:27,856 --> 00:41:30,122
And now I truly do have the remainingOps.
现在我真正有 remainingOps 了

993
00:41:30,124 --> 00:41:32,358
I've removed the last thing in there.
我在这里移除了最后一个元素

994
00:41:32,360 --> 00:41:35,594
[BLANK_AUDIO]

995
00:41:35,596 --> 00:41:38,463
Did everyone understand that little tidbit there?
每个人都理解这个小技巧了嘛？

996
00:41:38,465 --> 00:41:39,464
Yeah? >> So there's a,Yeah？
Yeah? -（学生提问）

997
00:41:39,466 --> 00:41:42,800
like a, a unseen let in sort
of the opts?
-（学生提问）

998
00:41:42,802 --> 00:41:43,600
>> Yeah.>> Why isn't that like in
- Yeah. -（学生提问）

999
00:41:43,602 --> 00:41:47,371
front of Doubles and
-（学生提问）

1000
00:41:47,373 --> 00:41:48,672
like ends or straightened >> It is.
是的

1008
00:41:48,674 --> 00:41:50,873
So, the question is why is there not a kind of unseen,
所以，问题是：为什么不是一种看不见的

1009
00:41:50,875 --> 00:41:52,508
let in front of all arguments?
let 在所有的参数前面？

1010
00:41:52,510 --> 00:41:54,376
Pretty much all arguments to functions kind of
差不多所有的函数里的参数

1011
00:41:54,378 --> 00:41:55,577
have that unseen let in there.
都有个看不见的 let 在那

1012
00:41:55,579 --> 00:41:57,545
They're all read on, 'kay?
这些都是默认的

1013
00:41:57,547 --> 00:41:59,681
So and you could put var in front of any one and
所以你可以把 var 放在任何一个参数前面

1014
00:41:59,683 --> 00:42:02,516
turn it into a mutable copy of it,
把这个变成可以在本地用的

1015
00:42:02,518 --> 00:42:03,484
that you could use locally.
一个可变的复制

1016
00:42:03,486 --> 00:42:04,885
But if you only use it locally,
但如果你在本地用这个

1017
00:42:04,887 --> 00:42:06,219
it's not that great a thing.
这不是个好事

1018
00:42:06,221 --> 00:42:08,371
Okay?
Okay？

1019
00:42:08,372 --> 00:42:10,522
Now, there is a way to have, to pass by value things back
现在，有一种通过值去获取、传递回来的方法

1020
00:42:10,525 --> 00:42:13,959
out, but I'm not even gonna talk about that.
但是我不打算讲

1021
00:42:13,961 --> 00:42:14,726
Okay.
Okay.

1022
00:42:14,728 --> 00:42:16,027
You can read about it.
你可以读到关于这些的东西

1023
00:42:16,029 --> 00:42:17,328
It's this in out thing.
传入、传出的事情

1024
00:42:18,698 --> 00:42:20,665
I'm not even gonna talk about it.
我不打算讲

1025
00:42:20,666 --> 00:42:22,633
I really think it's better to stay within the value,
我真的觉得还是在值上更好

1026
00:42:22,635 --> 00:42:25,035
pass by value, pass by reference parameters.
通过值或者引用传递参数

1027
00:42:25,037 --> 00:42:27,604
I think you can get more readable code that way.
我想你可以通过那种方式来写出可读性更高的代码

1028
00:42:27,606 --> 00:42:30,139
But there is a way, there is a way I'm not going to talk
但是我不想讲

1029
00:42:30,141 --> 00:42:33,075
about to do in out basically, parameters that go in out.
那种传入传出的方式

1030
00:42:33,077 --> 00:42:33,842
Yeah.
Yeah

1031
00:42:33,844 --> 00:42:36,712
>> Is there any way to
－（学生提问）

1032
00:42:36,714 --> 00:42:39,180



1033
00:42:39,182 --> 00:42:40,949
>> Yeah that's what I just said.
这就是我刚才提到的

1034
00:42:40,950 --> 00:42:42,717
There is a way to pass it kind of by reference in out.
有一种通过引用传递参数的方式

1035
00:42:42,719 --> 00:42:44,618
You know, you pass it in, you modify it,
如果传入后，改变它

1036
00:42:44,620 --> 00:42:47,054
and then it'll come back out when it's done at the end.
在完成后、结尾时更改就会生效

1037
00:42:47,056 --> 00:42:48,255
So, it's kind of like by reference.
所以这就是一种通过引用传递

1038
00:42:49,224 --> 00:42:50,323
But the other thing you said is,
但你可能又会说了

1039
00:42:50,325 --> 00:42:52,558
oh this is terrible I'm making three copies of
把这个值做了三次复制

1040
00:42:52,560 --> 00:42:55,394
that dang thing, this must be super slow.
真是一件很糟糕的事，会让程序变的非常慢

1041
00:42:55,396 --> 00:42:57,029
And the answer is no.
但答案是否定的

1042
00:42:57,031 --> 00:43:01,599
Swift is super smart about not actually copying it,
Swift 是不会真的复制它的

1043
00:43:01,601 --> 00:43:04,135
until you actually make a change to it.
直到你真的改变它

1044
00:43:04,137 --> 00:43:07,271
So here when it passes a copy in it didn't really
所以当传入一个拷贝的时候

1045
00:43:07,273 --> 00:43:10,073
copy it, it just kinda passed a pointer in but it knows that
并不是真的复制了，而是传入一种指针

1046
00:43:10,075 --> 00:43:13,576
pointer is by, you know, not by reference it's by value.
一种它知道从哪来的指针，不是通过引用而是值

1047
00:43:13,578 --> 00:43:15,611
And then when I copied it again here.
然后我们再次在这复制

1048
00:43:15,613 --> 00:43:17,146
It still didn't really copy it.
这还是不会真的复制

1049
00:43:17,148 --> 00:43:19,081
Even if this array had 10,000 things in it,
甚至这个数组里有一万条数据

1050
00:43:19,083 --> 00:43:21,116
it didn't make 10,000 copy of it.
它不会做一万次复制

1051
00:43:21,118 --> 00:43:25,019
It was only here where I actually mutated,
只有在这我真正改变的地方

1052
00:43:25,021 --> 00:43:26,120
now it had to make a copy.
它就必须得复制了

1053
00:43:26,122 --> 00:43:28,989
And it may not even have made an entire copy.
并且这可能甚至不会做一个完整的复制

1054
00:43:28,991 --> 00:43:32,025
It might have just kept track of the changes, for example.
它可能只会追踪改变的地方

1055
00:43:32,027 --> 00:43:33,860
So, it's super smart behind the scenes.
所以这真的非常智能

1056
00:43:33,862 --> 00:43:34,861
Sweet to very smart.
真的很智能

1057
00:43:34,863 --> 00:43:36,862
So, don't worry too, about much about oh,
所以不必总是担心

1058
00:43:36,864 --> 00:43:38,630
I'm copying these things over and over.
我一遍一遍的复制这些

1059
00:43:38,632 --> 00:43:40,332
Swift is making the minimum out of
Swift 在做复制之前

1060
00:43:40,334 --> 00:43:41,433
actual copying going on.
只做了少量的工作

1061
00:43:41,435 --> 00:43:42,600
Okay?
Okay?

1062
00:43:42,602 --> 00:43:47,171
All right, so now I have remainingOpts here,
好的，现在这就有了 remainingOps

1063
00:43:47,173 --> 00:43:49,840
which truly are my remaining ops
是真的余下的那个 ops

1064
00:43:49,842 --> 00:43:51,842
'Kay. Because I've
因为我已经

1065
00:43:51,843 --> 00:43:53,843
removed the top one, the x, off the top.
把最上面的那个 x 从栈顶移除了

1066
00:43:53,845 --> 00:43:56,279
So now I've got all the remainingOps,
所以我得到了所有的 remainingOps

1067
00:43:56,281 --> 00:43:59,181
in this local variable here called remainingOps.
 在这个叫 remainingOps 的局部变量

1068
00:43:59,183 --> 00:44:00,566
Okay.
Okay

1069
00:44:00,567 --> 00:44:01,950
Now, what am I gonna do with this op that I pulled off,
现在，我现在要对这个已经取出来的 op 做什么呢？

1070
00:44:01,952 --> 00:44:03,218
this one on the top, x?
这个在栈顶的 x

1071
00:44:03,220 --> 00:44:06,621
Well I'm gonna get the associated value from
我想从枚举中

1072
00:44:06,623 --> 00:44:07,888
the enum.
得到这个关联变量

1073
00:44:07,890 --> 00:44:11,792
'Kay. Either this or these or this.
可能是这个，这个或这个

1074
00:44:11,794 --> 00:44:13,226
And how do I do that?
那么我该怎么做呢？

1075
00:44:13,228 --> 00:44:15,094
I use switch.
我用 switch

1076
00:44:15,096 --> 00:44:17,496
'Kay, I told you that switch is really important.
我告诉过你们 switch 很重要

1077
00:44:17,498 --> 00:44:20,032
And now you're seeing that switch is really important.
现在你们看到了它真的很重要

1078
00:44:20,034 --> 00:44:21,867
switch is how you pull things out,
switch 用来把

1079
00:44:21,869 --> 00:44:23,668
associated values out of enums.
关联变量取出枚举

1080
00:44:23,670 --> 00:44:25,036
So I'm just gonna switch on the op.
所以我想在 op 上用 switch

1081
00:44:25,038 --> 00:44:27,772
'Kay, this is the op that I pulled off the top,
这就是我从上面取得的 op

1082
00:44:27,774 --> 00:44:30,708
that x from the thing we did on the board.
那个 x 就是我们之前取得的

1083
00:44:30,710 --> 00:44:32,109
And I'm just gonna look at the cases, so
我现在只会关注这些 case

1084
00:44:32,111 --> 00:44:35,412
I have the case operand, Okay.
case .Operand

1085
00:44:35,414 --> 00:44:38,581
Notice that it puts a little dot here because it's
注意这里放了个小点

1086
00:44:38,583 --> 00:44:41,450
really Op.Operand and it's using type inference to
因为这应该是 Op.Operand，并且用了类型推断

1087
00:44:41,452 --> 00:44:43,652
know that it's Op.Operand, right.
为了清楚这是 Op.Operand

1088
00:44:43,654 --> 00:44:47,289
Op.op, Op.Operand but it doesn't need the Op there.
Op.op, Op.Operand 但这里不需要 Op

1089
00:44:47,291 --> 00:44:50,892
And here it's asking in this space, what do you wanna do
在这里

1090
00:44:50,894 --> 00:44:54,628
with the associated value if you're handling this case.
你想在这个 case 里对相关变量做什么

1091
00:44:54,630 --> 00:44:56,864
Where the enum is operand.
对于相关的枚举 operand

1092
00:44:56,866 --> 00:44:58,432
'Kay?
Okay?

1093
00:44:58,434 --> 00:45:04,037
Well I want to let that associated value
我想在那个关联变量前面放个 let

1094
00:45:04,039 --> 00:45:10,175
be assigned to a constant called operand.
用来关联一个叫做 operand 的常量

1095
00:45:10,177 --> 00:45:11,510
'Kay?
Okay?

1096
00:45:11,512 --> 00:45:14,746
And yes I could put var here, which would do the same thing,
我当然也可以放个 var 在这，也一样有用

1097
00:45:14,748 --> 00:45:17,715
except for I could then change the thing in here.
除非我之后把这里的东西改变了

1098
00:45:17,717 --> 00:45:20,685
But I almost never wanna do this, almost always let.
但我几乎从来都不会这样做，几乎都用 let

1099
00:45:20,687 --> 00:45:23,887
So let operand means that inside the handling of
所以 let operand 表示在这个 case 中

1100
00:45:23,889 --> 00:45:27,157
this case, 'kay, this case of the switch.
这个 switch 中的这个 case

1101
00:45:27,159 --> 00:45:30,693
Inside here, operand is gonna have the associated value of
在这里面，operand 就会获得

1102
00:45:30,695 --> 00:45:31,427
the operand.
operand 的关联变量

1103
00:45:32,430 --> 00:45:34,196
'Kay?
'Kay?

1104
00:45:34,198 --> 00:45:35,897
Oh, that's exactly what I want.
这就是我想要的

1105
00:45:35,899 --> 00:45:38,599
I'm just gonna return right now I have to return this
我现在就要返回一个值

1106
00:45:38,601 --> 00:45:40,301
Tuple right here.
我要返回一个 Tuple

1107
00:45:40,303 --> 00:45:42,569
So I'm gonna returned the operand.
所以我要返回 operand

1108
00:45:42,571 --> 00:45:45,005
That's the result, 'kay.
这就是结果

1109
00:45:45,007 --> 00:45:47,191
When I go here and
当我到这

1110
00:45:47,192 --> 00:45:49,376
I encounter that next one down which was a four, I got a four
我碰到下一个是 4，我得到一个 4

1111
00:45:49,378 --> 00:45:52,845
I can just return that result to evaluate this one.
我可以直接返回这个结果来计算它

1112
00:45:52,847 --> 00:45:55,881
And I also though have to return the remainingOps.
当然我也需要返回 remainingOps

1113
00:45:57,018 --> 00:46:00,085
'Kay, so I'm just returning the two values of this Tuple,
所以我返回了 Tuple 里的两个值

1114
00:46:00,087 --> 00:46:02,754
notice I don't have to put result: and
注意我没有在这放 result:

1115
00:46:02,756 --> 00:46:06,390
remainingOps:  colon in here it knows that those match and
remainingOps: ，因为这里知道这些是对应的

1116
00:46:06,392 --> 00:46:07,224
so it's still doing it.
所以这还是会正常执行

1117
00:46:07,226 --> 00:46:09,159
All right, makes sense.
好的，懂了吧

1118
00:46:09,161 --> 00:46:13,763
That's it for operand that's all I have to do.
这就是我对 operand 做的一切

1119
00:46:13,765 --> 00:46:15,064
It's kind of a, in the recursion,
这在递归中

1120
00:46:15,066 --> 00:46:20,102
it's kind of an end case.
是一种结束的情况

1121
00:46:20,104 --> 00:46:21,069
Yeah? >> Is remainingOps part of
－（学生提问）

1122
00:46:21,071 --> 00:46:22,520
the stack or heap?
－（学生提问）

1123
00:46:22,521 --> 00:46:23,970
>> This one here, or this one here?
－（学生提问）

1124
00:46:23,973 --> 00:46:24,989
>> What in general [INAUDIBLE].
－（学生提问）

1125
00:46:24,990 --> 00:46:26,006
>> Okay so, so the question is,
问题是：

1126
00:46:26,009 --> 00:46:29,276
when I do something like this, where is remainingOps?
当我像这样做的时候，remainingOps 在哪？

1127
00:46:29,278 --> 00:46:30,377
Is it in the heap?
在堆中吗？

1128
00:46:30,379 --> 00:46:31,812
Is it on the stack?
还是在栈中？

1129
00:46:31,813 --> 00:46:33,246
And the thing is, that's implementation detail.
事实上这些是实现时的细节

1130
00:46:34,282 --> 00:46:36,148
So, you, you don't know, but you don't care.
所以你不知道，也不用关心

1131
00:46:38,018 --> 00:46:40,185
All right, so that's operand.
这就是 operand

1132
00:46:40,187 --> 00:46:42,020
Operand was really, really easy.
operand真的非常非常简单

1133
00:46:42,022 --> 00:46:44,321
How about our operation, that's you, you,
那么关于这里 UnaryOperation

1134
00:46:44,323 --> 00:46:46,090
UnaryOperation right here.
的操作是怎么样的呢

1135
00:46:46,092 --> 00:46:49,659
Now when we handle the case of the unary operation,
当我们要处理 UnaryOperation

1136
00:46:49,661 --> 00:46:52,195
 we don't need that first associated value,
我们不需要第一个变量

1137
00:46:52,197 --> 00:46:54,330
that's the symbol, like plus.
这是符号，像是加号

1138
00:46:54,332 --> 00:46:56,332
Okay well I'm evaluating here I don't care what this
当我在这计算的时候我不在乎它是什么

1139
00:46:56,334 --> 00:46:58,500
symbol is, I only care what the function is cause I'm
我只在乎那个函数是什么

1140
00:46:58,502 --> 00:47:00,002
gonna evaluate the function.
因为我要去计算那个函数

1141
00:47:00,004 --> 00:47:05,807
So we can actually ignore this by putting in underbar, 'kay?
所以我们实际上可以在这放一个下划线来忽略它

1142
00:47:05,809 --> 00:47:08,642
Underbar in Swift is kind of
下划线在 Swift 里

1143
00:47:08,644 --> 00:47:12,212
the universal I don't care about this thing.
就是一种“我不关心这个”的通用表达

1144
00:47:12,214 --> 00:47:14,681
Okay and we're gonna see it other places we use it
我们还会在其它地方

1145
00:47:14,683 --> 00:47:16,549
where it's kinda like, I don't really care about that.
使用下划线来表达“我不关心这个”

1146
00:47:16,551 --> 00:47:18,251
So you just put an underbarthere.
所以你只需要放一个下划线在这

1147
00:47:18,253 --> 00:47:19,819
That way you don't have to declare a variable with
这样你就不需要声明一个奇怪的变量

1148
00:47:19,821 --> 00:47:22,221
some dumb name or something like that.
或者跟他相似的东西

1149
00:47:22,223 --> 00:47:24,389
Just put an underbar it ignores it.
只是放一个下划线在这

1150
00:47:24,391 --> 00:47:25,323
'Kay?
'Kay?

1151
00:47:25,324 --> 00:47:26,256
But I do care about this.
但我真的关心这个

1152
00:47:26,259 --> 00:47:29,794
I'm gonna let that equal the operation that I'm doing.
我会放 let operation 在这

1153
00:47:29,796 --> 00:47:30,361
'Kay?
'Kay?

1154
00:47:31,397 --> 00:47:32,929
Everyone, make sense there?
所有人都懂了吗？

1155
00:47:32,931 --> 00:47:34,897
So I'm ignoring the String, but
所以我忽略了 String

1156
00:47:34,899 --> 00:47:36,699
I'm grabbing the operation.
我在获取 operation

1157
00:47:36,701 --> 00:47:40,402
So here, what I wanna do is return and I'll try to do it,
所以这里我试着返回

1158
00:47:40,404 --> 00:47:41,370
but I'm not gonna be able to.
我还没法做

1159
00:47:41,372 --> 00:47:45,540
I'm gonna say, return this operation with
我会返回我还没有的 operation

1160
00:47:45,542 --> 00:47:48,342
its operand which I don't have.
还有 operand

1161
00:47:48,344 --> 00:47:51,512
And there's some remaining ops that are leftover after I
还有一些我获取 operand 后

1162
00:47:51,514 --> 00:47:52,579
get the operand.
余下的 ops

1163
00:47:52,581 --> 00:47:55,515
So I'm kinda, I need to do some stuff here to
所以我要在这做一些

1164
00:47:55,517 --> 00:47:58,251
be able to return what I want.
能让我返回我想要的东西的操作

1165
00:47:58,253 --> 00:48:01,053
The first thing I need to do is get the operand.
第一件事就是获取 operand

1166
00:48:01,055 --> 00:48:03,689
'Kay?
'Kay?

1167
00:48:03,690 --> 00:48:06,324
So, I did a unary operation let's say it was square root.
例如我要处理平方根

1168
00:48:06,326 --> 00:48:07,625
I need to go back to the staff and
我需要返回到那个地方

1169
00:48:07,627 --> 00:48:10,862
pick off the next thing but I can't just
来获得下一个东西，但我不能

1170
00:48:10,864 --> 00:48:13,931
assume that it's a number, it might be more operations so
假定这是一个数字，接下来可能是更多的操作符

1171
00:48:13,933 --> 00:48:17,001
I have to recurse, so here's where the recursion comes in.
所以我需要递归，这里就是用到递归的地方

1172
00:48:17,003 --> 00:48:20,103
And I'm gonna show you how to call a function that
我会展示如何调用一个函数

1173
00:48:20,105 --> 00:48:22,172
returns a Tuple.
返回一个 Tuple

1174
00:48:22,174 --> 00:48:25,274
And get it's value up so this is important little example
获得这个值，所以这是这里一个重要的例子

1175
00:48:25,276 --> 00:48:27,677
here, so there's two ways to do it.
所以有两种方法来实现

1176
00:48:27,679 --> 00:48:30,279
I'm gonna do it one way here, which is,
我会在这里做其中一种

1177
00:48:30,281 --> 00:48:32,881
I'm gonna let operandEvaluation,
let operandEvaluation

1178
00:48:32,883 --> 00:48:37,919
which is just a local variable that I'm inventing, equal call
一个我声明的局部变量

1179
00:48:37,921 --> 00:48:43,057
evaluate with the remainingOps that I have.
等于 evaluate(remainingOps)

1180
00:48:43,059 --> 00:48:45,025
'Kay, so here I've recursed.
这样我就递归了

1181
00:48:45,027 --> 00:48:46,459
Okay, I'm recursing.
我正在做一个递归

1182
00:48:46,461 --> 00:48:48,661
And I just set it to operandEvaluation.
我把他赋给 operandEvaluation

1183
00:48:48,663 --> 00:48:51,564
Now, let's look at the type of this thing.
来看看它的类型

1184
00:48:51,566 --> 00:48:55,300
If I look at its type, you can see that it's a Tuple.
如果你看它的类型，就会发现它是一个 Tuple

1185
00:48:55,302 --> 00:48:56,468
That's its type.
这就是他的类型

1186
00:48:56,470 --> 00:48:58,770
It's a Tuple result remainingOps.
这是一个 Tuple 类型，里面有 result 和 remainingOps

1187
00:48:58,772 --> 00:49:00,671
It's this Tuple right here.
就是这边的这个 Tuple

1188
00:49:00,673 --> 00:49:03,140
That is the type of this operandEvaluation.
就是这个 operandEvaluation 的类型

1189
00:49:04,309 --> 00:49:06,242
So now that I have that Tuple,
所以现在我有了这个 Tuple

1190
00:49:06,244 --> 00:49:09,245
it's the result of evaluation how do I get the result and
这就是计算的结果，我是怎么获得的这个结果

1191
00:49:09,247 --> 00:49:13,716
the remaining op out of it well I can get the operand by
获得这些余下的 op

1192
00:49:13,718 --> 00:49:19,621
saying operand eval, operandEvaluation.result.
只要 let operand = operandEvaluation.result

1193
00:49:19,623 --> 00:49:21,423
'Kay?
'Kay?

1194
00:49:21,424 --> 00:49:23,224
So that just pull this is the Tuple here I'm
所以只是把 Tuple 放这

1195
00:49:23,226 --> 00:49:26,227
getting this value of the Tuple out of there.
就获得了这里 Tuple 的值

1196
00:49:26,229 --> 00:49:27,461
Now what type is this?
这个的类型是什么

1197
00:49:29,298 --> 00:49:29,863
Anybody?
有人知道吗

1198
00:49:30,865 --> 00:49:31,931
It's an Optional.
这是个 Optional

1199
00:49:31,932 --> 00:49:32,998
You're pretty safe saying Optional when I
当我问你这是什么类型时

1200
00:49:33,001 --> 00:49:34,099
ask what type it is, aren't you?
说 Optional 是很安全的

1201
00:49:34,101 --> 00:49:35,801
It's almost always an Optional.
答案总可以是 Optional

1202
00:49:35,803 --> 00:49:37,168
Cuz I usually don't ask if it's not.
如果它不是我才不会问呢

1203
00:49:37,170 --> 00:49:40,672
But it is indeed an Optional, an Optional Double.
但是在这它确实是个 Optional，一个 Optional Double 型

1204
00:49:40,674 --> 00:49:42,707
It's this type right here, Okay?
这就是它的类型

1205
00:49:42,709 --> 00:49:46,043
So we need to turn it into a Double if we're gonna pass it
如果我们想把它传入这里，

1206
00:49:46,045 --> 00:49:48,078
to this operation right here.
就得把它变成一个 Double 类型的

1207
00:49:48,080 --> 00:49:52,648
So I'm gonna use if let to turn that into a Double.
所以在这里我是用 if let 来把它变成 Double

1208
00:49:52,650 --> 00:49:55,084
'Kay?

1209
00:49:55,085 --> 00:49:57,519
Now, I can actually do this because I have the operand.
我确实可以这么做，因为我已经有了操作数

1210
00:49:57,521 --> 00:49:58,587
Just got it right here.
从这里获取到的

1211
00:49:58,589 --> 00:50:00,755
'Kay? This is now a Double, see?
它现在变成 Double 了

1212
00:50:00,757 --> 00:50:04,125
And I can call this operation right here.
我可以在这里调用这个运算

1213
00:50:04,127 --> 00:50:06,327
And this is the remaining ops, but this has got to
这里是余下的 ops，

1214
00:50:06,329 --> 00:50:09,229
be the remaining ops after we recursed.
但这里得放递归之后余下的 ops

1215
00:50:09,231 --> 00:50:13,233
So it's gotta be the remaining ops in this operandEvaluation.
它得是这个 operandEvalution 余下的 ops

1216
00:50:13,235 --> 00:50:15,368
So that operandEvaluation.remainingOps.
所以这里放 operandEvaluation.remainingOps

1217
00:50:15,370 --> 00:50:19,471
Everybody cool with that?
都懂了吗？

1218
00:50:19,473 --> 00:50:21,206
So that's it.
就这么简单

1219
00:50:21,208 --> 00:50:25,343
It's just recurse, we just recursed to evaluate that.
我们为了计算而进行递归

1220
00:50:25,345 --> 00:50:29,180
If this fails if, if this recursion returned nil,
如果这步失败了，这次递归返回 nil

1221
00:50:29,182 --> 00:50:31,849
then this is, this, if let's not gonna happen this
这里都不会进行

1222
00:50:31,851 --> 00:50:34,584
return's not gonna happen, gonna fall all the way out and
不会 return，然后一路向下运行，

1223
00:50:34,586 --> 00:50:37,454
return nill which is what we want, 'kay.
最后返回我们需要的 nil

1224
00:50:37,456 --> 00:50:39,522
We failed in any of our recursive attempts to
如果为了得到操作数

1225
00:50:39,524 --> 00:50:40,756
get the operands we need,
递归失败了

1226
00:50:40,758 --> 00:50:42,825
we gotta fail all the way up to the top level.
就是一路失败到最顶层的递归

1227
00:50:42,827 --> 00:50:46,028


1228
00:50:46,030 --> 00:50:48,063
Okay now binary operation.
现在谈谈双目操作符

1229
00:50:49,299 --> 00:50:52,466
Also Okay, let's do yeah, binary here case.
在这个 case 里处理双目操作符

1230
00:50:53,535 --> 00:50:54,267
Binary.
输入Binary

1231
00:50:55,470 --> 00:50:57,570
Obviously same exact thing here.
显然，跟上面一样

1232
00:50:57,572 --> 00:50:59,438
We don't care about that.
我们不需要关心这个

1233
00:50:59,440 --> 00:51:00,906
And here we're gonna let operation.
在这里，let operation

1234
00:51:00,908 --> 00:51:03,708
And we're gonna do the exactly the same thing we did
跟之前做相同的事情

1235
00:51:03,710 --> 00:51:06,577
here but we just have to do it twice because we have two
但在这里得做两次

1236
00:51:06,579 --> 00:51:08,646
operands to do here, through here.
因为我们得获取到两个操作数

1237
00:51:08,648 --> 00:51:15,052
So let's let opp1Evaluation = evaluate(remainingOps).
所以，let opp1Evaluation = evaluate(remainingOps)

1238
00:51:16,088 --> 00:51:17,487
'Kay.

1239
00:51:17,488 --> 00:51:18,887
And then if we can let operand1 =
如果我们 let operand1 =

1240
00:51:18,890 --> 00:51:20,756
op1Evaluation.result.
op1Evaluation.result

1241
00:51:20,758 --> 00:51:23,625
'Kay, then we got op1, that's good.
我们就得到了 op1，还不错

1242
00:51:23,627 --> 00:51:27,262
So now let's let op2Evaluation =
现在我们再 let op2Evaluation =

1243
00:51:27,264 --> 00:51:32,600
evaluation(op1Evaluation.remainingOps).
evaluation(op1Evaluation.remainingOps)

1244
00:51:32,602 --> 00:51:36,370
'Kay?

1245
00:51:36,371 --> 00:51:40,139
And if we can let operand, oops, if we can let operand2
如果在这里 let operand2

1246
00:51:40,142 --> 00:51:44,844
= op2Evaluation.result,
= op2Evaluation.result，

1247
00:51:44,846 --> 00:51:50,716
then we can return (operation(operand1, operand2).
然后 return (operation(operand1, operand2)

1248
00:51:50,718 --> 00:51:53,185
'Kay?


1249
00:51:53,186 --> 00:51:55,653
And we'll have op2Evaluation.remainingOps
接着把 op2Evaluation.remainingOps

1250
00:51:55,656 --> 00:51:57,355
as our remaining ops.
作为余下的 ops

1251
00:51:57,357 --> 00:52:00,825
Okay?


1252
00:52:00,827 --> 00:52:01,692
Make sense?
明白了吗

1253
00:52:01,694 --> 00:52:02,426
All right.
好的

1254
00:52:02,428 --> 00:52:03,159
We have an error here.
哦，出现了个 error

1255
00:52:03,161 --> 00:52:04,560
What is it?
看看它错哪了

1256
00:52:04,562 --> 00:52:05,695
Okay.
我明白了

1257
00:52:05,696 --> 00:52:06,829
Yeah, this is a good error to cover here.
这个 error 值得一讲

1258
00:52:06,831 --> 00:52:09,665
See this it says method must be declared private
看这，它说函数必须被声明为 private

1259
00:52:09,667 --> 00:52:12,501
because this parameter uses a private type.
因为它的参数使用了 private 类型

1260
00:52:12,503 --> 00:52:16,137
And sure enough op is private so this has to be private.
显然由于 op 是 private 的，这个函数也得是 private 的

1261
00:52:17,740 --> 00:52:19,273
'Kay?

1262
00:52:20,476 --> 00:52:21,875
Now notice by the way,
注意

1263
00:52:21,877 --> 00:52:28,080
I don't have default: break here in this switch.
这个 switch 我没有写 default: break

1264
00:52:28,082 --> 00:52:30,215
And why do I not have that?
我之所以没写

1265
00:52:30,217 --> 00:52:33,418
Because I've handled every possible value of op.
是因为我已经处理了 op 的每一个可能的情形

1266
00:52:35,088 --> 00:52:35,986
'Kay?


1267
00:52:35,988 --> 00:52:37,254
There are only three kinds of op.
这里只有三种 op

1268
00:52:37,256 --> 00:52:38,522
I've handled them all.
每一种我都处理过了

1269
00:52:38,524 --> 00:52:40,374
So I don't need any default.
所以就不需要 default 了

1270
00:52:40,375 --> 00:52:42,225
It wasn't like in the other one where we had a String and
这不像上一个处理 String 的 switch

1271
00:52:42,227 --> 00:52:44,761
we only handle a few Strings, we had a default break.
我们只处理了几个 String，所以需要写 default: break

1272
00:52:44,763 --> 00:52:47,863
You don't put default break in when you handle every thing.
如果能处理完所有情况，就不需要 default: break 了

1273
00:52:47,865 --> 00:52:49,598
And it's really bad programing style to
而且在每一个 switch 后面都放一个 default: break

1274
00:52:49,600 --> 00:52:51,633
put a default break in every single switch.
是一种很不好的编程风格

1275
00:52:51,635 --> 00:52:54,903
'Kay, you should only put them in the ones where you
除非你真的没法处理所有的情况

1276
00:52:54,905 --> 00:52:58,373
truly are breaking because you can't handle every case.
必须得要一个 break 才行

1277
00:52:58,375 --> 00:53:00,574
'Kay? All right.
好的我们继续。

1278
00:53:00,576 --> 00:53:03,844
Now, the last thing we have to do is just call this recursive
那么最后要做的

1279
00:53:03,846 --> 00:53:06,113
version from here.
就是调用这个递归

1280
00:53:06,115 --> 00:53:08,782
And I'm gonna call this one and
这次调用它来获取 Tuple 值的方式

1281
00:53:08,784 --> 00:53:11,117
get these Tuple values a little differently.
略有不同

1282
00:53:11,119 --> 00:53:12,718
I'm not gonna call it in the same way here.
我不会像上次那么调用

1283
00:53:12,720 --> 00:53:14,920
I'm not gonna say, let something equal.
我不会写 let XX = XX 这种

1284
00:53:14,922 --> 00:53:20,091
Instead I'm gonna say let a Tuple which has let's call it
我会 let 一个 Tuple ，

1285
00:53:20,093 --> 00:53:24,062
say (result, remainder) = evaluate
比如 (result, remainder) = evaluate

1286
00:53:24,064 --> 00:53:28,666
and I'm gonna pass my whole (opStack) here, Okay.
我要把整个 opStack 传进去

1287
00:53:28,668 --> 00:53:31,668
So this is a different way to call a function that returns
这里就是调用能返回 Tuple 的函数的不同方法

1288
00:53:31,670 --> 00:53:35,305
a Tuple here you actually let a Tuple equal the result.
其实是令一个 Tuple 等于函数的返回值

1289
00:53:35,307 --> 00:53:37,974
Instead of letting a single thing equal result and
而不是让一个单独的东西等于返回值再

1290
00:53:37,976 --> 00:53:42,111
then using the dots to get it, you let the Tuple equal it and
使用 . 来获取元素，你是令 Tuple 等于后面这些

1291
00:53:42,113 --> 00:53:45,547
notice that these names don't have to be the same as these
顺便注意这些名字并不必须和上面这些相同

1292
00:53:45,549 --> 00:53:48,283
names so result is the same, but here I
两个 result 是一样的，但是这里

1293
00:53:48,285 --> 00:53:52,286
use the word remainder instead of the word remainingOps.
我用了 remainder 而没有用 remainingOps

1294
00:53:52,288 --> 00:53:53,754
Okay they do not have to be the same.
它们不必相同

1295
00:53:55,024 --> 00:54:00,694
And then here we just return our result.
在这里，返回我们的结果

1296
00:54:00,696 --> 00:54:02,261
Okay?

1297
00:54:02,263 --> 00:54:04,163
So we learned a lot right there, Okay.
在这我们讲了很多

1298
00:54:04,165 --> 00:54:05,297
We learned about Tuple,
我们讲了 Tuple

1299
00:54:05,299 --> 00:54:08,033
passing, you know, things back Tuples in
讲了通过不同的方法获取 Tuple

1300
00:54:08,035 --> 00:54:13,237
different ways, you know, how to ignore things in enums, and,
以及要得到所需的值或者其他的东西的时候

1301
00:54:13,239 --> 00:54:15,106
when we're getting associate values, all that stuff.
如何在 enum 里忽略一些东西

1302
00:54:15,108 --> 00:54:16,974
So hopefully, you got all that.
希望你们都掌握了

1303
00:54:16,976 --> 00:54:19,676
I see a few people still kinda catching up on their typing.
我看到有些同学仍然在忙着敲代码

1304
00:54:19,678 --> 00:54:21,444
So I'll break for second here.
那我就暂时等你们一下

1305
00:54:21,446 --> 00:54:24,480


1306
00:54:24,482 --> 00:54:27,283
So that's it that's the entire implementation of
这就是我们计算器的 calculator brain

1307
00:54:27,285 --> 00:54:28,384
our calculator brain.
全部的实现过程

1308
00:54:28,386 --> 00:54:30,919
It wasn't really that bad actually, right?
其实它并没有那么难理解，对吗？

1309
00:54:30,921 --> 00:54:33,722
Pretty simple little data structure here.
很简单的数据结构

1310
00:54:33,724 --> 00:54:36,858
Just have to say what our known ops are.
只需要说清我们要用哪些 ops

1311
00:54:36,860 --> 00:54:38,726
And have this recursion which you know,
再加上这个递归

1312
00:54:38,728 --> 00:54:42,196
actually is quite simple, powerful code.
这其实就是一段简单而功能强大的代码

1313
00:54:42,198 --> 00:54:44,031
If you're not comfortable with your recursion
如果你不明白这个递归

1314
00:54:44,033 --> 00:54:46,533
I can see how it might be a little bit disturbing.
我也知道它确实有些地方有点烦人

1315
00:54:46,535 --> 00:54:48,301
But go stare at it for a while
但如果你多看看这段代码

1316
00:54:48,302 --> 00:54:50,068
and you'll, you'll get it, how it works.
你就会明白它的原理了

1317
00:54:50,071 --> 00:54:51,921
Okay.

1318
00:54:51,922 --> 00:54:53,772
So, now that we've got this new calculator brain,
既然我们已经有了这个新的 calculator brain

1319
00:54:53,775 --> 00:54:57,509
we have to use it in our old Controller.
我们得把它用在之前的 Controller 上

1320
00:54:57,511 --> 00:54:59,678
Okay, yeah question?
说你的问题

1321
00:54:59,679 --> 00:55:01,846
- Do we have to let the opStack equal the remainder?
- 我们必须得让 opStack 等于 remainder 吗？

1322
00:55:01,848 --> 00:55:04,549
Do we have to let the opStack equal the remainder?
我们是不是得让 opStack 等于 remainder

1323
00:55:04,551 --> 00:55:05,349
Here, you mean?
你是说这段代码吗？

1324
00:55:05,351 --> 00:55:05,916
- Yeah.
- 是的！

1325
00:55:07,119 --> 00:55:08,418
well, we're not gonna use remainder, so
嗯，我们不必让它等于 remainder

1326
00:55:08,420 --> 00:55:10,620
actually, even I could put I don't care here.
实际上，这个 remainder 甚至可以写成 ‘I don't care’

1327
00:55:10,622 --> 00:55:13,255
I only put that remainder there to show you could have
我在这用 remainder 只是想让你们知道

1328
00:55:13,257 --> 00:55:15,257
a different name, but I'm not using the remainder.
你可以起一个不同的名称，我实际没有使用 remainder 这个变量

1329
00:55:15,259 --> 00:55:16,892
I only want the result. You see.
我只需要一个结果。你看这（被学生打断）

1330
00:55:16,894 --> 00:55:19,861
- Won't the opStack contain
- 在你计算 opStack 之前，

1331
00:55:19,862 --> 00:55:22,829
- what was previously in it before you evaluate it?
- 它不包含原先在它里面的东西吗？

1332
00:55:22,832 --> 00:55:25,016
Yes, the opStack will be
是的，但是这不会影响到 opStack

1333
00:55:25,017 --> 00:55:27,201
unaffected by this because opStack is an array.
因为它是一个数组

1334
00:55:27,203 --> 00:55:28,702
Arrays are passed by value so
数组是通过值传递的，

1335
00:55:28,704 --> 00:55:30,837
a copy of it gets passed into here.
它的一个 copy 被传递到这里

1336
00:55:30,839 --> 00:55:33,506
So this would be untouched and which is what I want.
所以它不会改变，这正是我想要的

1337
00:55:33,508 --> 00:55:36,242
I don't want evaluate to consume my opStack.
我不想 evaluate 方法耗尽我的运算栈

1338
00:55:36,244 --> 00:55:38,010
I wanna be able to call evaluate over and
我希望它一遍又一遍的

1339
00:55:38,012 --> 00:55:38,744
over and over.
调用 evaluate

1340
00:55:38,746 --> 00:55:39,945
'Kay? Especially if,
明白了吗？尤其是假如

1341
00:55:39,947 --> 00:55:43,581
I, let's say, introduced variable operands and,
我引入变量操作数，

1342
00:55:43,583 --> 00:55:45,550
hint that's what you're homeworks gonna be, then I wouldn't
提示你们下这个会留给你们当作业，

1343
00:55:45,552 --> 00:55:47,685
want to change the variables to different things and
而且我不想改变这些变量

1344
00:55:47,687 --> 00:55:49,520
be calling it over and
然后通过不同的值，比如变量

1345
00:55:49,521 --> 00:55:51,354
over with different values for the variable for example and
一直调用它

1346
00:55:51,357 --> 00:55:53,690
then maybe next week I can have an assignment where I'm
也许下周我会布置这么一个任务，

1347
00:55:53,692 --> 00:55:57,894
gonna make you graph such a thing, which I'm going to do.
让你们就画这样的东西，我会布置给你们的

1348
00:55:57,896 --> 00:55:59,012
Okay?

1349
00:55:59,013 --> 00:56:00,129
So that's why I wanna do that.
这就是我为什么想这么做

1350
00:56:00,131 --> 00:56:02,131
So anyway, yeah, remainder here can just be anything.
总而言之，这个 remainder 你想怎么写都行

1351
00:56:02,133 --> 00:56:03,532
I'm actually gonna put this here because we're
实际上，我这么写

1352
00:56:03,534 --> 00:56:05,300
gonna println this in a second just so
是想一会 println 它

1353
00:56:05,302 --> 00:56:06,567
we can get a better look at what's going on.
这样我们就可以明白它内部是如何运行的

1354
00:56:06,569 --> 00:56:10,904
But first, let's go back to our Controller and use this
接着，回到我们的 Controller

1355
00:56:10,906 --> 00:56:14,007
CalculatorBrain, this nice Model we just invented.
用 CalculatorBrain 这个刚刚建立的不错的 Model

1356
00:56:14,009 --> 00:56:15,842
Let's use it. Now,
我们现在就把它用上

1357
00:56:15,843 --> 00:56:17,676
I'm gonna show you how to get two things on screen at
我先教你们怎样让这两个页面同时

1358
00:56:17,679 --> 00:56:18,644
the same time.
显示在你的屏幕上

1359
00:56:18,646 --> 00:56:20,880
That aren't necessarily directly related.
它们之间不一定要直接相关

1360
00:56:20,882 --> 00:56:23,549
Before we have the Storyboard and then I went up and
之前我们用 Storyboard 的时候，移动鼠标

1361
00:56:23,551 --> 00:56:25,784
clicked this Assistant Editor right here and
点击右上角的 Assistant Editor 按钮

1362
00:56:25,786 --> 00:56:27,319
it showed me the Controller.
它显示的是一个对应的 Controller

1363
00:56:27,320 --> 00:56:28,853
Because the Assistant Editor figured out that, oh,
那是因为 Assistant Editor 这个编辑模块认为

1364
00:56:28,855 --> 00:56:30,388
if you have the Storyboard up you probably want
如果打开了 Storyboard，那么你可能想要打开

1365
00:56:30,390 --> 00:56:33,257
the Controller for the scene you have selected.
你选择的那个事件的 Controller

1366
00:56:33,259 --> 00:56:34,992
But here it's like, I don't know what to show you.
但是现在，这里没啥能显示的

1367
00:56:34,994 --> 00:56:36,827
So I'm gonna show you a different way to
现在我教教你们别的方法

1368
00:56:36,829 --> 00:56:39,229
get something in here, two ways actually.
来显示控制器界面，实际上是两种方法

1369
00:56:39,231 --> 00:56:41,931
One is if you go to this top bar where
看没看见 top bar 上

1370
00:56:41,933 --> 00:56:44,667
it says counterparts, you can mouse down and
counterparts 这个选项，

1371
00:56:44,669 --> 00:56:47,603
you can find all kinds of things about this
点击它你会发现更多选项

1372
00:56:47,605 --> 00:56:50,272
like subclasses of this class on the left.
比如左边代码这个类的子类

1373
00:56:51,341 --> 00:56:54,642
Superclasses of this class on the left.
这个类的父类

1374
00:56:54,644 --> 00:56:57,111
Of course it has no superclasses or subclasses.
当然了，它没有任何子类或者父类

1375
00:56:57,113 --> 00:57:00,547
But other things, things it includes are included by it.
还有其他的选项，比如它包含或包含它的一些文件

1376
00:57:00,549 --> 00:57:02,115
You can also just manually go in.
你也可以手动去找

1377
00:57:02,117 --> 00:57:03,283
We can go over here for example and
比如我们可以在里面浏览

1378
00:57:03,285 --> 00:57:06,152
find our ViewController and load it up that way, but
找到我们想要的 ViewController，并且打开它

1379
00:57:06,154 --> 00:57:09,088
I'm gonna show you a different way than doing that
先不要点，我给你们展示下第二种方法

1380
00:57:09,090 --> 00:57:11,423
which is to go over here to your navigator.
首先打开左侧的导航条，

1381
00:57:11,425 --> 00:57:14,893
If you hold down Option and press on
按住 Option 键，同时点击

1382
00:57:14,895 --> 00:57:18,663
a file like ViewController it will appear on the right.
一个文件，比如这个 ViewController，它就会显示在右边

1383
00:57:18,665 --> 00:57:20,464
'Kay?


1384
00:57:20,466 --> 00:57:22,866
So Option clicking in here is another good way to
按Option + 左键也能非常方便地把

1385
00:57:22,868 --> 00:57:23,767
put things on the right.
东西在右边打开

1386
00:57:25,437 --> 00:57:27,320
Okay?

1387
00:57:27,321 --> 00:57:29,204
So now here we have our CalculatorBrain on the left
现在 CalculatorBrain 显示在左边，

1388
00:57:29,207 --> 00:57:31,040
and we have our Controller on the right,
同时 Controller 显示在我们的右边

1389
00:57:31,042 --> 00:57:34,943
we are going to rip out all of the stuff in our
我们将删掉 Controller 里

1390
00:57:34,945 --> 00:57:39,180
Controller that had to do with being calculator.
那些以前写的计算用的代码

1391
00:57:39,182 --> 00:57:41,716
Okay, so that's all this stuff right in here.
那么要删的就是这些

1392
00:57:41,718 --> 00:57:43,484
'Kay.

1393
00:57:43,485 --> 00:57:45,251
All this calculating stuff, we don't need any of this
这些计算用的代码我们再也不需要了，

1394
00:57:45,254 --> 00:57:47,254
because those were only called from there.
因为那些代码只在刚删掉那调用

1395
00:57:47,256 --> 00:57:49,022
'Kay, so our Controller's getting quite simple,
我们的 Controller 变得更简洁了，

1396
00:57:49,024 --> 00:57:50,757
our Controller hardly has anything left in it.
几乎没剩下什么了

1397
00:57:50,759 --> 00:57:54,727
And that's because the UI only needs this to be controlled.
因为要想控制 UI 有这些就够了

1398
00:57:54,729 --> 00:57:56,579
'Kay?

1399
00:57:56,580 --> 00:57:58,430
We also don't need our operandStack because the brain is
我们也不需要我们 operandStack，因为 brain

1400
00:57:58,432 --> 00:58:00,766
gonna do that.
会处理这些东西

1401
00:58:00,767 --> 00:58:03,101
However, we do need a new instance variable here
但是这里得有一个新的实例变量

1402
00:58:03,103 --> 00:58:04,903
which is the CalculatorBrain.
就是 CalculatorBrain

1403
00:58:05,905 --> 00:58:07,838
Okay I'm just gonna create one like that,
我将会定义一个像那样的实例变量

1404
00:58:07,840 --> 00:58:12,676
this is extremely common, Okay? this is
这是非常常见的，

1405
00:58:12,678 --> 00:58:16,680
the green arrow that goes from the Controller to the Model.
这是之前讲 MVC 时候说到的从 Controller

1406
00:58:16,682 --> 00:58:18,948
Remember that in our MVC talk that I did last time I
指向 Model 那个绿色箭头

1407
00:58:18,950 --> 00:58:21,584
said that the Controller has a green arrow to the Model,
还记得 Controller 有个绿色的箭头指向 Model 吗

1408
00:58:21,586 --> 00:58:24,386
it can talk to it all it wants, say anything it wants.
Controller 可以给 Model 传递任何它想传递的信息

1409
00:58:24,388 --> 00:58:26,922
This is essentially that green arrow.
这段代码本质上来说就是那个绿色箭头

1410
00:58:26,924 --> 00:58:29,591
This is our Model right here.
这是我们的 Model

1411
00:58:29,593 --> 00:58:31,592
And this is the Controller this is how the Controller
这是 Controller，这就是 Controller 怎样

1412
00:58:31,594 --> 00:58:33,661
talks to it, through this thing we call the brain.
跟 Model 对话，通过我们称之为 brain 的这个东西

1413
00:58:33,663 --> 00:58:35,562
Thing you can call it anything you want and
这个 brain 你想怎么给他命名都行

1414
00:58:35,564 --> 00:58:38,298
of course this might be much more complicated green arrow,
当然了，这个绿色箭头可以表示相当复杂的东西

1415
00:58:38,300 --> 00:58:40,767
it might be a network database that is connecting to you to
它可能代表一个网络数据库，

1416
00:58:40,769 --> 00:58:41,934
get the data.
你可以和它进行链接并获取数据

1417
00:58:41,936 --> 00:58:43,102
Okay?

1418
00:58:43,104 --> 00:58:45,671
But in our case it's this very simple little brain.
但是在我们的例子中这是一个十分简单的小 brain

1419
00:58:45,673 --> 00:58:47,206
Okay.

1420
00:58:47,207 --> 00:58:48,740
So now we don't need this either down here.
我们也不需要下面这些代码了

1421
00:58:48,742 --> 00:58:51,343
This is where we're appending onto the opStack and
这是我们往 opStack 添加东西以及

1422
00:58:51,345 --> 00:58:52,044
printing it out.
把 opStack 打印出来的地方

1423
00:58:52,045 --> 00:58:52,744
So we don't need that.
我们也不需要这些

1424
00:58:52,746 --> 00:58:57,548
But we do need an enter() to push the operand onto
但是我们确实需一个 enter()

1425
00:58:57,550 --> 00:58:58,615
the stack.
来把 operand 压到栈里

1426
00:58:59,718 --> 00:59:00,516
Okay.

1427
00:59:00,518 --> 00:59:03,519
So here I'm just gonna say,
在这

1428
00:59:03,521 --> 00:59:08,657
that I'm gonna say I'm just gonna
我准备写

1429
00:59:08,659 --> 00:59:13,561
say brain.pushOperand(displayValue).
brain.pushOperand(displayValue)

1430
00:59:13,563 --> 00:59:15,413
'Kay?

1431
00:59:15,414 --> 00:59:17,264
That's the main thing I need to do, it's just do that.
这是我主要要做的，就这么做就好

1432
00:59:17,266 --> 00:59:21,902
One thing though is, I also need to update my display.
接下来我就需要更新 display 了

1433
00:59:21,904 --> 00:59:23,870
Because when I push this operand,
因为当我往栈里压这个 operand 时

1434
00:59:23,872 --> 00:59:25,672
that's gonna change the brain.
它会改变 brain

1435
00:59:25,674 --> 00:59:28,341
I need to call that evaluate, right?
我需要调用那个 evaluate ，对吧？

1436
00:59:28,343 --> 00:59:29,442
And get the value.
再得到它的值

1437
00:59:29,443 --> 00:59:30,542
So I could call evaluate here, but
我确实可以在这里调用 evaluate 但是


1438
00:59:30,544 --> 00:59:34,613
actually, I'm gonna go back to my brain, and I'm gonna change
实际上我们再看下 brain ，我将会改变

1439
00:59:34,615 --> 00:59:39,484
pushOperand to return the result of evaluating.
pushOperand 让它返回 evaluating 的结果

1440
00:59:39,486 --> 00:59:42,486
Typing today.
今天这字打的

1441
00:59:43,789 --> 00:59:46,623
From it, from its, from internally, so
从它的内部

1442
00:59:46,625 --> 00:59:48,991
I'm gonna return evaluate here.
evaluate 在这里返回

1443
00:59:48,993 --> 00:59:50,593
So that every time you push an operand,
所以每次你往栈里压一个 operand

1444
00:59:50,595 --> 00:59:52,127
it'll just return the evaluation.
它就会返回一个计算结果

1445
00:59:52,129 --> 00:59:55,163
Now one could argue whether this is the best thing to do.
现在有人或许会质疑这种方法是不是最好的

1446
00:59:55,165 --> 00:59:57,932
Because, you know, you might not be interested in
因为，你现在可能不会对

1447
00:59:57,934 --> 01:00:00,568
the result of evaluating that right now.
计算的结果感兴趣

1448
01:00:00,570 --> 01:00:03,671
But it kind of feels to me kind of good.
但我感觉蛮好的

1449
01:00:03,673 --> 01:00:05,339
And it's not gonna be,
而且

1450
01:00:05,341 --> 01:00:07,341
there's not gonna be that many things on the stack.
也不会有很多东西在栈上

1451
01:00:07,343 --> 01:00:10,143
You're not gonna usually have calculator brain
因为通常你的 calculator brain 不会有

1452
01:00:10,145 --> 01:00:12,712
have 1,000 operations and operands, although you could.
上千个操作符和操作数，虽然理论上可以这样

1453
01:00:12,714 --> 01:00:14,013
But you're not usually going to, so
但是你通常不会那样做

1454
01:00:14,015 --> 01:00:16,548
it's probably not a performance issue.
所以只返回这个应该不会是一个性能问题

1455
01:00:16,550 --> 01:00:19,751
To have it just return this and it'll make caller's code,
而且可以使调用部分的代码

1456
01:00:19,753 --> 01:00:22,320
you know, look a little simpler.
看起来简单些

1457
01:00:22,322 --> 01:00:24,522
And if they don't want this return value,
如果它们不想要这个返回值

1458
01:00:25,858 --> 01:00:27,808
then they can just ignore it.
它们可以直接忽略它

1459
01:00:27,809 --> 01:00:29,759
They don't have to use it but I am gonna use it.
它们没有必要用它，但我要用到

1460
01:00:29,762 --> 01:00:31,495
So, when I push this operand right here,
那么当我在这里将 operand 压栈

1461
01:00:31,497 --> 01:00:35,798
I'm gonna say, I'm gonna if let the results equal that.
我打算这样写 if let result ＝ 后面这些代码

1462
01:00:36,734 --> 01:00:38,000
Okay, because it's an Optional.
它是 Optional 的

1463
01:00:39,036 --> 01:00:41,836
And if it's not nil then I'm gonna
如果它不是 nil，我就可以

1464
01:00:41,838 --> 01:00:43,671
set the displayValue to the result.
把 result 的值赋给 displayValue

1465
01:00:43,673 --> 01:00:46,140
So in other words, every time I push an operand,
因此换句话说每次我往栈里压一个 operand

1466
01:00:46,142 --> 01:00:49,343
I'm gonna up my displayValue with the evaluation.
我将会把计算结果赋给我的 displayValue

1467
01:00:49,345 --> 01:00:50,811
Make sense?
能理解吗？

1468
01:00:50,813 --> 01:00:53,446
Okay, what if this comes back nil?
如果它是 nil 的话该怎么办？

1469
01:00:54,982 --> 01:00:56,615
So, I push something on,
我会往栈里压一些东西

1470
01:00:56,617 --> 01:00:59,151
this is not gonna happen probably with pushOperand(),
但这里应该不是调用 pushOperand()

1471
01:00:59,153 --> 01:01:02,587
but it might, and after your homework it might.
但也有可能是 nil， 在你们做过作业之后，可能会是

1472
01:01:02,589 --> 01:01:04,022
So, what if I push and it comes back nil?
所以，当我往栈里压并且返回是 nil 的时候怎么办？

1473
01:01:04,024 --> 01:01:07,258
Well, now I'm kinda stuck, Okay?
呵呵，现在我被难倒了

1474
01:01:07,260 --> 01:01:10,728
This is why, in your homework assignment, I suggested, wow
所以在你们的家庭作业中，我建议，

1475
01:01:10,730 --> 01:01:13,730
wouldn't it be cool if displayValue took an Optional.
如果 displayValue 是 Optional 该多好

1476
01:01:15,100 --> 01:01:17,600
Right, if displayValue took and returned an Optional.
对吧，如果 displayValue 是 Optional 并返回一个 Optional

1477
01:01:17,602 --> 01:01:20,769
You could put something sensible in the display when
当你有一些你无法计算的东西，

1478
01:01:20,771 --> 01:01:23,605
you had something that couldn't be evaluated.
你可以放一些合理的东西在你的 display 中

1479
01:01:23,607 --> 01:01:25,874
So in assignment two making displayValue into
所以在作业二中让 displayValue 是 Optional

1480
01:01:25,876 --> 01:01:27,809
an Optional is gonna be required task.
将会是要求之一

1481
01:01:27,811 --> 01:01:29,977
So you might as well do it for homework one,
你也可以在作业一中这样做

1482
01:01:29,979 --> 01:01:33,447
cuz you're gonna have to do it for homework two anyway.
因为你反正都要在作业二中这么做

1483
01:01:33,449 --> 01:01:35,182
Okay.

1484
01:01:35,183 --> 01:01:36,916
Just wanted to give you more time because I didn't
我只是想多给你们点时间

1485
01:01:36,917 --> 01:01:38,650
really teach you the things about NumberFormatter and
因为我没有在布置作业一之前

1486
01:01:38,653 --> 01:01:41,320
stuff in time for assignment one.
完整地教你们关于有关 NumberFormatter 的知识

1487
01:01:41,322 --> 01:01:44,623
But it's going to be required and that's because the best I
但是这将会是硬性要求，因为我最多只能告诉你们

1488
01:01:44,625 --> 01:01:48,093
can do here is maybe say displayValue equals zero.
令 displayValue 的值为 0

1489
01:01:48,095 --> 01:01:50,962
That's really lame but that's the best I can do.
那真的没什么道理，但是那是我也只能这样了

1490
01:01:50,964 --> 01:01:54,432
I really wanna say, displayValue was nil, Okay.
我也蛮想令 displayValue 为 nil 的

1491
01:01:54,434 --> 01:01:56,634
I really just wanna set displayValue equal to
我真的只想把 displayValue 等于

1492
01:01:56,636 --> 01:01:58,953
the result of this.
这段代码的结果

1493
01:01:58,954 --> 01:02:01,271
And I wanna have nil, you know, clear out my display or
我想设为 nil， 清除我的 display 或者

1494
01:02:01,274 --> 01:02:02,606
in assignment two,
在作业二中作为一个加分项

1495
01:02:02,608 --> 01:02:06,743
extra credit, maybe it puts an error message in my display.
让它在我的 display 上显示一段错误提示信息也好

1496
01:02:07,912 --> 01:02:09,545
Now that's extra credit, but
现在那是加分项，但是

1497
01:02:09,547 --> 01:02:11,246
that would be an even better thing to put there.
显示这么一段错误提示信息应该会更好

1498
01:02:12,216 --> 01:02:14,216
Okay?

1499
01:02:14,217 --> 01:02:16,217
But same thing for, for forming the operation.
但是形成运算也是一样的

1500
01:02:16,219 --> 01:02:17,652
Here's our operation right here.
这就是我们所做的操作

1501
01:02:17,654 --> 01:02:21,005
And I'm just gonna say,
我要说的是，

1502
01:02:21,006 --> 01:02:24,357
if I can let the result equals brains.performOperation of
如果把 result 置为 brain.performOperation()

1503
01:02:24,360 --> 01:02:27,361
the operation that I got off the button, then I'm going to
当松开按钮时， 那么

1504
01:02:27,363 --> 01:02:29,963
let my displayValue equal that result.
displayValue 应该等于之前所得的 result 值

1505
01:02:31,366 --> 01:02:34,667
Otherwise I'm going to do the very lame thing of
否则， 我们就要做一件很差劲的事

1506
01:02:34,669 --> 01:02:38,904
saying display value equals, whoops, value equals zero.
也就是将 displayValue 的值置为0.

1507
01:02:38,906 --> 01:02:40,389
Okay? Unders,
明白了么？明……

1508
01:02:40,390 --> 01:02:41,873
people understand why that's kind of lame?
大家都明白为什么这么做很差劲了么？

1509
01:02:41,875 --> 01:02:43,240
All right.
好的

1510
01:02:45,644 --> 01:02:47,077
Okay.

1511
01:02:47,079 --> 01:02:48,144
So that's it.
至此，

1512
01:02:48,146 --> 01:02:49,812
Look at how simple our Controller is here.
我们的 Controller 的实现非常简单

1513
01:02:49,814 --> 01:02:52,481
It has almost no code in it,Okay.
里面几乎没有代码

1514
01:02:52,483 --> 01:02:54,550
And that's really iOS is great about that.
这就是 iOS 开发的一个神奇之处

1515
01:02:54,552 --> 01:02:56,885
It really is pretty good about making it so
这是一个非常棒的体验，

1516
01:02:56,887 --> 01:02:58,920
that you can build your UI mostly graphically so
你可以图形化的创建大部分 UI

1517
01:02:58,922 --> 01:03:01,923
that there's very little code to control what's going on.
并且用非常少的代码来控制流程

1518
01:03:01,925 --> 01:03:03,491
And then even our Model,
对我们的模型来说，

1519
01:03:03,493 --> 01:03:05,759
which is a pretty powerful calculator right now,
目前是一个功能非常强大的计算器，

1520
01:03:05,761 --> 01:03:07,961
we could add as many functions as we wanted to.
我们可以随意添加各种方法

1521
01:03:07,963 --> 01:03:09,963
It's just one liners here.
只需要若干行代码

1522
01:03:09,965 --> 01:03:13,766
And it would be capable of,you know, evaluating any se,
它就可以计算任何

1523
01:03:13,768 --> 01:03:15,334
series of them that's evaluatable.
可计算的序列

1524
01:03:15,336 --> 01:03:18,003
And it's also set up to do your homework, Okay,
这也是你们的作业，

1525
01:03:18,005 --> 01:03:19,738
which is to add those variables,
添加这些变量，

1526
01:03:19,740 --> 01:03:22,140
to be able to push operand that are variables.
把操作符作为变量压栈

1527
01:03:22,142 --> 01:03:25,309
The other thing your homework is gonna ask you to do is to
另外一项作业需要你们做的是，

1528
01:03:25,311 --> 01:03:28,112
eval, to draw this, Okay,
把这些公式的内容

1529
01:03:28,114 --> 01:03:30,848
the contents of it in a human readable form.
转换成可读的形式

1530
01:03:30,850 --> 01:03:33,850
Using infix notation like this with parentheses when
像这样用中缀法

1531
01:03:33,852 --> 01:03:36,019
necessary, things like that and
必要时配合括号使用等类似的方法

1532
01:03:36,021 --> 01:03:37,820
that's gonna be a lot easier here too.
有了之前的铺垫，这个作业相当容易完成

1533
01:03:37,822 --> 01:03:39,055
Cuz you can recur,
因为你可以

1534
01:03:39,056 --> 01:03:40,289
use recursion, use recursion to build this as well.
使用递归来解决这个问题

1535
01:03:41,559 --> 01:03:43,725
Okay, so that's the main two things of
这就是我们的作业里

1536
01:03:43,727 --> 01:03:44,693
your homework that's what they are.
所要解决的两个主要问题

1537
01:03:44,695 --> 01:03:48,496
All right, so let's see if we broke anything here, all right,
现在来看看我们有没有出错的地方

1538
01:03:48,498 --> 01:03:50,064
so we're gonna go up here and run.
单击此处运行，

1539
01:03:52,168 --> 01:03:53,834
See if this all still works.
看是否仍然可以正常运行

1540
01:03:53,836 --> 01:03:55,101
Our UI has not changed.
我们的UI是没有变化的，

1541
01:03:55,103 --> 01:03:57,804
You notice I never even opened the Storyboard here.
你们可能注意到我在这里从来没有打开过 Storyboard

1542
01:03:57,806 --> 01:03:59,005
Didn't even open the Storyboard.
甚至没有打开过 Storyboard

1543
01:03:59,007 --> 01:04:01,607
Okay all these changes were pushing things out of
所有这些变动

1544
01:04:01,609 --> 01:04:03,175
the Controller into the Model.
Controller 改变了, Model 随之改变

1545
01:04:03,177 --> 01:04:04,510
Okay?The co,
好的

1546
01:04:04,511 --> 01:04:05,844
communication between the Controller and
所以, Controller 和 View

1547
01:04:05,846 --> 01:04:08,012
the View has not changed here.
之间的交互没有发生改变

1548
01:04:08,014 --> 01:04:10,915
So hopefully this is gonna work let's try 85, and
我们输入 85， 希望可以成功运行

1549
01:04:10,917 --> 01:04:13,083
our number entering is still working in
输入数字后，Controller 如期工作

1550
01:04:13,085 --> 01:04:15,252
our Controller that's good,Enter.
这是对的，

1551
01:04:15,254 --> 01:04:17,921
Okay it still says 85 that's good,
好的，程序说明 85 是可以的

1552
01:04:17,923 --> 01:04:22,224
how about 41 plus seems to actually be working.
那么试一试 41 ＋ ， 没有问题

1553
01:04:22,226 --> 01:04:23,325
Square root,
开平方根，

1554
01:04:23,327 --> 01:04:26,861
that's also working, nine times, excellent.
也没有问题， 再乘以 9， 非常好

1555
01:04:26,863 --> 01:04:28,813
That's working.
都可以得出正确结果

1556
01:04:28,814 --> 01:04:30,764
Now what if we do something that's not evaluatable?
现在，如果我们做一些不可计算的操作会怎样？

1557
01:04:30,767 --> 01:04:33,034
I'm going to press times a whole bunch of times.
我输入很多个乘号，

1558
01:04:33,036 --> 01:04:33,901
Right? Times, times.
乘，乘

1559
01:04:33,903 --> 01:04:35,736
Oh, times no, zero.
得出了 0

1560
01:04:35,738 --> 01:04:37,404
See that's not really great feedback.
可以看出这不是一个好的反馈

1561
01:04:37,406 --> 01:04:41,207
Okay? But, it's not really zero but
虽然结果不是 0，但是

1562
01:04:41,209 --> 01:04:43,642
it's, it's not good either.
也不是一个好的结果

1563
01:04:43,644 --> 01:04:46,912
So your homework is going to be printing out what's on
所以你们的作业是要

1564
01:04:46,914 --> 01:04:48,747
the stack in a nice form so
将栈中的内容，以一个合适的形式打印出来

1565
01:04:48,749 --> 01:04:50,548
you'll be able to see that you have times, times,
你们可以看到有很多乘号

1566
01:04:50,550 --> 01:04:53,918
times, and it's gonna equal a blank display.
将会得到一个空白输出

1567
01:04:53,920 --> 01:04:56,353
And that's gonna make sense that it's blank.
空白的输出是比较合理的

1568
01:04:56,355 --> 01:04:57,020
'Kay?
明白了么？

1569
01:04:57,022 --> 01:04:59,422
All right.
好了

1570
01:04:59,424 --> 01:05:01,724
Now, I wanna do one other thing here, though, just so
现在，我要做另外一件事，

1571
01:05:01,726 --> 01:05:03,659
you can really visualize what's going on,
让你们可以真正将整个过程视觉化

1572
01:05:03,661 --> 01:05:05,561
which is, I wanna print out,
那就是，

1573
01:05:05,563 --> 01:05:08,630
when we evaluate, I wanna print out this stack.
在计算时，我会打印出这些栈

1574
01:05:08,632 --> 01:05:10,265
I wanna print out the thing we're evaluating,
我希望打印出我们在计算的东西

1575
01:05:10,267 --> 01:05:12,934
I wanna print out the result,and I even wanna print out
打印结果，甚至

1576
01:05:12,936 --> 01:05:14,702
the remainder here so we can see what's going on.
希望打印出栈里剩下的， 这样我们就可以看到整个流程

1577
01:05:14,704 --> 01:05:17,471
So, I wanna say println.
所以，使用 println 函数

1578
01:05:17,473 --> 01:05:21,841
And I'm gonna say I'm gonna use my backslash thing here.
在这里用一个反斜杠

1579
01:05:21,843 --> 01:05:30,916
opStack equals result with how did I say this?
opStack 等于 result 加上...  应该怎么说，

1580
01:05:30,918 --> 01:05:32,685
With [NOISE], oh, yeah.
呃，对

1581
01:05:32,687 --> 01:05:36,688
With our remainder left over.
加上栈里剩下的元素

1582
01:05:37,857 --> 01:05:39,507
Okay.
好的

1583
01:05:39,508 --> 01:05:41,158
So wouldn't it be cool if I could just do this.
如果这样做，是不是很酷？

1584
01:05:41,160 --> 01:05:44,361
Just say, Okay, the opStack evaluated equals this
opStack 等于

1585
01:05:44,363 --> 01:05:47,064
result with the remainder left over.
结果加上剩下的 remainder

1586
01:05:47,066 --> 01:05:47,897
Okay?
好了吗？

1587
01:05:47,899 --> 01:05:48,765
Let's run that.
我们运行程序，

1588
01:05:48,766 --> 01:05:49,632
Do you think that's going to work?
你们认为程序会正常允许吗？

1589
01:05:51,302 --> 01:05:52,468
Maybe.Let's see.
可能会，让我们来看看

1590
01:05:52,470 --> 01:05:54,336
[BLANK_AUDIO]

1591
01:05:54,338 --> 01:05:56,204
Okay.
好的

1592
01:05:56,205 --> 01:05:58,071
So let's try putting eight on the stack.
我们试试把 8 放入栈中，

1593
01:05:59,709 --> 01:06:01,375
Okay?

1594
01:06:01,376 --> 01:06:03,042
Let's make so we can see this over here, where is it,
把窗口居中，这样看的更清楚

1595
01:06:03,045 --> 01:06:06,213
it's this probably right there, there it is.
大概在这个位置

1596
01:06:06,215 --> 01:06:08,114
We don't need that one Okay,so
我们不需要这个， 好

1597
01:06:08,116 --> 01:06:11,117
here is our Okay it's gonna be that, it's this.
这就是我们想要的结果

1598
01:06:11,119 --> 01:06:16,288
Okay, so it said here hm, enum value in, in an array, equals
这里写着，枚举值，在一个队列中， 等于

1599
01:06:16,290 --> 01:06:21,860
result of Optional(8), that's good, Optional(8) is good.
Optional(8)，很好，Optional(8) 是一个正确的结果

1600
01:06:21,862 --> 01:06:23,161
With nothing left over.
同时栈里没有其他东西

1601
01:06:23,163 --> 01:06:24,962
Okay, that's good.
Okay，没有问题

1602
01:06:24,964 --> 01:06:26,397
Let's go 6, Enter.
点击 6，然后点击 Enter

1603
01:06:26,399 --> 01:06:30,734
Oh, now we have enum enum on the stack equals Optional 6,
哦，现在我们的栈里有两个 enum  一个赋值为 Optional(6.0)

1604
01:06:30,736 --> 01:06:32,602
with enum left over.
另一个为 enum

1605
01:06:32,604 --> 01:06:33,936
Well that's not so good.
好吧，出问题了

1606
01:06:33,938 --> 01:06:38,807
Times enum, enum, enum equals it with, this is terrible.
点击 ×(乘号), enum, enum, enum 等于这个以及… 糟糕

1607
01:06:38,809 --> 01:06:40,342
This is, I can't understand what the heck is
这是怎么回事？

1608
01:06:40,344 --> 01:06:41,342
going on here.
到底为什么会是这样？

1609
01:06:41,344 --> 01:06:42,943
Why is this happening?
为什么会出现这些东西？

1610
01:06:42,945 --> 01:06:47,014
Okay, when you put something in parentheses like this,
Okay, 在圆括号中使用类似这样的东西

1611
01:06:47,016 --> 01:06:49,315
it tries to convert it to a String.
编译器会试图将它转化为 String

1612
01:06:49,317 --> 01:06:51,718
Okay, well the thing that's in here is an array.
但是括号里的代码却是一个 Array

1613
01:06:51,720 --> 01:06:54,520
Arrays know how to convert themselves to Strings.
Array 知道怎么将自己转化为 String

1614
01:06:54,522 --> 01:06:57,623
What they do is, they put open square bracket.
Array 所做的是，在最外层加上方括号

1615
01:06:57,625 --> 01:07:00,759
Then they ask every single  thing in the array,
然后将 Array 里的所有元素

1616
01:07:00,761 --> 01:07:04,462
convert yourself to a String O'kay, and it puts them here.
转化为 String, 然后 Array 将转换后的元素放在方括号中

1617
01:07:04,464 --> 01:07:07,298
Well our op is converting itself to this String.
所以，op 将自己转化成了这个 String

1618
01:07:07,300 --> 01:07:10,334
Enum Value 'kay?
Enum Value，看到没？

1619
01:07:10,336 --> 01:07:12,670
That's because the system doesn't really know how to
这是因为编译器并不知道

1620
01:07:12,672 --> 01:07:14,171
convert it any other way so
怎么将它（op）转换为其他的类型

1621
01:07:14,173 --> 01:07:15,872
it's just saying that's an enum value.
编译器仅仅把它当作一个枚举类型来处理

1622
01:07:15,874 --> 01:07:18,241
It doesn't know how to convert itself to a String.
它（op）不知道怎么将自己转化为 String

1623
01:07:18,243 --> 01:07:20,376
So, you see, see what's going on here?
现在，你们知道这是怎么回事了吗？

1624
01:07:20,378 --> 01:07:24,146
So, I'm going to show you how to teach a type to
接下来，我将给你们示范怎么让一种类型

1625
01:07:24,148 --> 01:07:26,381
turn itself into a String.
将自己转换为 String 类型

1626
01:07:26,383 --> 01:07:28,716
Okay, cuz that's really valuable for debugging and
Okay，因为这对程序的调试来说，是非常有用的，而且

1627
01:07:28,718 --> 01:07:30,651
also might be valuable for your homework.
可能对你们的作业有很大的参考价值

1628
01:07:33,756 --> 01:07:35,356
So, how we gonna do that?
那么，该怎么做呢？

1629
01:07:35,357 --> 01:07:36,957
All right, the way you do that is,
方法就是，

1630
01:07:36,959 --> 01:07:42,595
you have to add a computed property to your type.
你需要为你的类型添加一个 computed property (计算属性)

1631
01:07:42,597 --> 01:07:44,730
And enums, just like structs and
枚举、结构体和类一样

1632
01:07:44,732 --> 01:07:47,599
classes, can have properties,Okay?
也可以拥有属性，对么？

1633
01:07:47,601 --> 01:07:50,435
Only computed properties in enums, structs and
只有在枚举、结构体和类

1634
01:07:50,437 --> 01:07:53,104
classes can have properties that are values.
中的 computed properties (计算属性)可以有带值的属性

1635
01:07:53,106 --> 01:07:56,240
Like these, like this over here, all right.
比如这个，

1636
01:07:56,242 --> 01:07:57,408
But they can only be computed.
但是它们只能被计算

1637
01:07:57,410 --> 01:08:00,344
You remember a computed property looks like this, var.
一个 computed property (计算属性)应该是这样，var

1638
01:08:00,346 --> 01:08:01,929
The name of it.
它的名字

1639
01:08:01,930 --> 01:08:03,513
It has to be called description because
它必须被称为 description，因为

1640
01:08:03,515 --> 01:08:05,081
it's gonna be a String description of it.
这将是计算属性（computed property）的文字描述

1641
01:08:05,083 --> 01:08:07,517
The type has to be String.
它的类型必须是 String 类型

1642
01:08:07,519 --> 01:08:09,418
It's a String description of it.
这个字符串是计算属性的一个文字描述

1643
01:08:09,420 --> 01:08:12,588
And then of course you want your get here.
然后，可以使用 get 方法

1644
01:08:12,590 --> 01:08:18,360
And, whoops, your get and your set set.
你们自己写的 get 方法和 set 方法

1645
01:08:18,362 --> 01:08:21,896
But it has to not only be a computed property.
但是它不可能仅仅只是一个 computed property

1646
01:08:21,898 --> 01:08:24,165
This description thing to make this work.
为了让这个 description 起作用

1647
01:08:24,167 --> 01:08:26,900
It wants to be a read only one.
它需要是一个只读的属性

1648
01:08:26,902 --> 01:08:28,068
So we're not going to put the set,
所以，我们不要 set 方法，

1649
01:08:28,070 --> 01:08:29,769
so there will be no set, just a get.
没有 set 方法，仅仅是一个 get 方法

1650
01:08:30,805 --> 01:08:36,108
So this get just has to return this op as a String, so
因此，这个 get 方法仅需将 op 作为 String 返回，

1651
01:08:36,110 --> 01:08:38,176
I say someone turned it into a String.
所以说得有人将它转化为 String

1652
01:08:38,178 --> 01:08:40,045
Well how would we turn our op into a String.
我们到底怎么将 op 转化为 String呢？

1653
01:08:40,047 --> 01:08:44,749
Well for the operations we're just gonna return the symbol.
对于操作符，返回符号

1654
01:08:44,751 --> 01:08:47,484
Okay if this is a plus operation turning into
如果这是一个加法运算，将它转化

1655
01:08:47,486 --> 01:08:49,052
String is I'm just gonna  return a plus,
为 String 的操作是返回 +（加号），

1656
01:08:49,054 --> 01:08:53,389
cuz that pretty well describes a plus operation, a plus.
因为一个加号很好的描述了一个加法操作

1657
01:08:53,391 --> 01:08:55,224
For the operand,
对于操作数，

1658
01:08:55,225 --> 01:08:57,058
I'm gonna have to turn this Double into a String.
我要将 Double 类型 转化为 String类型

1659
01:08:57,061 --> 01:08:58,627
And return that.
并返回这个 String

1660
01:08:58,629 --> 01:08:59,528
Okay so how am I gonna do that?
怎么去实现这个转换呢？

1661
01:08:59,530 --> 01:09:03,131
I'm gonna do that using switch,
可以使用 switch 来实现它

1662
01:09:03,133 --> 01:09:05,867
I need to switch on myself.
我需要把自己作为 switch 的参数

1663
01:09:07,070 --> 01:09:09,837
Okay cuz I'm gonna do this switch so that I can get these
因为我要用 switch ，所以，

1664
01:09:09,839 --> 01:09:12,939
same things out here, and you do the same thing I did here,
相同的代码部分提取出来，你们跟着我做，

1665
01:09:12,941 --> 01:09:14,307
see how I did this switch.
注意我怎么实现这个 switch

1666
01:09:14,309 --> 01:09:16,309
So I could get these associated values out.
以便我可以获取这些相关的值

1667
01:09:16,311 --> 01:09:18,177
I'm gonna do the same thing here.
我将要在这里做相同的事情

1668
01:09:18,179 --> 01:09:20,512
So how do I switch on my self?
怎么把自己作为 switch 的参数呢？

1669
01:09:20,514 --> 01:09:23,415
I say switch self.
那就是 switch self

1670
01:09:23,417 --> 01:09:24,716
'Kay?
看到了没？

1671
01:09:24,718 --> 01:09:28,019
And then I just have to say the case for Operand.
然后，我仅需要写下 Operand 的 case

1672
01:09:28,021 --> 01:09:29,987
And I'll let that be the operand.
再写一句 let operand

1673
01:09:29,989 --> 01:09:33,657
And I have to do the case for UnaryOperation.
然后，UnaryOperation 的 case

1674
01:09:33,659 --> 01:09:34,624
Now when I do the case for
现在，当我处理 UnaryOperation 的 case 时，

1675
01:09:34,626 --> 01:09:37,493
UnaryOperation, I want the symbol.
我需要符号

1676
01:09:37,495 --> 01:09:40,529
But I don't care about the function.
但是我并不关心实际的运算

1677
01:09:40,531 --> 01:09:42,831
Cuz I'm not actually gonna compute anything.
因为在这里我不会进行任何计算

1678
01:09:42,833 --> 01:09:45,500
I'm just going to return the symbol.
我只是返回符号

1679
01:09:45,502 --> 01:09:47,469
And then for BinaryOption same, same, Operation
BinaryOperation 也一样

1680
01:09:47,471 --> 01:09:51,972
same thing I want the symbol  but I don't want this.
我仅需要符号，不需要这些

1681
01:09:51,974 --> 01:09:53,307
So that's the, the don't care.
所以，忽略这些东西

1682
01:09:53,309 --> 01:09:55,609
And what am I gonna do in each of these cases?
在每个 case 中我要做什么？

1683
01:09:55,611 --> 01:10:01,080
Well in the operand case I'm gonna return a String that
在 operand 的 case 中，我将

1684
01:10:01,082 --> 01:10:02,848
is that operand.
返回这个操作数的 String

1685
01:10:02,850 --> 01:10:06,251
Oops, don't like the way it puts that extra thing
Oops, 不喜欢编辑器在这里添加额外代码的方法

1686
01:10:06,253 --> 01:10:06,985
on there.
还有这里

1687
01:10:06,987 --> 01:10:08,286
Okay.

1688
01:10:08,287 --> 01:10:09,586
And then in the UnaryOperation case I'm
在 UnaryOperation 的 case 中，我将

1689
01:10:09,589 --> 01:10:11,522
just gonna return the symbol.
返回符号

1690
01:10:11,524 --> 01:10:13,390
And in the BinaryOperation case I'm also just
在 BinaryOperation 的 case 中，因为我也只是

1691
01:10:13,392 --> 01:10:14,224
gonna return the symbol.
返回符号

1692
01:10:14,226 --> 01:10:19,329
And we have, oops, don't want  the parentheses there.
那么…噢, 不需要这个括号

1693
01:10:19,331 --> 01:10:22,965
Kay and we've covered every case of this switch.
我们覆盖了 switch 的每一个 case

1694
01:10:22,967 --> 01:10:25,735
So not only does it know that this switch is covered but
现在它（description）不仅知道这个 switch 覆盖了所有情况

1695
01:10:25,737 --> 01:10:28,604
it knows that we for sure have returned something out of
而且它知道我们肯定会从这里返回一些东西，

1696
01:10:28,606 --> 01:10:31,506
here, because we only have one expression here which is
因为我们这里只有一个表达式，即 Swift（口误）， 不，

1697
01:10:31,508 --> 01:10:34,909
this Swift and switch and we know that covers every case.
switch，并且我们知道 switch 覆盖了所有 case

1698
01:10:34,911 --> 01:10:36,377
So there goes so we have this  nice description.
现在，我们有了一个很好的 description.

1699
01:10:36,379 --> 01:10:40,814
Now this is not quite enough O'kay?
但是，这还不够，

1700
01:10:40,816 --> 01:10:42,916
You have to implement this  property,
比必须实现这个 property（属性），

1701
01:10:42,918 --> 01:10:44,784
this computed property  read-only.
这个 computed property 是只读的

1702
01:10:44,786 --> 01:10:46,652
But if you do one other thing,
但如果我们在这里

1703
01:10:46,654 --> 01:10:50,456
which is up here, you have to put, colon Printable.
放一个 : Printable

1704
01:10:51,859 --> 01:10:56,961
Now, I told you enums and structs have no inheritance.
enum 和 struct 没有继承

1705
01:10:56,963 --> 01:10:58,696
So you're like what, wait a second, there.
等一下，看这里

1706
01:10:58,698 --> 01:11:01,098
You're telling me op inherits from Printable?
你竟然告诉我让 op 继承于 Printable?

1707
01:11:01,100 --> 01:11:04,234
And the answer is no, does not inherit, Okay, it's an enum.
不是这样的，这里不是继承

1708
01:11:04,236 --> 01:11:07,070
Enums don't have any inheritance, only classes do.
enum 没有继承关系，只有 class 有

1709
01:11:07,072 --> 01:11:10,540
What this colon Printable  means is, and
这个 : Printable 代表

1710
01:11:10,542 --> 01:11:12,842
this can be true for classes or structs or whatever.
这个也可以对 class 或者 struct 有效

1711
01:11:12,844 --> 01:11:14,643
You can put after the colon here.
在这里的冒号后面写

1712
01:11:15,713 --> 01:11:17,979
This is called a protocol.
这个叫做 protocol

1713
01:11:17,981 --> 01:11:21,215
And all this means is you're telling Swift that this
这就代表，你告诉 Swift，

1714
01:11:21,217 --> 01:11:24,852
enum implements whatever is in this protocol.
这个 enum 需要自己实现这个 protocol 的内容

1715
01:11:24,854 --> 01:11:28,389
And this protocol happens to just be one computed
这个 protocol 恰好有一个叫做 description 的 computed property

1716
01:11:28,391 --> 01:11:30,590
property called Description that returns the String.
用来返回一个 String

1717
01:11:31,826 --> 01:11:33,326
Okay?

1718
01:11:33,327 --> 01:11:34,827
Now we're going to talk about protocols in depth.
我们会深入了解 protocol

1719
01:11:34,829 --> 01:11:37,062
Because protocols are very important for
因为 protocol 能够帮助我们了解，

1720
01:11:37,064 --> 01:11:40,065
explaining how things work 'kay?
这到底是怎么一回事儿

1721
01:11:40,067 --> 01:11:43,501
But we're not gonna cover it  today, though.
但是我们今天不会讲

1722
01:11:43,503 --> 01:11:46,204
Okay, so if you do those two things, put description in
如果我这么做，加上 Printable

1723
01:11:46,206 --> 01:11:52,209
Printable, now when we run, you'll see, I'll go 5 enter.
再运行程序，5 enter，6,

1724
01:11:52,211 --> 01:11:54,511
Six, and you see it's put a five in there.
你就会看到这里有个 5

1725
01:11:54,513 --> 01:11:55,512
There's a 6.
这是 6

1726
01:11:55,514 --> 01:11:57,447
Times, it's even putting the times.
乘，它把乘号也放进去了

1727
01:11:57,449 --> 01:11:59,915
If I hit times again, now I get nil and
如果我再点乘，这里得到了 nil

1728
01:11:59,917 --> 01:12:03,652
it shows me the whole thing is left over, Okay.
剩下所有的东西都显示了

1729
01:12:03,654 --> 01:12:06,454
Let's go another thing here,
再来一个测试

1730
01:12:06,456 --> 01:12:10,358
what if I go 6 Enter 5 Enter 4 Enter.
输入 6 enter 5 enter 4 enter

1731
01:12:10,360 --> 01:12:13,661
Now if I do times it says  times of 4 and
再做一次乘法，它出现 4 * 5 = 20

1732
01:12:13,663 --> 01:12:18,098
5 is 20 with the 6 left over, exactly right.
6 被剩下了，这都是正确的

1733
01:12:19,134 --> 01:12:22,368
Kay now notice I had to rerun there to do that,
为了这么做我得重新运行一次，

1734
01:12:22,370 --> 01:12:24,303
you're gonna have a clear button right,
你得在这里放置一个清除按钮

1735
01:12:24,305 --> 01:12:25,571
that you do in assignment one,  you're gonna have to
这是你们在作业一里完成的，你们需要

1736
01:12:25,573 --> 01:12:27,239
make that work in assignment two as well.
作业二里令这个按钮工作起来

1737
01:12:28,308 --> 01:12:31,309
Okay the last thing really out of time but I'm gonna show you
最后一件事，快没时间了

1738
01:12:31,311 --> 01:12:34,311
the last thing really quickly that I was gonna do is use
我快速给你们展示一下

1739
01:12:34,313 --> 01:12:38,182
this description to fix this problem I said right here.
利用 description 来回答我留在这里的问题

1740
01:12:38,184 --> 01:12:41,385
Which is what if I had a  function called learn
定义一个叫 learn 的函数

1741
01:12:41,387 --> 01:12:45,388
op 'kay and it took an op as an argument here.
它把 op 作为参数

1742
01:12:45,390 --> 01:12:53,029
And it just said known ops ops description equals that op.
knownOps[op.description] = op

1743
01:12:53,031 --> 01:12:59,368
You see, now these could all just be learn op this.
这些都可以变成 learnOp()

1744
01:13:00,404 --> 01:13:03,438
Okay which is a lot nicer, I only have to type this thing
这看起来就好多了，我只需要把它敲一次

1745
01:13:03,440 --> 01:13:05,306
once, and I just use the description here.
我在这里用到了 description

1746
01:13:05,308 --> 01:13:08,875
he other thing about this, notice where this function is.
另一点，注意这个函数的位置

1747
01:13:08,877 --> 01:13:10,143
Inside the init.
它在 init 内部

1748
01:13:11,246 --> 01:13:12,545
Okay you are allowed to
你可以在

1749
01:13:12,547 --> 01:13:14,513
put functions inside other functions.
一个函数的内部放另一个函数

1750
01:13:14,515 --> 01:13:17,549
If this is only called inside here, you can put it in here.
如果只在内部被调用，你可以这么做

1751
01:13:17,551 --> 01:13:20,518
If if I put it outside in fact   I'd have a little a problem,
如果我把它放到外部，就会有点小问题

1752
01:13:20,520 --> 01:13:22,387
because it would have to be private.
它得是 private 的

1753
01:13:22,389 --> 01:13:26,390
Because it uses op, and that's what this error right here is.
因为它用到了 op，就好像这里的 error 提示的那样

1754
01:13:26,392 --> 01:13:29,460
All right I'd have say private func, but I don't want to do
我得把它变成 private 的，但是我不想这么做

1755
01:13:29,462 --> 01:13:32,462
private func, instead I'm just gonna put this right down
所以我把它放到这里

1756
01:13:32,464 --> 01:13:35,131
here, Okay and obviously I would do that one last.
显然，我最后还是把它放在这里

1757
01:13:35,133 --> 01:13:37,333
Okay that's it, hope you learned a lot and
这就是今天所要讲的，希望你们能学到很多知识

1758
01:13:37,335 --> 01:13:40,236
stuff elsewhere for that and I will see you on Wednesday,
周三再见

1759
01:13:40,238 --> 01:13:42,037
I'm here if you have questions.
如果有问题，来找我，我都在的

1760
01:13:44,074 --> 01:13:47,976
For more, please visit us at stanford.edu.
想了解更多，请登录 stanford.edu
